% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\index{rayTracing}
The ray tracing method involves 4 steps \cite{}:
\begin{enumerate}
\item the ray coordinates are transformed into the coordinate system of the surface their interact with,
\item he intersection of the ray with the surface is found,
\item the directions of the ray after the surface is computed according to Snell''s law,
\item the coordinates and directions of the ray is transformed back into its original coordinate systems
\end{enumerate}

\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<rayTracing.h>>=
#ifndef __RAYTRACING_H__
#define __RAYTRACING_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

#define SNELL_N_ITERATION 100
#define TOL 1E-9
#define N_THREAD 16
#define N_THREAD2 256

<<ray tracing data type>>

<<vector data type>>

<<ray data type>>

<<coordinate system data type>>

<<ray bundle structure>>

<<conic structure>>

<<zernikeS structure>>

__host__ __device__  rtd zernike_surface(rtd r, rtd o, int max_n, rtd *a);
__host__ __device__  rtd zernike_surface_x_derivative(rtd r, rtd o, int max_n, rtd *a);
__host__ __device__  rtd zernike_surface_y_derivative(rtd r, rtd o, int max_n, rtd *a);
int zern_dx_coef(rtd *b, int j, int n, int m, int jp, int np, int mp);
int zern_dy_coef(rtd *b,int j, int n, int m, int jp, int np, int mp);

<<conic equations>>

<<aperture structure>>
__global__ void intersection(char *mask, ray *d__ray, int N_RAY);

__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
				   rtd *d__R, vector *d__origin);
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
					    rtd *d__R);
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin);
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
					     rtd *d__R);


#endif // __RAYTRACING_H__
@ 
\subsection{Source}
\label{sec:source}

<<rayTracing.cu>>=
#include "rayTracing.h"

<<vector functions>>
<<coordinates forward transform>>
<<coordinates backward transform>>

<<to z plane kernel>>
<<to sphere kernel>>
<<reference sphere origin from chief ray>>
<<ray bundle kernels>>
<<bundle reset kernel>>
<<zernike surface kernel>>
<<zernike projection kernel>>
<<aperture intersection>>

<<ray bundle functions>>

<<coordinate system functions>>

<<conic functions>>

<<zernikeS functions>>

<<zernike surface equation>>
<<zernike derivative x coefficient>>
<<zernike derivative y coefficient>>

<<vignetting kernel>>
<<aperture functions>>


@ 
\subsection{Python}
\label{sec:python}

\index{rayTracing!python}

<<rayTracing.pxd>>=
cdef extern from "rayTracing.h":
    ctypedef double rtd
    ctypedef struct vector:
        rtd x
        rtd y
        rtd z
    ctypedef struct ray:
        vector coordinates
        vector directions
        vector surface_normal
        rtd optical_path_length
<<rayTracing.pxd contents>>
<<class definitions>>
@ 
<<rayTracing.pyx>>=
import numpy as np
cimport numpy as np
from utilities cimport cuDoubleArray
@
\subsubsection{Ray bundle}
\label{sec:ray-bundle-1}

\index{rayTracing!python!Bundle}

<<rayTracing.pxd contents>>=
    cdef cppclass bundle:
        int N_RAY, N_BUNDLE
	int *d__piston_mask
        rtd *d__sphere_radius
        rtd *d__sphere_distance
        vector *d__sphere_origin
        ray *d__ray
	ray *d__chief_ray
        void setup(rtd, int, int , vector, int)
        void setup(rtd, int , vector, int)
        void cleanup()
        void to_z_plane(rtd)
        void to_sphere(vector)
        void to_sphere(rtd , rtd)
        void get_coordinates(double *)
        void get_chief_coordinates(double *)
        void get_directions(double *)
        void get_chief_directions(double *)
        void get_optical_path_length(double *)
        void get_chief_optical_path_length(double *)
        void get_optical_path_difference(double *)
        void get_optical_path_difference(double *,
					 float , int , 
					 float , int )
        void get_vignetting(double *)
	void get_n_iteration(int *)
@
<<class definitions>>=
from utilities cimport cuFloatArray, cuDoubleArray, cuIntArray
from source cimport Source
# Bundle
cdef class Bundle:
    cdef bundle *_c_bundle
    cdef cuDoubleArray _coordinates_
    cdef cuDoubleArray _chief_coordinates_
    cdef cuDoubleArray _directions_
    cdef cuDoubleArray _chief_directions_
    cdef cuDoubleArray _optical_path_length_
    cdef cuDoubleArray _chief_optical_path_length_
    cdef cuDoubleArray _optical_path_difference_
    cdef cuDoubleArray _vignetting_
    cdef cuIntArray _n_iteration_
    cdef public cuDoubleArray sphere_radius
    cdef public cuDoubleArray sphere_distance
    cdef double[:,::1] _d__sphere_origin_
    cdef cuIntArray _piston_mask_
<<rayTracing.pyx>>=
# polar bundle
from scipy.optimize import brentq
from ceo.constants import ARCSEC2RAD
cdef class Bundle:
    """
    A class to represent a bundle of rays    

    This class is usually instanciated by the Source class

    Parameters
    ----------
    src : Source
        The Source object that contains the pointer to CEO bundle structure

    Attributes
    ----------
    N_BUNDLE : int, read only
        The number of ray bundle
    coordinates : cuDoubleArray, read only
        The coordinate vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_coordinates : cuDoubleArray, read only
        The coordinate vector of the chief ray
    directions : cuDoubleArray, read only
        The direction vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_directions : cuDoubleArray, read only
        The direction vector of the chief ray
    optical_path_length : cuDoubleArray, read only
        The optical path lengths of the rays as a N_BUNDLExN_RAY array
    chief_optical_path_length : cuDoubleArray, read only
        The optical path length  of the chief ray
    optical_path_difference : cuDoubleArray, read only
        The optical path differences of the rays as a N_BUNDLExN_RAY array
    vignetting : cuDoubleArray, read only
        The vignetting flag of the rays as a N_BUNDLExN_RAY array
    sphere_radius : cuDoubleArray, read only
        The radius of the reference sphere used to compute the optical path difference
    sphere_distance : cuDoubleArray, read only
        The distance from the last surface to the reference sphere used to compute the optical path difference
    piston_mask : numpy ndarray
        A 7 columns array where each column is a mask corresponding to 1 segment
    """

    def __cinit__(self, Source src):
        self._c_bundle = new bundle()
        self._c_bundle = &(src._c_source.rays)

        self._coordinates_               = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_coordinates_         = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._directions_                = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_directions_          = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._optical_path_length_       = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._chief_optical_path_length_ = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=True)
        self._optical_path_difference_   = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._vignetting_                = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._n_iteration_                = cuIntArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)

        self.sphere_radius = cuDoubleArray( shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=False)
        self.sphere_radius._c_gpu.dev_data = self._c_bundle.d__sphere_radius
        self.sphere_distance = cuDoubleArray( shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=False)
        self.sphere_distance._c_gpu.dev_data = self._c_bundle.d__sphere_distance

        self._piston_mask_ = cuIntArray(shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY))
        self._piston_mask_._c_gpu.dev_data = self._c_bundle.d__piston_mask;

    <<bundle common>>
@ 
<<bundle common>>=
"""
def __dealloc__(self):
    self._c_bundle.cleanup()
"""

def to_z_plane(self,rtd z_plane):
    """
    Propagates the rays to a given plane

    Parameters
    ----------
    z_plane : double
        The z coordinates of the plane
    """
    self._c_bundle.to_z_plane(z_plane)

def to_sphere(self, sphere_origin=None,
              rtd focal_plane_distance=0.0, 
              rtd focal_plane_radius=0.0):
    """
    Computes the optical path difference with respect to the reference sphere

    Parameters
    ----------
    sphere_origin : list of double, optional
        A 3 elements list containing the x,y and z coordinates of the sphere center; default: None
    focal_plane_distance : double, optional
        The location of the focal plane on the optical axis; default: 0.0
    focal_plane_radius : double, optional
        The radius of curvature of the focal plane; default: 0.0

    """
    cdef vector origin
    if sphere_origin is not None:
        origin.x = <double>sphere_origin[0]
        origin.y = <double>sphere_origin[1]
        origin.z = <double>sphere_origin[2]
        self._c_bundle.to_sphere(origin)

    if focal_plane_distance!=0.0:
        self._c_bundle.to_sphere(focal_plane_distance, focal_plane_radius)

def to_focal_plane(self, rtd focal_plane_distance):
    self._c_bundle.to_z_plane(focal_plane_distance)

def get_optical_path_difference(self,
                                float delta_x, int N_x,
                                float delta_y, int N_y):
    opd = cuDoubleArray(shape=(N_x,N_y),dev_malloc=True)
    self._c_bundle.get_optical_path_difference(opd._c_gpu.dev_data,
                                               delta_x, N_x,
                                               delta_y, N_y)
    return opd

def ee80(self,spaxel="circle"):
    """
    Computes the size of the geometric EE80 square 

    Parameters
    ----------
    spaxel : char, optional
        The spaxel geometry, square or circle; default: circle

    Returns
    -------
    float
        The size of the geometric EE80 square in radian
    """
    assert(spaxel=="circle" or spaxel=="square","spaxel is either a circle or a square!")
    V = self.vignetting.host().flatten()==1
    xyz = self.coordinates.host()
    x = np.abs( xyz[V,0] )
    y = np.abs( xyz[V,1] )
    r = np.hypot(x,y)
    def ensquared(hd):
        idx = np.logical_and(x<=hd , y<=hd)
        return float(idx.sum())/V.sum()
    def encircled(hd):
        idx = r<=hd
        return float(idx.sum())/V.sum()
    if spaxel=="circle":
        f = lambda x: encircled(x)-0.8
	b = r.max()
    else:
        f = lambda x: ensquared(x)-0.8
	b = np.maximum(x.max(),y.max())
    try:
        return 2*brentq(f,0,b)*(ARCSEC2RAD/1e-3)
    except ValueError:
        return np.float('inf')


property N_BUNDLE:
    def __get__(self):
        return self._c_bundle.N_BUNDLE

property coordinates:
    def __get__(self):
        self._c_bundle.get_coordinates(self._coordinates_._c_gpu.dev_data)
        return self._coordinates_

property chief_coordinates:
    def __get__(self):
        self._c_bundle.get_chief_coordinates(self._chief_coordinates_._c_gpu.dev_data)
        return self._chief_coordinates_

property directions:
    def __get__(self):
        self._c_bundle.get_directions(self._directions_._c_gpu.dev_data)
        return self._directions_

property chief_directions:
    def __get__(self):
        self._c_bundle.get_chief_directions(self._chief_directions_._c_gpu.dev_data)
        return self._chief_directions_

property optical_path_length:
    def __get__(self):
        self._c_bundle.get_optical_path_length(self._optical_path_length_._c_gpu.dev_data)
        return self._optical_path_length_

property chief_optical_path_length:
    def __get__(self):
        self._c_bundle.get_chief_optical_path_length(self._chief_optical_path_length_._c_gpu.dev_data)
        return self._chief_optical_path_length_

property optical_path_difference:
    def __get__(self):
        self._c_bundle.get_optical_path_difference(self._optical_path_difference_._c_gpu.dev_data)
        return self._optical_path_difference_

property vignetting:
    def __get__(self):
        self._c_bundle.get_vignetting(self._vignetting_._c_gpu.dev_data)
        return self._vignetting_

property n_iteration:
    def __get__(self):
        self._c_bundle.get_n_iteration(self._n_iteration_._c_gpu.dev_data)
        return self._n_iteration_

property piston_mask:
    def __get__(self):
        P = self._piston_mask_.host()
        return [ np.array( [P[kk,:].flatten()==k for k in range(1,8)] ) for kk in range(self._piston_mask_.shape[0])]
@

\subsubsection{Coordinate system}
\label{sec:coordinate-system-1}

\index{rayTracing!python!Coordinate\_system}

<<rayTracing.pxd contents>>=
    cdef cppclass coordinate_system:
        vector *origin
        vector *euler_angles
        rtd *R
        char *tag
        void update()
<<class definitions>>=
cimport numpy as np
cdef class Quaternion:
    cdef:
        public np.ndarray qw, qx, qy, qz
cdef class Coordinates:
    cdef:
        double[:,::1] data
        public list data_log
        vector *v
        public int log
cdef class Coordinate_system:
    cdef:
        coordinate_system *_c_coordinate_system
        double[:,:,::1] _R_
        int N
        public Coordinates origin, euler_angles
        public bytes tag
    cdef void init(Coordinate_system, coordinate_system *)
@
<<rayTracing.pyx>>=
# coordinate_system
cdef class Coordinate_system:
    """
    A class for the coordinate system origins and euler angles

    Attributes
    ----------
    N : int
        The number of coordinate systems
    origin : Coordinates
        The origin of the coordinate system(s)
    euler_angles : Coordinates
        The euler angles of the coordinates system(s)
    R : ndarray
        The rotation natrix of the coordinate systems as a [N,3,3] array
    """

    def __cinit__(self, int N=1):
        self.N = N
        self._c_coordinate_system = new coordinate_system()
        self.origin = Coordinates((self.N,3))
        self.euler_angles = Coordinates((self.N,3))

    cdef void init(self, coordinate_system *cs):
        self._c_coordinate_system = cs
        self.origin.v = cs.origin
        self.euler_angles.v = cs.euler_angles
        self.tag = cs.tag

    def update(self):
        """
        Updates the coordinate systems on the device
        """
        self._c_coordinate_system.update()

    property R:
        def __get__(self):
            self._R_ = <double[:self.N,:3,:3]>self._c_coordinate_system.R
            return np.array(self._R_)
@
\paragraph{Coordinates}
\label{sec:coordinates}

\index{rayTracing!python!Coordinates}

<<rayTracing.pyx>>=
# Coordinates
cdef class Coordinates:
    """
    An interface between an array of device vectors and an array of host coordinates

    Examples
    --------
    >>> import ceo
    >>> gmt = ceo.GMT_MX(25.5,256, M1_radial_order=8, M2_radial_order=14)

    The origin of M1 segment in the motion coordinate system is a Coordinates object

    >>> print gmt.M1.motion_CS.origin

    to retrieve the origin values:

    >>> print gmt.M1.motion_CS.origin[:]

    Segment 1 is moved along the y-axis of 1mm:

    >>> gmt.M1.motion_CS.origin[0,1] = 1e-3

    All the segments are resetted to their nominal position with

    gmt.M1.motion_CS.origin[:] = 0
    """
    def __cinit__(self,tuple shape):
        self.data =  np.zeros(shape, dtype=np.float64)
        self.log = 0
        self.data_log = []

    def __getitem__(self,index):
        cdef int k
        for k in range(self.data.shape[0]):
            self.data[k,0] = self.v[k].x
            self.data[k,1] = self.v[k].y
            self.data[k,2] = self.v[k].z
        return np.array( self.data.__getitem__(index) )

    def __setitem__(self,index,value):
        self.data.__setitem__(index,np.array(value))
        cdef int k
        for k in range(self.data.shape[0]):
            self.v[k].x = self.data[k,0]
            self.v[k].y = self.data[k,1]
            self.v[k].z = self.data[k,2]
        if self.log>0:
            if len(self.data_log)>self.log:
                self.data_log.pop(<int>0)
            self.data_log.append(np.array(self.data))

    def __repr__(self):
        data = np.array(self.data)
        return data.__repr__()

    def __str__(self):
	max_abs_data = np.max(np.abs(self[:]))
        if  max_abs_data!=0:
            exp = np.floor(np.log10(max_abs_data))
        else:
            exp = 0
        s = np.array_str(np.asarray(self.data)*(10**-exp),precision=2,suppress_small=True)
        return "@(CEO)>Coordinates:\nX,Y,Z coordinates in meter: 10^%dX\n"%exp + s

    property shape:
        def __get__(self):
            return self.data.shape

    property size:
        def __get__(self):
            return self.data.size
@
\paragraph{Quaternions}
\label{sec:quaternions}

\index{rayTracing!python!Quaternions}

<<rayTracing.pyx>>=
# Quaternion
cdef class Quaternion:
    def __cinit__(self, qw=np.array(0.0,ndmin=1), 
                  qx=np.array(0.0,ndmin=1), 
                  qy=np.array(0.0,ndmin=1), 
                  qz=np.array(0.0,ndmin=1),
                  np.ndarray origins = None,
                  np.ndarray euler_angles = None):
        self.qw = np.array(qw)
        self.qx = np.array(qx)
        self.qy = np.array(qy)
        self.qz = np.array(qz)
        if origins is not None:
            self.from_origins(origins)
        if euler_angles is not None:
            self.from_euler_angles(euler_angles)
        
    def from_euler_angles(self, np.ndarray euler_angles):
        if euler_angles.ndim==1:
            euler_angles = euler_angles[None,:]
        ca = np.cos(euler_angles[:,0]*0.5)
        sa = np.sin(euler_angles[:,0]*0.5)
        cb = np.cos(euler_angles[:,1]*0.5)
        sb = np.sin(euler_angles[:,1]*0.5)
        cc = np.cos(euler_angles[:,2]*0.5)
        sc = np.sin(euler_angles[:,2]*0.5)
        self.qw = ca*cb*cc + sa*sb*sc 
        self.qx = sa*cb*cc - ca*sb*sc
        self.qy = ca*sb*cc + sa*cb*sc
        self.qz = ca*cb*sc - sa*sb*cc
        
    def from_origins(self, np.ndarray origins):
        if origins.ndim==1:
            origins = origins[None,:]
        self.qx = origins[:,0]
        self.qy = origins[:,1]
        self.qz = origins[:,2]
        self.qw = np.zeros_like(self.qx)

    def norm(self):
        red = self.qw**2 + self.qx**2 + self.qy**2 + self.qz**2
        return np.sqrt(red)

    def conj(self):
        Q = Quaternion(self.qw,-self.qx,-self.qy,-self.qz)
        return Q

    def __add__(x,y):
        if isinstance(x,Quaternion) and isinstance(y,Quaternion):
            Q1 = <Quaternion>x
            Q2 = <Quaternion>y
            return Quaternion(Q1.qw+Q2.qw,Q1.qx+Q2.qx,Q1.qy+Q2.qy,Q1.qz+Q2.qz)
        else:
            return NotImplemented

    def __sub__(x,y):
        if isinstance(x,Quaternion) and isinstance(y,Quaternion):
            Q1 = <Quaternion>x
            Q2 = <Quaternion>y
            return Quaternion(Q1.qw-Q2.qw,Q1.qx-Q2.qx,Q1.qy-Q2.qy,Q1.qz-Q2.qz)
        else:
            return NotImplemented

    def __mul__(x,y):
        if isinstance(x,Quaternion) and isinstance(y,Quaternion):
            Q1 = <Quaternion>x
            Q2 = <Quaternion>y
            a1 = Q1.qw
            b1 = Q1.qx
            c1 = Q1.qy
            d1 = Q1.qz
            a2 = Q2.qw
            b2 = Q2.qx
            c2 = Q2.qy
            d2 = Q2.qz
            return Quaternion(
                a1*a2-b1*b2-c1*c2-d1*d2,
                a1*b2+b1*a2+c1*d2-d1*c2,
                a1*c2-b1*d2+c1*a2+d1*b2,
                a1*d2+b1*c2-c1*b2+d1*a2)
        else:
            return NotImplemented

    def to_euler_angles(self):
        q0 = self.qw
        q1 = self.qx
        q2 = self.qy
        q3 = self.qz
        a = np.arctan2(2.0*(q0*q1+q2*q3),1-2.0*(q1*q1+q2*q2))
        b = np.arcsin(2.0*(q0*q2-q3*q1))
        c = np.arctan2(2.0*(q0*q3+q1*q2),1-2.0*(q2*q2+q3*q3))
        return np.concatenate((a[:,None],b[:,None],c[:,None]),axis=1)

    def __getitem__(self,index):
        wxyz = np.zeros((self.qw.size,4))
        wxyz[:,0] = self.qw
        wxyz[:,1] = self.qx
        wxyz[:,2] = self.qy
        wxyz[:,3] = self.qz
        return wxyz.__getitem__(index)

    def __setitem__(self,index,value):
        wxyz = np.zeros((self.qw.size,4))
        wxyz[:,0] = self.qw
        wxyz[:,1] = self.qx
        wxyz[:,2] = self.qy
        wxyz[:,3] = self.qz
        wxyz[index] = value
        self.qw = wxyz[:,0]
        self.qx = wxyz[:,1]
        self.qy = wxyz[:,2]
        self.qz = wxyz[:,3]

    def __repr__(self):
        return [self.qw,self.qx,self.qy,self.qz].__repr__()

    def __str__(self):
        return "@(CEO)>Quaternion:" + \
            "\nqw:" + np.array_str(self.qw,precision=3,suppress_small=True) + \
            "\nqx:" + np.array_str(self.qx,precision=3,suppress_small=True) + \
            "\nqy:" + np.array_str(self.qy,precision=3,suppress_small=True) + \
            "\nqz:" + np.array_str(self.qz,precision=3,suppress_small=True)
@
\subsubsection{Conic surface}
\label{sec:surface-1}

\index{rayTracing!python!Conic}

<<rayTracing.pxd contents>>=
    cdef cppclass conic:
        coordinate_system ref_frame
        void setup(rtd , rtd , vector , vector , vector)
        void cleanup()
@
<<rayTracing.pyx>>=
# conic
cdef class Conic:
    """
    """
    cdef conic *_c_conic

    def __cinit__(self,rtd c, rtd k, 
                  origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0],
                  conic_origin=[0.0,0.0,0.0]):
        self._c_conic = new conic()
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        cdef vector __conic_origin
        __conic_origin.x = <float>conic_origin[0]
        __conic_origin.y = <float>conic_origin[1]
        __conic_origin.z = <float>conic_origin[2]
        self._c_conic.setup(c, k, __origin, __euler_angles, __conic_origin)

    def __dealloc__(self):
        self._c_conic.cleanup()
@
\subsubsection{Aperture}
\label{sec:aperture-1}

\index{rayTracing!python!Aperture}

<<rayTracing.pxd contents>>=
    cdef cppclass aperture:
        coordinate_system ref_frame
        void setup(float, float, int, vector , vector) 
        void setup_GMT_M1(float, int)
        void cleanup()
        void vignetting(bundle *)
@
<<rayTracing.pyx>>=
# aperture
cdef class Aperture:
    """
    """
    cdef aperture *_c_aperture
    
    def __cinit__(self, float D, float ri, int D_px, origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0]):
        self._c_aperture = new aperture()
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_aperture.setup(D, ri, D_px, __origin, __euler_angles)

    def __dealloc__(self):
        self._c_aperture.cleanup()

    def vignetting(self, Bundle rays):
        self._c_aperture.vignetting(rays._c_bundle)
@
\subsubsection{Zernike}
\label{sec:zernike}

\index{rayTracing!python!ZernikeS}

<<rayTracing.pxd contents>>=
    cdef cppclass zernikeS:
          rtd *a
          void setup(int , rtd *, vector , vector , int)
          void cleanup()
          void surface(rtd *, rtd *, rtd *, int , int)
          void update(rtd *)
          void surface_derivatives(rtd *, rtd *, 
                                   rtd *, rtd *, int )
          void projection(float *, rtd *, rtd *, int)

    rtd zernike_surface(rtd , rtd , unsigned int , rtd *)

@ 
<<class definitions>>=
from numpy cimport ndarray
from utilities cimport cuDoubleArray
cdef class ZernikeS:
    cdef:
        zernikeS *_c_zernikeS
        public int max_n, n_mode, N_SURF
        public ndarray a
        double [:,::1] _a_
@
<<rayTracing.pyx>>=
# Zernike surface
cdef class ZernikeS:
    """
    A class to represent a surface as the weighted sum of Zernike polynomials

    Parameters
    ----------
    max_n : int
        The largest of the radial orders
    a : ndarray, optional
        The Zernike polynomial coefficients as a N_SURFxn_modes array; default to all 0
    N_SURF : int, optional
        The number of Zernike surfaces; default: 1
    origin : list, optional
        Origin of the coordinate system of the Zernike polynomials; default: [0,0,0]
    euler_angles : list, optional
        Euler angles of the coordinate system of the Zernike polynomials; default: [0,0,0]

    Attributes
    ----------
    max_n : int
        The largest of the radial orders
    n_mode : int
        The total number of Zernike modes
    N_SURF : int
        The number of Zernike surfaces
    a : ndarray
        The Zernike polynomial coefficients as a N_SURFxn_modes array

    Examples
    --------
    >>> import ceo
    >>> import numpy as np
    >>> import matplotlib as plt

    Lets define a Zernike surface made of the first 15 Zernike polynomials (4th radial order)

    >>> Z = ceo.ZernikeS(4)

    and setting it to be a pure focus mode:

    >>> Z.a[3] = 1.0
    >>> Z.update()

    The surface is computed with

    >>> npx = 512
    >>> u = np.linspace(-1,1,npx)
    >>> x,y = np.meshgrid(u,u, indexing='xy')
    >>> r = np.hypot(x,y)
    >>> o = np.arctan2(y,x)
    >>> cuo = ceo.cuDoubleArray(host_data=o)
    >>> cur = ceo.cuDoubleArray(host_data=r)
    >>> S = Z.surface(cur,cuo)

    and its derivative with

    >>> (dSdx,dSdy) = Z.surface_derivatives(cur,cuo)
    >>> fig, (ax1,ax2,ax3) = plt.subplots(ncols=3,sharey=True)
    >>> fig.set_size_inches(20,4.5)
    >>> h1 = ax1.imshow(S.host(),interpolation=None,origin='lower')
    >>> plt.colorbar(h1,ax=ax1)
    >>> h2 = ax2.imshow(dSdx.host(),interpolation=None,origin='lower')
    >>> plt.colorbar(h2,ax=ax2)
    >>> h3 = ax3.imshow(dSdy.host(),interpolation=None,origin='lower')
    >>> plt.colorbar(h3,ax=ax3)
    """

    def __cinit__(self, int _max_n_, ndarray _a_=None,
                  origin=[0.0,0.0,0.0], euler_angles=[0.0,0.0,0.0],
                  int N_SURF=1):
        self._c_zernikeS = new zernikeS()
        self.max_n = _max_n_
        self.n_mode = (_max_n_+1)*(_max_n_+2)/2
        self.N_SURF = N_SURF
        if _a_ is None:
            self.a = np.zeros((self.N_SURF,self.n_mode), dtype=np.float64)
        else: 
            self.a = _a_
        cdef vector __origin
        __origin.x = <float>origin[0]
        __origin.y = <float>origin[1]
        __origin.z = <float>origin[2]
        cdef vector __euler_angles
        __euler_angles.x = <float>euler_angles[0]
        __euler_angles.y = <float>euler_angles[1]
        __euler_angles.z = <float>euler_angles[2]
        self._c_zernikeS.setup( self.max_n, <rtd *>self.a.data,
                                __origin, __euler_angles,
                                self.N_SURF) 

    def __dealloc__(self):
        self._c_zernikeS.cleanup();

    def update(self):
        """
        Updates the Zernike surface based on the Zernike coefficients
        """
        self._c_zernikeS.update(<rtd *>self.a.data)

    def reset(self):
        """
        Resets the Zernike coefficients to zero and update the Zernike surface
        """
        self.a = np.zeros((self.N_SURF,self.n_mode))
        self.update()
        
    def surface(self, cuDoubleArray r, cuDoubleArray o, int surf_id=0):
        """
        Computes the Zernike surface in polar coordinates

        Parameters
        ----------
        r : cuDoubleArray
            The normalized radius
        o : cuDoubleArray
            The azimuth
        surf_id : int, optional
            The surface index; default: 0

        Returns
        -------
        S : cuDoubleArray
            The Zernike surface
        """
        S = cuDoubleArray(shape=r.shape, dev_malloc = True)
        self._c_zernikeS.surface(S._c_gpu.dev_data, 
                                 r._c_gpu.dev_data, o._c_gpu.dev_data, 
                                 r._c_gpu.N, surf_id)
        return S

    def surface_derivatives(self, cuDoubleArray r, cuDoubleArray o):
        """
        Computes the Zernike surface x and y derivatives in polar coordinates

        Parameters
        ----------
        r : cuDoubleArray
            The normalized radius
        o : cuDoubleArray
            The azimuth

        Returns
        -------
        dSdx : cuDoubleArray
            The Zernike surface x derivative
        dSdy : cuDoubleArray
            The Zernike surface y derivative
        """
        dSdx = cuDoubleArray(shape=r.shape, dev_malloc = True)
        dSdy = cuDoubleArray(shape=r.shape, dev_malloc = True)
        self._c_zernikeS.surface_derivatives(dSdx._c_gpu.dev_data, dSdy._c_gpu.dev_data, 
                                             r._c_gpu.dev_data, o._c_gpu.dev_data, r._c_gpu.N)
        return dSdx,dSdy

    def projection(self, cuFloatArray phase, cuDoubleArray r, cuDoubleArray o):
        """
        Projects the phase onto a set on Zernike polynomials

        Parameters
        ----------
        phase : cuFloatArray
            The wavefront phase
        r : cuDoubleArray
            The radius of the coordinates
        o : cuDoubleArray
            The azimuth of the coordinates
        """
        self._c_zernikeS.projection(phase._c_gpu.dev_data, 
                                    r._c_gpu.dev_data, o._c_gpu.dev_data, r.size)
        self._a_ = <double[:self.N_SURF,:self.n_mode]>self._c_zernikeS.a
        self.a   = np.asarray(self._a_)

def Zernike_Surface(rtd r, rtd o, int max_n, np.ndarray a):
    return zernike_surface(r, o, max_n, <rtd *>a.data)

@

\section{Custom types}
\label{sec:custom-types}

The accuracy of the ray tracing is partly depending upon the data type used to hold data values of rays and surfaces.
GPU are faster in single precision than in double precision but double precision may still be required for accuracy.
So lets defined a ray tracing type:
\index{rayTracing!vector!=}
\index{rayTracing!vector!+}
\index{rayTracing!vector!+=}
\index{rayTracing!vector!-}
\index{rayTracing!vector!-=}
\index{rayTracing!vector!*}
<<ray tracing data type>>=
typedef double rtd;
@ 

\subsection{Vector}
\label{sec:vector}

\index{rayTracing!vector}

A new vector data type is defined 
<<vector data type>>=
struct vector{
  rtd x;
  rtd y;
  rtd z;
  __host__ __device__ vector(rtd x=0.0, rtd y=0.0, rtd z=0.0)
    : x(x), y(y), z(z)
  {
  }
  __host__ __device__ rtd rho2(void);
  __host__ __device__ rtd rho2_shift(rtd x0, rtd y0);
  __host__ __device__ rtd mag(void);
  __host__ __device__ rtd mag(rtd R);
  __host__ __device__ rtd angle(void);
  __host__ __device__ rtd norm(void);
  __host__ __device__ rtd dot(vector *u);
  __host__ __device__ void unit(void);
  __host__ __device__ void left_cross(vector *w, vector *u);
  __host__ __device__ void right_cross(vector *w, vector *u);
  __host__ __device__ vector& operator=(const vector& v){
     x = v.x;
     y = v.y;
     z = v.z;
     return *this;
   }
  __host__ __device__ vector& operator-=(const vector& rhs){
     x -= rhs.x;
     y -= rhs.y;
     z -= rhs.z;
     return *this;
   }
  __host__ __device__ vector& operator+=(const vector& rhs){
     x += rhs.x;
     y += rhs.y;
     z += rhs.z;
     return *this;
   }
  __host__ __device__ vector operator-(const vector& rhs) const
  {
    return vector(x-rhs.x,y-rhs.y,z-rhs.z);
  }
  __host__ __device__ vector operator+(const vector& rhs) const
  {
    return vector(x+rhs.x,y+rhs.y,z+rhs.z);
  }
  __host__ __device__ rtd operator*(const vector& rhs) const
  {
    return x*rhs.x + y*rhs.y + z*rhs.z;
  }
  __host__ __device__ vector operator*(const rtd& rhs) const
  {
    return vector(x*rhs,y*rhs,z*rhs);
  }
};
@ that represents the 3 coordinates in space of the tip of vector.
The square of the magnitude of a vector projected in the x,y--plane i.e. $[[x]]^2+[[y]]^2$ is computed with 
\index{rayTracing!vector!rho2}
<<vector functions>>=
__host__ __device__ rtd vector::rho2(void) {
  return x*x + y*y;
}
@
The square of the magnitude of a vector projected in the x,y--plane with respect to origin ([[x0]],[[y0]]) i.e. $[[x-x0]]^2+[[y-y0]]^2$ is computed with 
\index{rayTracing!vector!rho2\_shift}
<<vector functions>>=
__host__ __device__ rtd vector::rho2_shift(rtd x0, rtd y0) {
  rtd xp, yp;
  xp = x - x0;
  yp = y - y0;
  return xp*xp + yp*yp;
}
@ 
The magnitude and angle of the projection of the vector in the x,y--plane is
\index{rayTracing!vector!mag}
\index{rayTracing!vector!angle}
<<vector functions>>=
__host__ __device__ rtd vector::mag(void) {
  return hypot(x,y);
}
__host__ __device__ rtd vector::angle(void) {
  return atan2(y,x);
}
@  
\index{rayTracing!vector!dot}
The dot product of this vector $\mathbf v$ with a vector $\mathbf u$ i.e $\mathbf{v}\cdot\mathbf{u}$ is
<<vector functions>>=
__host__ __device__ rtd vector::dot(vector *u) {
  return x*u->x + y*u->y + z*u->z;
}
@ 
The norm of the vector is
\index{rayTracing!vector!norm}
<<vector functions>>=
__host__ __device__ rtd vector::norm(void) {
  return sqrt( x*x + y*y + z*z );
}
@ 
The vector is normalized such as $\left\|\mathbf{v}\right\|=1$ with
\index{rayTracing!vector!unit}
<<vector functions>>=
__host__ __device__ void vector::unit(void) {
  rtd n = norm();
  x /= n;
  y /= n;
  z /= n;
}

@ 
The magnitude can also be normalized by radius [[R]]:
\index{rayTracing!vector!mag}
<<vector functions>>=
__host__ __device__ rtd vector::mag(rtd R) {
  return hypot(x,y)/R;
}
@ 
The cross product of a vector $\mathbf{u}$ with this vector $\mathbf{v}$ i.e. $\mathbf{w}=\mathbf{u}\wedge\mathbf{v}$ 
\index{rayTracing!vector!left\_cross}
<<vector functions>>=
__host__ __device__ void vector::left_cross(vector *w, vector *u) {
  w->x = u->y*z - u->z*y;
  w->y = u->z*x - u->x*z;
  w->z = u->x*y - u->y*x;
}
@ 
The cross product of this vector $\mathbf{v}$ with a vector $\mathbf{u}$ i.e. $\mathbf{w}=\mathbf{v}\wedge\mathbf{u}$ 
\index{rayTracing!vector!right\_cross}
<<vector functions>>=
__host__ __device__ void vector::right_cross(vector *w, vector *u) {
  w->x = u->z*y - u->y*z;
  w->y = u->x*z - u->z*x;
  w->z = u->y*x - u->x*y;
}
@

\subsection{Ray}
\label{sec:ray}

\index{rayTracing!ray}

A type for the rays is also defined:
<<ray data type>>=
typedef struct {
  <<ray data>>
} ray;
@ 
It contains the ray coordinates:
<<ray data>>=
vector coordinates;
@ 
the direction cosines of the ray:
<<ray data>>=
vector directions;
@ 
the [[surface_normal]] at the surface it intersected with the last time:
<<ray data>>=
vector surface_normal;
@ 
the optical path length:
<<ray data>>=
rtd optical_path_length;
@ 
the optical path difference
<<ray data>>=
rtd optical_path_difference;
@ the vignetting flag [[v]], $[[v]]=0$ means the ray is vignetted:
<<ray data>>=
char v;
@ and the number of iterative steps for the Raphson--Newton method:
<<ray data>>=
int n_iteration;

@
\section{Ray bundle}
\label{sec:ray-bundle}

\index{rayTracing!bundle}

Collections of rays are gathered into bundles:
<<ray bundle structure>>=
struct bundle {
  <<ray bundle parameters>>
  void setup(rtd RADIUS, int N_RADIUS, int N_THETA, vector origin, int N_SRC);
  void setup(rtd L, int N_L, vector origin, int N_SRC);
  void cleanup(void);
  void to_z_plane(rtd z_in);
  void to_sphere(vector sphere_origin);
  void to_sphere(rtd z_chief_on_axis, rtd rho_focal_plane);
  void get_coordinates(double *d__coord);
  void get_chief_coordinates(double *d__coord);
  void get_directions(double *d__dir);
  void get_chief_directions(double *d__dir);
  void get_chief_optical_path_length(double *d__opl);
  void get_optical_path_length(double *d__opl);
  void get_optical_path_difference(double *d__opd);
  void get_optical_path_difference(double *d__opd,
				   float const delta_x, int N_x, 
				   float const delta_y, int N_y);
  void get_vignetting(double *d__v);
  void get_n_iteration(int *n_iteration);
};
@ 
A bundle allocates an array of [[N_RAY]] rays on the device
<<ray bundle parameters>>=
int N_RAY;
ray *d__ray;
@ 
The structure may contain several bundle of rays, each associated to a different source but with the same number of rays
<<ray bundle parameters>>=
int N_BUNDLE;
@
The x and y coordinates of the [[origin]] vector specifies the location of the center of the ray bundle when it crosses the (x,y) plane of the first surface.
The z coordinate specifies the height of the ray bundle with respect to the first surface.
<<ray bundle parameters>>=
vector *d__origin;
@ 
The chief ray is defined with
<<ray bundle parameters>>=
ray *d__chief_ray; 
vector *d__chief_origin;
@ 
The vignetting mask is defined with
<<ray bundle parameters>>=
mask V;
@
The ray geometry is defined either in polar coordinates (\textit{fan} mode)
<<ray bundle parameters>>=
char geom[8];
@ where the radius and azimuth angle are sampled with [[N_RADIUS]] and [[N_THETA]] rays,
<<ray bundle parameters>>=
int N_RADIUS, N_THETA;
@ 
or in cartesian coordinates (\textit{box} mode) where the rays sample a [[N_L]]$\times$[[N_L]] square
<<ray bundle parameters>>=
int N_L;
@
In \textit{fan} mode, the radius is saved in [[L]] and in \textit{box} mode the side of the box is saved in [[L]]:
<<ray bundle parameters>>=
rtd L;
@ 
The optical path difference is computed with respect to a reference sphere which is centered on the object in the image plane and which is tangent to the exit pupil.
<<ray bundle parameters>>=
rtd *d__sphere_distance, *d__sphere_radius;
vector *d__sphere_origin;
@ The GMT segment piston mask:
<<ray bundle parameters>>=
int *d__piston_mask;
@
\subsection{Setup \& Cleanup}
\label{sec:bundle-setup--cleanup}

A ray bundle is specified with either the polar or cartesian coordinates of the rays at a given origin.
The direction cosine are derived from the coordinates of a source object.

The polar coordinates are defined with the sampling of the radius [[N_RADIUS]] from 0 to [[RADIUS]] and with the sampling of the azimuth [[N_THETA]].
\index{rayTracing!bundle!setup}
<<ray bundle functions>>=
void bundle::setup(rtd RADIUS, int _N_RADIUS_, 
		   int _N_THETA_, vector origin, int N_SRC)
{
  strcpy(geom,"fan");
  N_RADIUS = _N_RADIUS_;
  N_THETA  = _N_THETA_;
  L        = RADIUS;
  N_BUNDLE = N_SRC;
  N_RAY = (N_RADIUS-1)*N_THETA + 1;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The polar coordinates $\rho$ and $\theta$ of the rays are given by
\begin{equation}
  \rho = [[RADIUS]] {k \over [[N_RADIUS]] - 1 } \forall k \in [0,[[N_RADIUS]] - 1]
\end{equation}
and
\begin{equation}
  \theta = 2\pi {k \over [[N_THETA]] } \forall k \in [0,[[N_THETA-1]]]
\end{equation}
<<bundle coordinates>>=
<<chief ray init>>
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_RADIUS/N_THREAD+1,N_THETA/N_THREAD+1, N_BUNDLE);
ray_coordinates LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                            L, N_RADIUS, N_THETA, d__origin);
@ 
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                            rtd RADIUS, int N_RADIUS, int N_THETA, vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta, s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    k += iSource*N_RAY;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    <<bundle coordinates kernel (common)>>
  }
}
@ where
<<bundle coordinates kernel (common)>>=
d__ray[k].coordinates.z = origin->z;
d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
d__ray[k].directions.z  = -cos(src[iSource].zenith);
d__ray[k].optical_path_length = 0.0;
d__ray[k].optical_path_difference = 0.0;
s = -origin->z/d__ray[k].directions.z;
d__ray[k].coordinates.x -= s*d__ray[k].directions.x;
d__ray[k].coordinates.y -= s*d__ray[k].directions.y;
d__ray[k].v = 1;
@
The chief ray is defined with
<<chief ray allocation>>=
vector chief_origin;
chief_origin.x = 0.0;
chief_origin.y = 0.0;
chief_origin.z = origin.z;
HANDLE_ERROR( cudaMalloc((void**)&d__chief_ray, sizeof(ray)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__chief_origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__chief_origin, &chief_origin, 
                         sizeof(vector), cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_origin,   sizeof(vector)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_radius,   sizeof(rtd)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_distance, sizeof(rtd)*N_BUNDLE ) );
@
 and is initialized with
<<chief ray init>>= 
ray_coordinates LLL gridDim , blockDim RRR (d__chief_ray, 1, src->dev_ptr,
					    0.0, 2, 1, d__origin);

@
The cartesian coordinates are defined with the sampling of the square box length [[N_L]] from $-[[L]]$ to [[L]].
\index{rayTracing!bundle!setup}
<<ray bundle functions>>=
  void bundle::setup(rtd _L_, int _N_L_, vector origin, int N_SRC)
{
  strcpy(geom,"box");
  N_L = _N_L_;
  L = _L_;
  N_BUNDLE = N_SRC;
  N_RAY = N_L*N_L;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__piston_mask, sizeof(int)*N_RAY*N_BUNDLE ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The cartesian coordinates $x$ and $y$ of the rays are given by
\begin{eqnarray}
  x &=& L*(i-([[N_L]]-1)/2)/([[N_L]]-1) \\
  y &=& L*(j-([[N_L]]-1)/2)/([[N_L]]-1)
\end{eqnarray}
<<bundle coordinates (box)>>=
<<chief ray init>>
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_L/N_THREAD+1,N_L/N_THREAD+1, N_BUNDLE);
ray_coordinates_box LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                                            L, N_L, d__origin);
@ 
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y, s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    k = i + j*N_L + iSource*N_RAY;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    <<bundle coordinates kernel (common)>>
  }
}
@
Memory is freed with
\index{rayTracing!bundle!cleanup}
<<ray bundle functions>>=
void bundle::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>bundle: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__ray ) );
  HANDLE_ERROR( cudaFree( d__chief_ray ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
  HANDLE_ERROR( cudaFree( d__chief_origin ) );
  HANDLE_ERROR( cudaFree( d__piston_mask ) );
  HANDLE_ERROR( cudaFree( d__sphere_origin ) );
  HANDLE_ERROR( cudaFree( d__sphere_radius ) );
  HANDLE_ERROR( cudaFree( d__sphere_distance ) );
}
@

\subsection{Propagation parametric geometric equation}
\label{sec:prop-param-geom}

The rays are propagated to the plane $z=[[z__plane]]$ with
\begin{eqnarray}
  \label{eq:26}
  s &=& { [[z_plane]] - z \over m} \\\nonumber
  x &=& x + s k \\\nonumber
  y &=& y + s l \\\nonumber
  z &=& [[z_plane]]
\end{eqnarray}
\index{rayTracing!bundle!to\_z\_plane}
<<ray bundle functions>>= 
void bundle::to_z_plane(rtd z_plane)
{
  to_z_plane_chief_kernel LLL 1, 1, N_BUNDLE RRR (d__chief_ray, 1, z_plane);
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  to_z_plane_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, z_plane, d__chief_ray);
}
@ where
<<to z plane kernel>>=
  __global__ void to_z_plane_kernel(ray *d__ray, int N_RAY, rtd z_plane, ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    if (d__ray[k].directions.z==0)
       return;
    s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
    d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
    d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
    d__ray[k].coordinates.z = z_plane;
    d__ray[k].optical_path_length = s;
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray->optical_path_length;
  }
}
__global__ void to_z_plane_chief_kernel(ray *d__ray, int N_RAY, rtd z_plane)
{
  int k, iSource;
  rtd s;
  iSource = blockIdx.z;
  k = iSource;
  if (d__ray[k].directions.z==0)
    return;
  s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
  d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
  d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
  d__ray[k].coordinates.z = z_plane;
  d__ray[k].optical_path_length = s;
}
@ 

\subsection{Reference sphere}
\label{sec:reference-sphere}

\subsubsection{Spherical focal plane}
\label{sec:spher-focal-plane}

\index{rayTracing!bundle!to\_sphere}

<<ray bundle functions>>= 
void bundle::to_sphere(rtd z_chief_on_axis, rtd rho_focal_plane)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  <<reference sphere distance>>
  <<reference sphere origin>>
  <<reference sphere radius>>
  <<chief ray optical path length>>
  <<rays optical path difference>>
}
@
Given the $z$ location of the focal plane on axis [[z_chief_on_axis]] and the radius of curvature of the focal plane [[rho_focal_plane]], the distance to the object from the last surface for the chief ray is given by
<<reference sphere distance>>= 
to_focal_surface_chief_kernel LLL gridDim , blockDim RRR (d__sphere_distance, d__chief_ray, 1, 
                                                          z_chief_on_axis, 
							  rho_focal_plane);
@  with
<<to sphere kernel>>=
__global__ void to_focal_surface_chief_kernel(rtd *s, ray *d__ray, int N_RAY, 
                                              rtd z_chief_on_axis, rtd rho_focal_plane)
{
  int k, iSource;
  rtd x, y, z, g, rho2;
  iSource = blockIdx.z;
  k = iSource;
  x = d__ray[k].coordinates.x;
  y = d__ray[k].coordinates.y;
  z = d__ray[k].coordinates.z - z_chief_on_axis + rho_focal_plane;
  g = x*d__ray[k].directions.x + y*d__ray[k].directions.y + z*d__ray[k].directions.z;
  rho2 = x*x + y*y + z*z;
  s[k] = -1.0*sqrt( g*g - (rho2-rho_focal_plane*rho_focal_plane) ) - g;
}
@
The origin of the reference sphere is computed next 
<<reference sphere origin>>= 
chief_parametric_equation LLL gridDim , blockDim RRR (d__sphere_origin, 
						      d__chief_ray, 1, 
						      d__sphere_distance);
@ 
The chief ray defines the location of the object and the reference sphere is centered on the object e.g. the origin of the reference sphere is on the chief ray.
If the distance from the last surface to the object is known for the chief ray, then the origin of the reference sphere is given by:
<<reference sphere origin from chief ray>>=
__global__ void chief_parametric_equation(vector *d__v, ray *d__ray, int N_RAY, rtd *s)
{
  int k, iSource;
  iSource = blockIdx.z;
  k = iSource;
  d__v[k].x = d__ray[k].coordinates.x + d__ray[k].directions.x*s[k];
  d__v[k].y = d__ray[k].coordinates.y + d__ray[k].directions.y*s[k];
  d__v[k].z = d__ray[k].coordinates.z + d__ray[k].directions.z*s[k];
}
@ The computation of the radius of the reference sphere, which must be tangent to the exit pupil, is:
<<reference sphere radius>>= 
sphere_radius_kernel LLL gridDim , blockDim RRR (d__sphere_radius, d__chief_ray, 1, 
						 d__sphere_origin);
@ 
To compute the reference sphere radius, one must know the location of the exit pupil.
The location of the exit pupil is given by the intersection of the chief ray with the optical axis after the last surface of the system.
Remembering the rays parametric equation:
\begin{eqnarray}
  \label{eq:60}
  x &=& x_{-1} + k_{-1}s \\
  y &=& y_{-1} + l_{-1}s \\
  z &=& z_{-1} + m_{-1}s \\
\end{eqnarray}
and noting that, at the intersection $x=y=0$, the distance $s$ from the last surface to the exit pupil is given by
\begin{equation}
  \label{eq:61}
  s = \sqrt{  x_{-1}^2 + y_{-1}^2 \over k_{-1}^2 + l_{-1}^2 }
\end{equation}
Given the origin of the reference sphere $\left( x_{s,0},y_{s,0},z_{s,0} \right)$, the radius $\varrho_s$ is written
\begin{equation}
  \label{eq:62}
  \varrho_s = \sqrt{ x_{s,0}^2 + y_{s,0}^2 + \left( z_{s,0} - z_E \right) },
\end{equation}
where $z_E$ is the exit pupil coordinate on the z--axis,
\begin{equation}
  \label{eq:63}
  z_E = z_{-1} + m_{-1}s.
\end{equation}
In the case of an on--axis source, $k_{-1}=l_{-1}=0$ and $s=\infty$ so the radius is set to $\varrho_s=23.772110269559725$m.
<<to sphere kernel>>=
__global__ void sphere_radius_kernel(rtd *radius, ray *d__ray, int N_RAY, 
				     vector *sphere_origin)
{
  int k, iSource;
  rtd rho2_xy, rho2_kl, buf, s, z;
  iSource = blockIdx.z;
  k = iSource;

  buf =  d__ray[k].coordinates.x;
  buf *= buf;
  rho2_xy = buf;
  buf =  d__ray[k].coordinates.y;
  buf *= buf;
  rho2_xy += buf;

  buf =  d__ray[k].directions.x;
  buf *= buf;
  rho2_kl = buf;
  buf =  d__ray[k].directions.y;
  buf *= buf;
  rho2_kl += buf;
  
  if (rho2_kl<1E-24)
    radius[k] = 23.772110269559725;
  else {
    s = sqrt(rho2_xy/rho2_kl);
    z = d__ray[k].coordinates.z + d__ray[k].directions.z*s;

    buf = sphere_origin[k].x;
    buf *= buf;
    radius[k] = buf;

    buf = sphere_origin[k].y;
    buf *= buf;
    radius[k] += buf;

    buf = sphere_origin[k].z - z;
    buf *= buf;
    radius[k] += buf;
    radius[k] = sqrt( radius[k] );
  }
}
@ The optical path length of the chief ray from the last surface to the reference sphere is computed with
<<chief ray optical path length>>= 
to_sphere_chief_kernel LLL gridDim , blockDim RRR (d__chief_ray, 1, 
                                                   d__sphere_origin, d__sphere_radius);
@ with
<<to sphere kernel>>=
__global__ void to_sphere_chief_kernel(ray *d__ray, int N_RAY, 
                                       vector *sphere_origin, rtd *sphere_radius)
{
  int k, iSource;
  rtd s, x, y, z, g, rho2;
  iSource = blockIdx.z;
  k = iSource;
  <<to sphere kernel common>>
}
@
The optical path difference (OPD) is usually computed with respect to a reference sphere centered on the object.
The OPD is given by the difference between the rays optical path length (OPL) to the sphere and the OPL of the chief ray to the sphere.
The OPL $s$ is used to compute the intersection of a ray with the sphere from the parametric equation:
\begin{eqnarray}
  \label{eq:27}
  x &=& x_{-1} + s k_{-1} \\\nonumber
  y &=& y_{-1} + s l_{-1} \\\nonumber
  z &=& z_{-1} + s m_{-1} 
\end{eqnarray}
where $(x_{-1},y_{-1},z_{-1})$ and  $(k_{-1},l_{-1},m_{-1})$ are the coordinates at and direction cosines from the last surface.
Inserting $x$, $y$ and $z$ in the sphere equation,
\begin{equation}
  \label{eq:28}
  (x - x_O)^2 + (y-y_O)^2 + (z-z_O)^2 = R^2 
\end{equation}
where $(x_O,y_O,z_O)$ is the object coordinate and $R$ the sphere radius, and solving for $S$ lead to
\begin{equation}
  \label{eq:29}
  s = - \gamma - \sqrt{\gamma^2  - (\rho^2 - R^2)}
\end{equation}
with
\begin{equation}
  \label{eq:30}
  \gamma = (x_{-1} - x_O)k_{-1} + (y_{-1} - y_O)l_{-1} + (z_{-1} - z_O)m_{-1} 
\end{equation}
and
\begin{equation}
  \label{eq:31}
  \rho^2 = (x_{-1} - x_O)^2 + (y_{-1} - y_O)^2 + (z_{-1} - z_O)^2. 
\end{equation}
@ 
The code corresponding to the above equation is:
<<to sphere kernel common>>=
x = d__ray[k].coordinates.x - sphere_origin[iSource].x;
y = d__ray[k].coordinates.y - sphere_origin[iSource].y;
z = d__ray[k].coordinates.z - sphere_origin[iSource].z;
g = x*d__ray[k].directions.x + y*d__ray[k].directions.y + z*d__ray[k].directions.z;
rho2 = x*x + y*y + z*z;
s = -sqrt( g*g - (rho2-sphere_radius[iSource]*sphere_radius[iSource]) ) - g;
d__ray[k].optical_path_length = s;
d__ray[k].coordinates.x += s*d__ray[k].directions.x; 
d__ray[k].coordinates.y += s*d__ray[k].directions.y;
d__ray[k].coordinates.z += s*d__ray[k].directions.z;
@
The optical path difference of the source rays is computed last
<<rays optical path difference>>= 
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_RAY/N_THREAD2+1,1, N_BUNDLE);
to_sphere_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, 
                                             d__sphere_origin, d__sphere_radius, 
                                             d__chief_ray);
@ with
<<to sphere kernel>>=
__global__ void to_sphere_kernel(ray *d__ray, int N_RAY, 
				 vector *sphere_origin, rtd *sphere_radius,
				 ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s, x, y, z, g, rho2;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    <<to sphere kernel common>>
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray[iSource].optical_path_length;
  }
}

@
\subsubsection{Reference sphere origin}
\label{sec:refer-sphere-orig}

Given the origin and the radius of the reference sphere, the optical path difference is computed with
\index{rayTracing!bundle!to\_sphere}
<<ray bundle functions>>= 
void bundle::to_sphere(vector sphere_origin)
{
  HANDLE_ERROR( cudaMemcpy( d__sphere_origin, &sphere_origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  <<reference sphere radius>>
  <<chief ray optical path length>>
  <<rays optical path difference>>
}
@ 
<<ray bundle functions (opt-out)>>= 
void bundle::to_sphere(rtd *s, rtd sphere_radius)
{
  <<ray bundle functions: from distance>>
}
@  

\subsection{Gathering data}
\label{sec:gathering-data}

The coordinates, directions, optical path length and vignetting map are copied into arrays with the following functions:
<<ray bundle functions>>= 
<<gathering ray coordinates>>
<<gathering ray directions>>
<<gathering ray optical path length>>
<<gathering ray optical path difference>>
<<gathering ray vignetting map>>
<<gathering ray number of iterative steps>>
<<OPD nearest neighbor interpolation>>
@ 
<<ray bundle kernels>>= 
<<gathering ray coordinates kernel>>
<<gathering ray directions kernel>>
<<gathering ray optical path length kernel>>
<<gathering ray optical path difference kernel>>
<<gathering ray vignetting map kernel>>
<<gathering ray number of iterative steps kernel>>
<<OPD nearest neighbor interpolation kernel>>
@ 
\index{rayTracing!bundle!get\_coordinates}
<<gathering ray coordinates>>=
void bundle::get_coordinates(double *d__coord)
{
  HANDLE_ERROR( cudaMemset( d__coord, 0, sizeof(double)*N_RAY*3 ) );  
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim , blockDim RRR (d__coord, d__ray, N_RAY);
}
@ 
\index{rayTracing!bundle!get\_chief\_coordinates}
<<gathering ray coordinates>>=
void bundle::get_chief_coordinates(double *d__coord)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim, blockDim RRR (d__coord, d__chief_ray, 1);
}
@ 
<<gathering ray coordinates kernel>>=
__global__ void get_coordinates_kernel(double *d__coord, ray *d__ray, int N_RAY)
{
  int i, j, k0, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  k0 = k;
  k += iSource*N_RAY;
  if ( ( k0<N_RAY ) && (d__ray[k].v==1) )
  {
    l = k*3;
    d__coord[l++] = d__ray[k].coordinates.x;
    d__coord[l++] = d__ray[k].coordinates.y;
    d__coord[l]   = d__ray[k].coordinates.z;
  }
}
@ 
\index{rayTracing!bundle!get\_directions}
<<gathering ray directions>>=
void bundle::get_directions(double *d__dir)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__ray, N_RAY);
}
@ 
\index{rayTracing!bundle!get\_chief\_directions}
<<gathering ray directions>>=
void bundle::get_chief_directions(double *d__dir)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__chief_ray, 1);
}
@ 
<<gathering ray directions kernel>>=
__global__ void get_directions_kernel(double *d__dir, ray *d__ray, int N_RAY)
{
  int i, j, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
  {
    k += iSource*N_RAY;
    l = k*3;
    d__dir[l++] = d__ray[k].directions.x;
    d__dir[l++] = d__ray[k].directions.y;
    d__dir[l]   = d__ray[k].directions.z;
  }
}
@ 
\index{rayTracing!bundle!get\_optical\_path\_length}
<<gathering ray optical path length>>=
void bundle::get_optical_path_length(double *d__opl)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__ray, N_RAY);
}
@ 
\index{rayTracing!bundle!get\_chief\_optical\_path\_length}
<<gathering ray optical path length>>=
void bundle::get_chief_optical_path_length(double *d__opl)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__chief_ray, 1);
}
@ 
<<gathering ray optical path length kernel>>=
__global__ void get_optical_path_length_kernel(double *d__opl, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    {
      k += iSource*N_RAY;
      d__opl[k]   = d__ray[k].optical_path_length;
    }
}
@ 
\index{rayTracing!bundle!get\_optical\_path\_difference}
<<gathering ray optical path difference>>=
void bundle::get_optical_path_difference(double *d__opd)
{
  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_RAY*N_BUNDLE ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_optical_path_difference_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY);
}
@ 
<<gathering ray optical path difference kernel>>=
__global__ void get_optical_path_difference_kernel(double *d__opd, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = k;
  k += iSource*N_RAY;
  if ( (j<N_RAY) && (d__ray[k].v) )
    {
      d__opd[k]   = d__ray[k].optical_path_difference;
    }
}
@ 
\index{rayTracing!bundle!get\_n_iteration}
<<gathering ray number of iterative steps>>=
void bundle::get_n_iteration(int *n_iteration)
{
  HANDLE_ERROR( cudaMemset(n_iteration, 0, sizeof(int)*N_RAY*N_BUNDLE ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_n_iteration_kernel LLL gridDim , blockDim RRR (n_iteration, d__ray, N_RAY);
}
@ 
<<gathering ray number of iterative steps kernel>>=
__global__ void get_n_iteration_kernel(int *n_iteration, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = k;
  k += iSource*N_RAY;
  if ( (j<N_RAY) && (d__ray[k].v) )
    {
      n_iteration[k]   = d__ray[k].n_iteration;
    }
}
@ 
The OPD is interpolated on a $N_x\times N_y$ grid with respective sampling $\delta_x$ and $\delta_y$.
The $x_i$ and $y_i$ interpolation coordinates are written:
\begin{eqnarray}
  \label{eq:32}
  x_i &=& \delta_x(i -(N_x-1)/2),\quad \forall 0\leq i \leq N_x-1 \\\nonumber
  y_i &=& \delta_y(j -(N_y-1)/2),\quad \forall 0\leq j \leq N_y-1 
\end{eqnarray}
The coordinates are re--centered with respect to the original coordinate grid
\begin{eqnarray} 
  \label{eq:33}
  x_i &\rightarrow& x_i + L/2 \\\nonumber
  y_i &\rightarrow& y_i + L/2
\end{eqnarray}
and scale to that grid
\begin{eqnarray}
  \label{eq:34}
  x_i &\rightarrow& x_i{N_L-1 \over L} \\\nonumber
  y_i &\rightarrow& y_i{N_L-1 \over L}
\end{eqnarray}
<<OPD nearest neighbor interpolation>>=
void bundle::get_optical_path_difference(double *d__opd,
					 float const delta_x, int N_x, 
					 float const delta_y, int N_y)
{
  /* cublasHandle_t handle; */
  /* cublasStatus_t status; */
  /* double *d__coord; */
  /* int N, idx; */

  /* cublasCreate(&handle); */

  /* N = N_RAY*3; */
  /* HANDLE_ERROR( cudaMalloc((void**)&d__coord, sizeof(double)*N ) ); */
  /* get_coordinates(d__coord); */

  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x max idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y max idx = %d\n",idx); */

  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_x*N_y ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1);
  get_optical_path_difference_interp_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY,
  									delta_x, N_x,
  									delta_y, N_y,
  									L, N_L);
  /* cublasDestroy(handle); */
  /* HANDLE_ERROR( cudaFree( d__coord) ); */
}
@ with
<<OPD nearest neighbor interpolation kernel>>=
__global__ void get_optical_path_difference_interp_kernel(double *d__opd,
                                                     ray* d__ray, int N_RAY,
						     float const delta_x, int N_x, 
						     float const delta_y, int N_y,
						     float const L, int const N_L)
{
  /*
  int i, j, k, kl;
  float x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) roundf( x );
      j = (int) roundf( y );
      kl = i + N_x*j;
      if ( (i<0) || (i>=N_x) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      if ( (j<0) || (j>=N_y) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      d__opd[k] = d__ray[k].optical_path_difference;
    }
  */
  int i, j, k, l;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) rint( x );
      j = (int) rint( y );
      l = i + N_x*j;
      if ( ( (i>=0) && (i<N_x) ) && ( (i>=0) && (i<N_y) ) )
	d__opd[l]   = d__ray[k].optical_path_difference;
    }
}
@ 
\index{rayTracing!bundle!get\_vignetting}
<<gathering ray vignetting map>>=
void bundle::get_vignetting(double *d__v)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_vignetting_kernel LLL gridDim , blockDim RRR (d__v, d__ray, N_RAY);
}
@ 
<<gathering ray vignetting map kernel>>=
  __global__ void get_vignetting_kernel(double *d__v, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    d__v[k]   = (d__ray[k].v==1) ? 1.0 : 0.0;
}
@ 
<<gathering wavefront>>=
void bundle::get_wavefront(source *src)
{
//  printf("Setting wavefront!\n");
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1, N_BUNDLE);
  get_wavefront_kernel LLL gridDim , blockDim RRR (src->wavefront.amplitude, 
                                                   src->wavefront.phase,
						   V.m,
                                                   d__ray, N_RAY);
  V.set_filter();
  src->wavefront.masked(&V);
}
@ 
<<gathering wavefront kernel>>=
__global__ void get_wavefront_kernel(float *amplitude, float *phase,
                                     char *m, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    if (d__ray[k].v==1)
      {
	m[k]         = 1;
	amplitude[k] = 1.0;
	phase[k]     = d__ray[k].optical_path_difference;
      } else {
	m[k]         = 0;
	amplitude[k] = 0.0;
	phase[k]     = 0.0;
    }
}
@ 

\subsection{Resetting}
\label{sec:resetting}

The ray vignetting is reset with
\index{rayTracing!bundle!reset}
<<ray bundle functions (opt-out)>>= 
void bundle::reset(source *src) 
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  if (strcmp(geom,"box")==0)
     <<bundle coordinates (box)>>
  if (strcmp(geom,"fan")==0)
     <<bundle coordinates>>
}
@ with 
<<bundle reset kernel>>=
__global__ void reset_kernel(ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__ray[k].v = 0;
}
@

\section{Coordinate system}
\label{sec:coordinate-system}

\index{rayTracing!coordinate\_system}
The surface location and orientation with respect to the GCS is specified with a coordinate vector:
<<coordinate system data>>=
vector *origin;
@ and with 3 Euler angles with respected to the x, y and z axis.
<<coordinate system data>>=
vector *euler_angles;
@ The surface can be made of [[N]] identical segments
<<coordinate system data>>=
int N; 
@
The rotation matrix [[R]] used to transform the ray coordinates into the surface coordinates (and back!) is defined with
<<coordinate system data>>=
rtd *R, *d__R;
float *float_R;
vector *d__origin;
@ 
Coordinate systems can be tagged:
<<coordinate system data>>=
char tag[32];
@ 
They are gathered in a new coordinate system data type
<<coordinate system data type>>=
struct coordinate_system{
  <<coordinate system data>>
  void setup(void);
  void setup(vector _origin_, vector _euler_angles_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_);
  void setup(vector *_origin_, vector *_euler_angles_, int _N_, char *_tag_);
  void cleanup(void);
  void info(void);
  void info_details(void);
  void update(void);
  void update(vector _origin_, vector _euler_angles_,int idx);
};
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup}

A coordinate system structure is initialized with
\begin{itemize}
\item a single origin and orientation,
\index{rayTracing!coordinate\_system!setup}
<<coordinate system functions>>=
void coordinate_system::setup(vector _origin_, vector _euler_angles_)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  memcpy( origin , &_origin_ , n_byte);
  memcpy(euler_angles,  &_euler_angles_, n_byte);
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item origin and orientation align to the main coordinate system,
\index{rayTracing!coordinate\_system!setup}
<<coordinate system functions>>=
void coordinate_system::setup(void)
{
  N = 1;
  HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
  int n_byte = sizeof(vector)*N;
  origin = (vector *)malloc( n_byte );
  euler_angles = (vector *)malloc( n_byte );
  origin[0].x = 0;
  origin[0].y = 0;
  origin[0].z = 0;
  euler_angles[0].x = 0;
  euler_angles[0].y = 0;
  euler_angles[0].z = 0;
  <<rotation matrix eval>>
  strcpy(tag,"coordinate_system");
  info();
}
@ 
\item an array of [[N]] origins and orientations:
  \begin{itemize}
  \item without a tag:
\index{rayTracing!coordinate\_system!setup}
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, int _N_)
{
  strcpy(tag,"coordinate_system");
  <<coordinate system setup common>>
}
@
\item or with a tag:
\index{rayTracing!coordinate\_system!setup}
<<coordinate system functions>>=
void coordinate_system::setup(vector *_origin_, vector *_euler_angles_, 
                              int _N_, char *_tag_)
{
  strcpy(tag,_tag_);
  <<coordinate system setup common>>
}
@  
\end{itemize}
where 
<<coordinate system setup common>>=
N = _N_;
HANDLE_ERROR( cudaMalloc((void**)&d__R, sizeof(rtd)*9*N ) );
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector)*N ) );
int n_byte = sizeof(vector)*N;
origin = (vector *)malloc( n_byte );
euler_angles = (vector *)malloc( n_byte );
memcpy( origin , _origin_ , n_byte);
memcpy(euler_angles,  _euler_angles_, n_byte);
<<rotation matrix eval>>
info();
@ 
\end{itemize}

The rotation matrix to transform the ray coordinates in the LCS is given by
\begin{eqnarray}
R &=& \left[ 
  \begin{array}{ccc}
    c\gamma & -s\gamma & 0 \\
    s\gamma &  c\gamma & 0 \\
    0       &  0       & 1
  \end{array}
  \right] \left[
  \begin{array}{ccc}
    c\beta & 0 & s\beta \\
    0      & 1 &  0 \\
    -s\beta & 0 &  c\beta
  \end{array}
  \right] \left[
    \begin{array}{ccc}
      1       &  0       & 0 \\
      0       &  c\alpha & -s\alpha \\
      0       &  s\alpha &  c\alpha 
    \end{array}
\right] \\
&=& \left[
  \begin{array}{ccc}
    c\beta c\gamma &  s\alpha s\beta c\gamma - c\alpha s\gamma & c\alpha s\beta c\gamma + s\alpha s\gamma \\
    c\beta s\gamma &  s\alpha s\beta s\gamma + c\alpha c\gamma & c\alpha s\beta s\gamma - s\alpha c\gamma \\
    -s\beta         &  s\alpha c\beta                           &  c\alpha c\beta
  \end{array}
\right]
\end{eqnarray}
where $cx$ and $sx$ stands for $\sin(x)$ and $\cos(x)$, respectively.
$\alpha$, $\beta$ and $\gamma$ are the Euler angles along the x, y and z axis respectively.
The matrix is computed with
<<rotation matrix eval>>=
R = (rtd *)malloc( sizeof(rtd)*9*N );
rtd ca, sa, cb, sb, cg, sg;
int k, idx;
for (k=0; k<N; k++)
  {
    idx = k;
    <<rotation matrix definition>>
  }
<<CS from host to device>>
/* for (k=0;k<9*N;k++) */
/*    *(float_R+k) = (float) R[k]; */
@ with
<<rotation matrix definition>>=
ca = cos(euler_angles[idx].x);
sa = sin(euler_angles[idx].x);
cb = cos(euler_angles[idx].y);
sb = sin(euler_angles[idx].y);
cg = cos(euler_angles[idx].z);
sg = sin(euler_angles[idx].z);
idx *= 9;
R[idx++] = cb*cg;
R[idx++] = sa*sb*cg - ca*sg;
R[idx++] = ca*sb*cg + sa*sg;
R[idx++] = cb*sg;
R[idx++] = sa*sb*sg + ca*cg;
R[idx++] = ca*sb*sg - sa*cg;
R[idx++] = -sb;
R[idx++] = sa*cb;
R[idx++] = ca*cb;
@ and
<<CS from host to device>>=
HANDLE_ERROR( cudaMemcpy( d__R, R, 
			    sizeof(rtd)*9*N, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMemcpy( d__origin, origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@ where the elements of $R$ are stored in the row major format.
\index{rayTracing!coordinate\_system!cleanup}
<<coordinate system functions>>=
void coordinate_system::cleanup(void)
{
  fprintf(stdout,"@(CEO)>coordinate_system: freeing memory!\n");
  free( origin );
  free( euler_angles );
  free(R);
  HANDLE_ERROR( cudaFree( d__R ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@ 
The coordinate system is updated with
\index{rayTracing!coordinate\_system!update}
<<coordinate system functions>>=
void coordinate_system::update(void)
{
  int k, idx;
  rtd ca, sa, cb, sb, cg, sg;
  for (k=0; k<N; k++)
    {
      idx = k;
      <<rotation matrix definition>>
    }
  <<CS from host to device>>
}
@ or with the origin [[_origin_]] and euler angles [[_euler_angles_]] vectors of a single segment identified with its index [[idx]]
<<coordinate system functions>>=
void coordinate_system::update(vector _origin_, vector _euler_angles_,int idx)
{
  int n_byte = sizeof(vector);
  memcpy( origin + idx , &_origin_ , n_byte);
  memcpy(euler_angles + idx,  &_euler_angles_, n_byte);
  rtd ca, sa, cb, sb, cg, sg;
  <<rotation matrix definition>>
  <<CS from host to device>>
}
@ 
\subsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the coordinate systems are displayed with the [[info]] routine:
\index{rayTracing!coordinate\_system!info\_details}
<<coordinate system functions>>=
void coordinate_system::info_details(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," ID (Tx          Ty        Tz)[m]  (Ox         Oy         Oz)[deg]\n");
  float c = 180.0/PI;
  int k;//, i, j, idx;
  for (k=0; k<N; k++)
    {
      fprintf(stdout," %2d  %+.3e   %+.3e   %+.3e      %+.3e   %+.3e   %+.3e\n", k,
	      origin[k].x, origin[k].y, origin[k].z,
	      euler_angles[k].x*c, euler_angles[k].y*c, euler_angles[k].z*c);
      /*
      fprintf(stdout,"Direction cosine matrix:\n");
      for (i=0;i<3;i++)
	{
	  fprintf(stdout,"||  ");
	  for (j=0;j<3;j++)
	    {
	      idx = j + i*3 + k*9;
	      fprintf(stdout,"%+.3e  ",R[idx]);
	    }
	  fprintf(stdout,"||\n");
	}
      */
    }
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ 
\index{rayTracing!coordinate\_system!info}
<<coordinate system functions>>=
void coordinate_system::info(void)
{
/*
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," %d coordinate systems\n",N);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
*/
}
@ 

\section{Conic surface}
\label{sec:surface}

\index{rayTracing!conic}

A conic surface is represented with the [[conic]] structure:
<<conic structure>>=
struct conic {

  <<conic parameters>>
  
  void setup(rtd _c_, rtd _k_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_);
  void setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin);
  void cleanup(void);
};
@
A conic surface is defined at a given location within a given coordinate system:
<<conic parameters>>=
coordinate_system ref_frame; 
vector origin, *d__origin;
@
The conic shape is specified with two parameters:
<<conic parameters>>=
rtd c, k;
@ 
where [[c]] is the vertex curvature and [[k]] is the conic parameter.

The conic surface is defined with
\begin{equation}
 \label{eq:4}
  F(x,y,z) = z - {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} } = 0.
\end{equation}
The conic expression is computed with
\index{rayTracing!conic!conic\_equation}
<<conic equations>>=
__host__ __device__ inline rtd conic_equation(vector *v, vector *v0, const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else {    
    rtd rho2;
    rho2 = c*v->rho2_shift(v0->x,v0->y);
    if (k==0)
      return rho2*0.5;
    else
      return rho2/( 1 + sqrt(1 - k*c*rho2) );
  }
}
@ 
and the surface equation with
\index{rayTracing!conic!conic\_surface}
<<conic equations>>=
__device__ inline rtd  conic_surface(vector *v, vector *v0, const rtd k, const rtd c)
{
  return v->z - v0->z - conic_equation(v, v0, k, c);
}
@
@ 
The partial derivative of the conic equation are written
\begin{itemize}
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial x } = -x {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
\index{rayTracing!conic!partial\_x\_conic\_surface}
<<conic equations>>=
 __device__ inline rtd partial_x_conic_surface(vector *v, vector *v0, 
					       const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -(v->x - v0->x)*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2_shift(v0->x,v0->y);
      return -(v->x - v0->x)*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial y } = -y {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
\index{rayTracing!conic!partial\_y\_conic\_surface}
<<conic equations>>=
__device__ inline rtd partial_y_conic_surface(vector *v, vector *v0, 
					      const rtd k, const rtd c)
{
  if (c==0)
    return 0.0;
  else    
    if (k==0)
      return -(v->y - v0->y)*c;
    else {
      rtd rho2;
      rho2 = c*v->rho2_shift(v0->x,v0->y);
      return -(v->y - v0->y)*c*rsqrt(1 - k*c*rho2);
    }
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial z } = 1
  \end{equation}
\index{rayTracing!conic!partial\_z\_conic\_surface}
<<conic equations>>=
__device__ inline rtd partial_z_conic_surface(void)
{
  return 1.0;
}
@
\end{itemize}

The generic expression for aspheric surface is given by
\begin{equation}
  \label{eq:69}
  F(x,y,z) = z - {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} } - \sum_{i=1}^N a_i Z_i(\rho,\theta) = 0.  
\end{equation}
\index{rayTracing!conic!aspheric\_surface}
<<conic equations>>=
__device__ inline rtd aspheric_surface(vector *v, vector *v0, 
                                       const rtd k, const rtd c,
				       const int max_n, rtd *a, const rtd R)
{
  return conic_surface(v, v0, k, c) - 
         zernike_surface(v->mag(R), v->angle(), max_n, a);
}
@ 
The partial derivative of the aspheric equation are written
\begin{itemize}
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial x } = -x {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
\index{rayTracing!conic!partial\_x\_aspheric\_surface}
<<conic equations>>=
__device__ inline rtd partial_x_aspheric_surface(vector *v, vector *v0, 
					       const rtd k, const rtd c,
					       const int max_n, rtd *cx,
					       const rtd R)
{
  return partial_x_conic_surface(v, v0,	k, c) - 
         zernike_surface(v->mag(R), v->angle(), max_n-1, cx);
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial y } = -y {c \over \sqrt{ 1 - \kappa c^2 \rho^2 } }
  \end{equation}
\index{rayTracing!conic!partial\_y\_aspheric\_surface}
<<conic equations>>=
__device__ inline rtd partial_y_aspheric_surface(vector *v, vector *v0, 
					      const rtd k, const rtd c,
					      const int max_n, rtd *cy,
					      const rtd R)
{
  return partial_y_conic_surface(v, v0,	k, c) - 
         zernike_surface(v->mag(R), v->angle(), max_n-1, cy);  
}
@
\item
  \begin{equation}
    { \partial F(x,y,z) \over \partial z } = 1
  \end{equation}
\index{rayTracing!conic!partial\_z\_aspheric\_surface}
<<conic equations>>=
__device__ inline rtd partial_z_aspheric_surface(void)
{
  return 1.0;
}
@
\end{itemize}

\subsection{Setup \& Cleanup}
\label{sec:surf-setup--cleanup}

A conic surface is initialized with the [[setup]] routine:
\index{rayTracing!conic!setup}
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@ or with a surface centered on [[origin]]
\index{rayTracing!conic!setup}
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_, vector _origin_, vector _euler_angles_, vector conic_origin)
{
  c = _c_;
  k = _k_;
  origin.x = conic_origin.x;
  origin.y = conic_origin.y;
  origin.z = conic_origin.z;
  ref_frame.setup(_origin_, _euler_angles_);
  <<conic allocation>>
}
@
A conic surface that sets in the GCS is simply defined with
\index{rayTracing!conic!setup}
<<conic functions>>=
void conic::setup(rtd _c_, rtd _k_)
{
  c = _c_;
  k = _k_;
  origin.x = 0;
  origin.y = 0;
  origin.z = 0;
  ref_frame.setup();
  <<conic allocation>>
}
<<conic allocation>>=
HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
@ 
The GMT M1 segmented conic is defined with
<<conic functions (opt-out)>>=
void conic::setup_GMT_M1(void)
{
  c = 1./36.0;
  k = 1 - 0.9982857;
  D_seg = 8.365;
  ri    = 2.4412/8.365;
  N = 7;
  vector origin[7];
  vector euler_angles[7];
  origin[0].x = origin[0].y = origin[0].z = 0.0;
  euler_angles[0].x = euler_angles[0].y = euler_angles[0].z = 0.0;
  rtd D_c, o, zo, sa;
  sa = sin(13.522*PI/180);
  D_c = 8.710 - (0.691-0.445)*sa;
  zo = 8.417*sa*0.5 + 0.691 - 0.445;
  int k;  
  for (k=1; k<N; k++)
  {
    o = PI*(2*k-1)/6.0;
    origin[k].x = D_c*cos(o);
    origin[k].y = D_c*sin(o);
    origin[k].z = zo;
    euler_angles[k].x = 0.0;
    euler_angles[k].y = 0.0
    euler_angles[k].z = 0.0;
  }
  ref_frame.setup(origin, euler_angles, N);
}
@
Memory is freed with
\index{rayTracing!conic!cleanup}
<<conic functions>>=
void conic::cleanup(void)
{
  fprintf(stdout,"@(CEO)>conic: freeing memory!\n");
  ref_frame.cleanup();
  HANDLE_ERROR( cudaFree( d__origin ) );
}
@

\section{Zernike surface}
\label{sec:zernike-surface}

\index{rayTracing!zernikeS}

A Zernike surface is defined as the weighted sum of Zernike polynomials and it is represented with the [[zernikeS]] structure:
<<zernikeS structure>>=
struct zernikeS {
  <<zernikeS parameters>>
  void setup(int max_n, rtd *a);
  void setup(int _max_n_, rtd *_a_, int _N_);
  void setup(int max_n, rtd *a, vector _origin_, vector _euler_angles_);
  void setup(int max_n, rtd *a, vector _origin_, vector _euler_angles_, int _N_);
  void cleanup(void);
  void surface(rtd *S, rtd *r, rtd *o, const int N);
  void surface(rtd *S, rtd *r, rtd *o, const int N, int surf_id);
  void update(rtd *a);
  void surface_derivative_coefs(void);
  void surface_derivatives(rtd *d__dSdx, rtd *d__dSdy, rtd *d__r, rtd *d__o, const int N);
  void projection(float *d__phase, rtd *d__r, rtd *d__o, const int N);
};
@ 
A Zernike surface is given by
\begin{equation}
  \label{eq:43}
  \varphi\left( \vec r \right) = \sum_{j=1}^J a_j Z_j\left(\vec r\right),
\end{equation}
where $a_j$ is the Zernike coefficients corresponding to the Zernike polynomials $Z_j\left(\vec r\right)$ and $\vec r$ is a vector defined such as $0\leq r \geq 1$.
Zernike polynomials are defined as:
\begin{equation}
  \label{eq:44}
  Z_j\left(\vec r\right) = \sqrt{n+1} R_{nm}(r) A_{jm}(\theta),
\end{equation}
where
\begin{equation}
  \label{eq:45}
  R_{nm}(r) = \sum_{k=0}^{n-m\over 2}(-1)^k{(n-k)! \over k!\left( {n+|m|\over 2} -k \right)!\left( {n-|m|\over 2} -k \right)!}r^{n-2k},
\end{equation}
and
\begin{equation}
  \label{eq:46}
  A_{jm}(\theta) = 2^{1-\delta_{m0}\over 2}\cos\left( m\theta + (1-\delta_{m0})((-1)^j-1){\pi\over 4} \right),
\end{equation}
with $\delta_{m0}$ the Kronecker symbol.

The parameters of the [[zernikeS]] structure are
\begin{itemize}
\item the Zernike mode [[j]], radial order [[n]] and azimuthal order [[m]]
<<zernikeS parameters>>=
int max_n;
unsigned int j, n, m, n_mode;
@
\item the Zernike coeffcients [[a]]
<<zernikeS parameters>>=
rtd *a, *d__a;
@
\item the Zernike derivative coefficients [[bx]] and [[by]]
<<zernikeS parameters>>=
rtd *bx, *by, *d__bx, *d__by;
@
\item the arrays for the sparse column format storage of [[bx]] and [[by]]
<<zernikeS parameters>>=
unsigned int *bx_row_idx, *bx_col_ptr, 
             *by_row_idx, *by_col_ptr,
             bx_nnz, by_nnz;
@
\item the Zernike surface derivative coefficients [[c]]
<<zernikeS parameters>>=
rtd *cx, *d__cx, *cy, *d__cy;
@
\item the number of Zernike surfaces [[N]]
<<zernikeS parameters>>=
int N;
@
\end{itemize}
Eq.~(\ref{eq:43}) is re--written
\begin{equation}
  \label{eq:51}
  \varphi\left( \vec r \right) = \sum_{n=0}^N \sqrt{n+1} \sum_{m=n}^{
    \begin{array}{c}
m=m-2\\
 m\geq 0
\end{array}
} R_{nm}(r) \left\{
    \begin{array}{l}
      \sqrt{2} \left[ a_j \cos(m\theta) + a_j\sin(m\theta) \right] \\
      a_j
    \end{array}
\right\}
\end{equation}

The Zernike surface is defined in a given coordinate system:
<<zernikeS parameters>>=
coordinate_system ref_frame; 
@ 

\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-3}

A [[zernikeS]] structure is initialized with the largest radial order in the surface and the series of Zernike coefficients for all the modes up to that radial order:
\index{rayTracing!zernikeS!setup}
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_)
{
  N = 1;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup();
  
  <<zernikeS setup common>>
}
@ 
The origin vector and Euler angles of the coordinate systems where the Zernike polynomials are defined can be passed as arguments:
\index{rayTracing!zernikeS!setup}
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, vector _origin_, vector _euler_angles_)
{
  N = 1;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup(_origin_, _euler_angles_);
  
  <<zernikeS setup common>>
}
@ 
An array of [[N]] Zernike surface is created with
\index{rayTracing!zernikeS!setup}
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, int _N_)
{
  N = _N_;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode*N;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup();
  
  <<zernikeS setup common>>
}
@ or with
\index{rayTracing!zernikeS!setup}
<<zernikeS functions>>=
void zernikeS::setup(int _max_n_, rtd *_a_, 
		     vector _origin_, vector _euler_angles_, int _N_)
{
  N = _N_;
  max_n = _max_n_;
  n_mode = (max_n+1.0)*(max_n+2.0)*0.5;
  int n_byte = sizeof(rtd)*n_mode*N;
  a = (rtd *)malloc( n_byte );
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMalloc((void**)&d__a, n_byte ) );
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );

  ref_frame.setup(_origin_, _euler_angles_);
  
  <<zernikeS setup common>>
}
@ where
<<zernikeS setup common>>=
if (max_n==0)
  return;

fprintf(stdout,"Computing Zernike derivative coefficients: ....");

int nel = n_mode*n_mode/2;
int n_col_ptr = (max_n+1.0)*max_n*0.5 + 1;

bx = (rtd *) malloc( sizeof(rtd)*nel);
bx_row_idx = (unsigned int *) malloc( sizeof(unsigned int)*nel);
bx_col_ptr = (unsigned int *) malloc( sizeof(unsigned int)*n_col_ptr);
memset( bx_col_ptr, 0 , sizeof(unsigned int)*n_col_ptr );

by = (rtd *) malloc( sizeof(rtd)*nel);
by_row_idx = (unsigned int *) malloc( sizeof(unsigned int)*nel);
by_col_ptr = (unsigned int *) malloc( sizeof(unsigned int)*n_col_ptr);
memset( by_col_ptr, 0 , sizeof(unsigned int)*n_col_ptr );

<<Zernike derivative coefficients>>
fprintf(stdout,"\b\b");
/*
fprintf(stdout,"bx_nnz=%d\n",bx_nnz);
fprintf(stdout,"b ; row_idx ; col_ptr\n");
for (int k=0;k<bx_nnz;k++) {
  if (k<n_col_ptr)
  fprintf(stdout,"b=%+4.2f ; %2d ; %2d\n",bx[k],bx_row_idx[k],bx_col_ptr[k]);
  else
  fprintf(stdout,"b=%+4.2f ; %2d\n",bx[k],bx_row_idx[k]);
}
fprintf(stdout,"by_nnz=%d\n",by_nnz);
fprintf(stdout,"b ; row_idy ; col_ptr\n");
for (int k=0;k<by_nnz;k++) {
  if (k<n_col_ptr)
  fprintf(stdout,"b=%+4.2f ; %2d ; %2d\n",by[k],by_row_idx[k],by_col_ptr[k]);
  else
  fprintf(stdout,"b=%+4.2f ; %2d\n",by[k],by_row_idx[k]);
}
*/

n_byte = N*sizeof(rtd)*(n_col_ptr-1);
cx = (rtd *) malloc( n_byte );
HANDLE_ERROR( cudaMalloc((void**)&d__cx, n_byte ) );

cy = (rtd *) malloc( n_byte );
HANDLE_ERROR( cudaMalloc((void**)&d__cy, n_byte ) );

surface_derivative_coefs();
fprintf(stdout,"\b\b");

HANDLE_ERROR( cudaMemcpy( d__cx, cx, 
			  n_byte, cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMemcpy( d__cy, cy, 
			  n_byte, cudaMemcpyHostToDevice ) );
fprintf(stdout,"\b\b!\n");
@ 
The Zernike derivative coefficients are saved into a sparse matrix using the compressed column storage:
<<Zernike derivative coefficients>>=
int j, n, m, jp, np, mp, kx=0, ky=0;
for (np=0;np<max_n;np++) {
  jp = np*(np+1)/2 + 1;
  mp = np%2;
  while (mp<=np) {
    <<Zernike derivative coefficients: part 2>>
      ++jp;
    if (mp>0) {
       <<Zernike derivative coefficients: part 2>>
	++jp;
    }
    mp += 2;
  }
 }
bx_col_ptr[jp-1] = kx;
bx_nnz = kx;
by_col_ptr[jp-1] = ky;
by_nnz = ky;
@
<<Zernike derivative coefficients: part 2>>=
for (n=np+1;n<=max_n;n++) {
  j = n*(n+1)/2 + 1;
  m = n%2;
  while (m<=n) {
    <<Zernike derivative coefficients: part 2a>>
    ++j;
    if (m>0) {
      <<Zernike derivative coefficients: part 2a>>
      ++j;
    }
    m += 2;
  }
 }
bx_col_ptr[jp] = kx;
by_col_ptr[jp] = ky;
@ 
<<Zernike derivative coefficients: part 2a>>=
  if (zern_dx_coef(bx+kx,j,n,m,jp,np,mp)) {
    bx_row_idx[kx] = j-1;
    ++kx;
  }
  if (zern_dy_coef(by+ky,j,n,m,jp,np,mp)) {
    by_row_idx[ky] = j-1;
    ++ky;
  }
@
From the Zernike derivative coefficients, the coefficients of the Zernike surface derivative are computed:
\index{rayTracing!zernikeS!surface\_derivative\_coefs}
<<zernikeS functions>>=
void zernikeS::surface_derivative_coefs(void) 
{
  int k,l,n,p, idx_a, idx_c;
  n = (max_n+1.0)*max_n*0.5;
  for (p=0;p<N;p++) {
    idx_a = p*n_mode;
    idx_c = p*n;
    for (k=0;k<n;k++) {
      cx[idx_c] = 0.0;
      for (l=bx_col_ptr[k];l<bx_col_ptr[k+1];l++)
	cx[idx_c] += a[ bx_row_idx[l] + idx_a ] * bx[l];
      /* fprintf(stdout,"cx = %4.2f\n",cx[k]); */
      cy[idx_c] = 0.0;
      for (l=by_col_ptr[k];l<by_col_ptr[k+1];l++)
	cy[idx_c] += a[ by_row_idx[l] + idx_a ] * by[l];
      /* fprintf(stdout,"cy = %4.2f\n",cy[k]); */
      idx_c++;
    }
  }
}
@ 
The Zernike coefficients are updated with
\index{rayTracing!zernikeS!update}
<<zernikeS functions>>= 
void zernikeS::update(rtd *_a_)
{
  int n_byte = sizeof(rtd)*n_mode*N;
  memcpy( a, _a_,  n_byte);
  HANDLE_ERROR( cudaMemcpy( d__a, a, 
			    n_byte, cudaMemcpyHostToDevice ) );
  surface_derivative_coefs();

  int n_col_ptr = (max_n+1.0)*max_n*0.5 + 1;
  n_byte = N*sizeof(rtd)*(n_col_ptr-1);
  HANDLE_ERROR( cudaMemcpy( d__cx, cx, 
			    n_byte, cudaMemcpyHostToDevice ) );
  HANDLE_ERROR( cudaMemcpy( d__cy, cy, 
			    n_byte, cudaMemcpyHostToDevice ) );
}
@
Memory is freed with:
\index{rayTracing!zernikeS!cleanup}
<<zernikeS functions>>=
void zernikeS::cleanup(void)
{
  fprintf(stdout,"@(CEO)>zernikeS: freeing memory!\n");
  free( a );
  HANDLE_ERROR( cudaFree( d__a) );
  if (max_n>0) {
    free( bx );
    free( bx_row_idx );
    free( bx_col_ptr );
    free( by );
    free( by_row_idx );
    free( by_col_ptr );
    free( cx );
    free( cy );
    HANDLE_ERROR( cudaFree( d__cx) );
    HANDLE_ERROR( cudaFree( d__cy) );
  }
}
@
\subsection{Zernike surface equation}
\label{sec:zern-surf-equat}

\index{rayTracing!zernikeS!surface}
<<zernikeS functions>>=
void zernikeS::surface(rtd *d__S, rtd *d__r, rtd *d__o, const int N)
{
    dim3 blockDim(N_THREAD,N_THREAD);
    dim3 gridDim(N/N_THREAD2+1,1);
    surface_kern LLL gridDim, blockDim RRR (d__S, d__r, d__o, N, max_n, d__a);
}
@ 
\index{rayTracing!zernikeS!surface}
<<zernikeS functions>>=
void zernikeS::surface(rtd *d__S, rtd *d__r, rtd *d__o, const int N, int surf_id)
{
  //fprintf(stdout,"a offset = %d\n",surf_id*n_mode);
    dim3 blockDim(N_THREAD,N_THREAD);
    dim3 gridDim(N/N_THREAD2+1,1);
    surface_kern LLL gridDim, blockDim RRR (d__S, d__r, d__o, N, max_n, d__a + surf_id*n_mode);

}
@ with 
<<zernike surface kernel>>=
__global__ void surface_kern(rtd *S, rtd *r, rtd *o, const int N, 
			     int max_n, rtd *a)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if (k<N) {
    S[k] = zernike_surface(r[k], o[k], max_n, a);
  }
}
@ where
\index{rayTracing!zernikeS!zernike\_surface}
<<zernike surface equation>>=
__host__ __device__ rtd zernike_surface(rtd r, rtd o, int max_n, rtd *a)
{
  int n, m, mH, a_idx,j;
  rtd R, R2, R4, A, S_n, S, 
    H1, H2, H3, sm, cm, s2, c2, s ,c, sqrt2;
  if (max_n<0)//( (r>1.0) || (max_n<0) )
    S = 0.0;
  else {
    R = 1.0;
    S = a[0]*R;
    <<zernike surface: radial order sum>>
    }
  return S;
}
@ 
The Zernike surface is computed by summing all the azimuthal order of a each radial order from the highest to the lowest azimuthal order.
The Zernike coefficients [[a]] are ordered by increasing azimuthal order.
<<zernike surface: radial order sum>>=
sqrt2 = sqrt(2.0);
sincos(2*o,&s2,&c2);
for (n=1;n<=max_n;n++) {
  j = (n+1)*(n+2)/2;
  a_idx = j - 1;

  m = n;
  R = pow(r,n);
  sincos(m*o, &sm, &cm);
  if (j%2) {
    A = a[a_idx--]*sm;
    A += a[a_idx--]*cm;
  } else {
    A = a[a_idx--]*cm;
    A += a[a_idx--]*sm;
  }
  j -= 2;
  A *= sqrt2;
  S_n = R*A;

  m -= 2;
  if (m>=0) {
    R2 = n*R - (n-1.0)*pow(r,m);
    <<azimuth>>
    S_n += R2*A;
  }

  m -= 2;
  while (m>=0) {
    mH = m + 4;
    if (r>0) {
      <<H3>>
      <<H2>>
      <<H1>>
      <<R recurrence>>
      <<azimuth>>
    } else {
      R4 = (m==0) ? pow(-1.0,0.5*n) : 0.0;
      A = 1.0;
    }
    S_n += R4*A;
    R  = R2;
    R2 = R4;
    m -= 2;
  }
  S += sqrt(n+1.0)*S_n;
}
@ 
The azimuthal function are computed in a decreasing $m$ order starting from $m=n$, to $n-2$, $n-4$,...
The azimuthal function are derived using the following recurrence relation
\begin{eqnarray}
  \label{eq:54}
  \cos(m-2\theta) &=& \cos(m\theta)\cos(2\theta) + \sin(m\theta)\sin(2\theta) \\
  \sin(m-2\theta) &=& \sin(m\theta)\cos(2\theta) - \cos(m\theta)\sin(2\theta) 
\end{eqnarray}
<<azimuth>>=
  if (m>0) {
    c = cm*c2 + sm*s2;
    s = sm*c2 - cm*s2;
    if (j%2) {
      A = a[a_idx--]*s;
      A += a[a_idx--]*c;
    } else {
      A = a[a_idx--]*c;
      A += a[a_idx--]*s;
    }
    j -= 2;
    A *= sqrt2;
    cm = c;
    sm = s;
  } else {
    A = a[a_idx--];
    --j;
  }
@ 
The radial functions $R_{nm}(r)$ are derived from the recurrence relation\cite{CRM03}:
\begin{equation}
  \label{eq:47}
  R_{n(m-4)}(r) = H_1R_{nm}(r) + \left( H_2 + {H_3 \over r^2} \right) R_{n(m-2)}(r),
\end{equation}
<<R recurrence>>=
R4 = H1*R + ( H2 + H3/(r*r) )*R2;
@
starting at $m=n$ and with
\begin{equation}
  \label{eq:52}
  R_{nn}(r) = r^n,
\end{equation}
and
\begin{equation}
  \label{eq:53}
  R_{n(n-2)}(r) = nR_{nn}(r) - (n-1)R_{(n-2)(n-2)}(r).
\end{equation}
@ 
where
\begin{equation}
  \label{eq:48}
  H_1 = {m(m-1) \over 2} - mH_2 + H_3{ (n+m+2)(n-m) \over 8 },
\end{equation}
<<H1>>=
H1 = mH*(mH-1.0)*0.5 - mH*H2 + H3*(n+mH+2.0)*(n-mH)*0.125;
@ 
\begin{equation}
  \label{eq:49}
  H_2 = H_3{(n+m)(n-m+2) \over 4(m-1) } + (m-2),
\end{equation}
<<H2>>=
H2 = H3*0.25*(n+mH)*(n-mH+2.0)/(mH-1.0) + mH - 2.0;
@ 
and
\begin{equation}
  \label{eq:50}
  H_3 = {-4(m-2)(m-3) \over (n+m-2)(n-m+4) }.
\end{equation}
<<H3>>=
H3 = -4.0*(mH-2.0)*(mH-3.0)/((n+mH-2.0)*(n-mH+4.0));
@

\subsection{Zernike surface derivative}
\label{sec:zern-surf-deriv}

The partial derivative of the Zernike surface given in Eq.~(\ref{eq:43}) is written
\begin{equation}
  \label{eq:55}
  {\partial \varphi \left( \vec r \right) \over \partial x } = \sum_{j=2}^N a_j   {\partial Z_j \left( \vec r \right) \over \partial x },
\end{equation}
where
\begin{equation}
  \label{eq:56}
  {\partial Z_j \left( \vec r \right) \over \partial x } = \sum_{k=1}^{j-1} b_{jk}^x Z_k \left( \vec r \right)
\end{equation}
Inserting Eq.~(\ref{eq:55}) into Eq.~(\ref{eq:56}) leads to
\begin{equation}
  \label{eq:57}
  {\partial \varphi \left( \vec r \right) \over \partial x } = \sum_{j=2}^N a_j \sum_{k=1}^{j-1} b_{jk}^x Z_k \left( \vec r \right) = \sum_{k=1}^{N-1} Z_k \left( \vec r \right) \sum_{j={k+1}}^N a_jb_{jk}^x  = \sum_{k=1}^{N-1} Z_k \left( \vec r \right) c_{k}^x,
\end{equation}
with
\begin{equation}
  \label{eq:58}
  c_k^x = \sum_{j={k+1}}^N a_jb_{jk}^x.
\end{equation}

The x and y derivatives of the Zernike surface are computed with
\index{rayTracing!zernikeS!surface\_derivatives}
<<zernikeS functions>>=
void zernikeS::surface_derivatives(rtd *d__dSdx, rtd *d__dSdy, 
				   rtd *d__r, rtd *d__o, const int N)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N/N_THREAD2+1,1);
  surface_kern LLL gridDim, blockDim RRR (d__dSdx, d__r, d__o, N, max_n-1, d__cx);
  surface_kern LLL gridDim, blockDim RRR (d__dSdy, d__r, d__o, N, max_n-1, d__cy);
}
@
Both derivatives depends on the projection coefficients of Zernike x and y derivatives:  
<<zernike derivative x coefficient>>=
int zern_dx_coef(rtd *b, int j, int n, int m, int jp, int np, int mp) 
{
  int delta_m, rule_0, rule_1, rule_2, rule_3;
  delta_m = mp - m;
  rule_0 = (delta_m==1) || (delta_m==-1);
  rule_1 = (j-jp)%2 == 0 && !( (m==0) || (mp==0) );
  rule_2 = ( (m==0) && (mp!=0) ) && (jp%2 == 0);
  rule_3 = ( (m!=0) && (mp==0) ) && (j%2  == 0);
  if ( rule_0 && (rule_1||rule_2||rule_3) )
    *b = sqrt( (n+1.0)*(np+1.0) );
  else 
    return 0;
  if ( (m==0) || (mp==0) )
    *b *= sqrt(2.0);
  return 1;
}
@ 
<<zernike derivative y coefficient>>=
int zern_dy_coef(rtd *b, int j, int n, int m, int jp, int np, int mp) 
{
  int delta_m, rule_0, rule_1, rule_2, rule_3, sign_rule_1, sign_rule_2;
  delta_m = mp - m;
  rule_0 = (delta_m==1) || (delta_m==-1);
  rule_1 = (j-jp)%2 == 1 && !( (m==0) || (mp==0) );
  rule_2 = ( (m==0) && (mp!=0) ) && (jp%2 == 1);
  rule_3 = ( (m!=0) && (mp==0) ) && (j%2  == 1);
  if ( rule_0 && (rule_1||rule_2||rule_3) )
    *b = sqrt( (n+1.0)*(np+1.0) );
  else
    return 0;
  sign_rule_1 = (delta_m==+1) && (j%2 == 1);
  sign_rule_2 = (delta_m==-1) && (j%2 == 0);
  if ( ( (m!=0) && (mp!=0) ) && ( sign_rule_1 || sign_rule_2 ) )
    *b *= -1;
  if ( (m==0) || (mp==0) )
    *b *= sqrt(2.0);
  return 1;
}
@
\subsection{Projection}
\label{sec:projection}

The projection $a_i$ of a wavefront phase $\varphi$ onto a Zernike polynomial is given by
\begin{equation}
  \label{eq:59}
  a_i = { \sum_k \varphi\left( \vec r_k \right) Z_i\left( \vec r_k \right) \over \sum_k \left| Z_i\left( \vec r_k \right) \right|^2 }
\end{equation}
@ 
\index{rayTracing!zernikeS!projection}
<<zernikeS functions>>=
void zernikeS::projection(float *d__phase, rtd *d__r, rtd *d__o, const int N)
{
  int k;
  int n_byte = sizeof(rtd)*n_mode;
  rtd *d__ap;
  HANDLE_ERROR( cudaMalloc((void**)&d__ap, n_byte ) );
  HANDLE_ERROR( cudaMemset(d__ap, 0, n_byte ) ); 
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  for (k=0;k<n_mode;k++)
    projection_kern LLL gridDim, blockDim RRR (d__a, d__phase, d__r, d__o, N, max_n, d__ap, k);
  HANDLE_ERROR( cudaFree( d__ap) );
  HANDLE_ERROR( cudaMemcpy( a, d__a, 
			    sizeof(rtd)*n_mode, cudaMemcpyDeviceToHost ) );
}
@ where
<<zernike projection kernel>>=
__global__ void projection_kern(rtd *a, float *phase, rtd *r, rtd *o, const int N, 
				int max_n, rtd *ap, int mode)
{
  int i;
  rtd num, denom, z;
  num = denom = 0.0;
  ap[mode] = 1.0;
  for (i=0; i<N; i++) {
    if (phase[i]!=0) 
      {
	z = zernike_surface(r[i], o[i], max_n, ap);
	num   += phase[i]*z;
	denom += z*z;
      }
  }
  a[mode]  = num/denom;
  ap[mode] = 0.0;
}
@
\section{Aperture}
\label{sec:aperture}

\index{rayTracing!aperture}
An aperture is a bounded surface used to clip a bundle of ray to the aperture shape.
<<aperture structure>>=
struct aperture {
  <<aperture parameters>>
  void setup(float _D_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, int _D_px_, 
	     vector _origin_, vector _euler_angles_);
  void setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
	     vector *_origin_, vector *_euler_angles_, int N_segment);
  void setup_GMT_M1(float _D_, int _D_px_);
  void cleanup(void);
  void vignetting(bundle *rays);

};
@
A circular aperture is defined by its diameter [[D]] in meter of [[D_px]] in pixel.
If the aperture is annular [[ri]] defines the ratio between the inner and outer diameter.
The aperture can be segmented with [[N]] identical segments of diameter [[D_seg]].
The location of the aperture segments is defined within a given coordinate system [[ref_frame]].
A mask [[V]] is used to select the rays that are not vignetted by the aperture.
<<aperture parameters>>= 
int D_px;
float D, ri, D_seg;
int N;
mask V;
coordinate_system ref_frame;

@
\subsection{Setup \& Cleanup}
\label{sec:aper-setup--cleanup}

An aperture is initialized with:
\begin{itemize}
\item for a circular aperture,
\index{rayTracing!aperture!setup}
<<aperture functions>>=
void aperture::setup(float _D_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = 0.0;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@  \item for an annular aperture,
\index{rayTracing!aperture!setup}
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, int _D_px_, 
		     vector _origin_, vector _euler_angles_) 
{
  D_px = _D_px_;
  D_seg = D = _D_;
  ri   = _ri_;
  N = 1;
  V.setup(D_px*D_px);
  ref_frame.setup(_origin_, _euler_angles_);
}
@
\item for an aperture with [[N_segment]] circular segment of diameter [[D_seg]], each segment with a different coordinate system,
\index{rayTracing!aperture!setup}
<<aperture functions>>=
void aperture::setup(float _D_, float _ri_, float _D_seg_, int _D_px_, 
		     vector *_origin_, vector *_euler_angles_, int N_segment)
{
  D_px  = _D_px_;
  D     = _D_;
  D_seg = _D_seg_;
  ri    = _ri_;
  N = N_segment;
  V.setup(D_px*D_px*N);
  ref_frame.setup(_origin_, _euler_angles_, N);
}
@
\end{itemize}

The memory is freed with
\index{rayTracing!aperture!cleanup}
<<aperture functions>>=
void aperture::cleanup(void)
{
  fprintf(stdout,"@(CEO)>aperture: freeing memory!\n");
  V.cleanup();
  ref_frame.cleanup();
}
@ 
The vignetting of the rays are done with
\index{rayTracing!aperture!vignetting}
<<aperture functions>>=
void aperture::vignetting(bundle *rays)
{
  float R2, Rri2;
  R2 = D_seg*D_seg*0.25;
  Rri2 = R2*ri*ri;
  fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  HANDLE_ERROR( cudaMemset(V.m, 0, sizeof(char)*rays->N_RAY ) );
  vignetting_kernel LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY, 
						Rri2, R2,
						ref_frame.d__R,
						ref_frame.d__origin);
  intersection LLL gridDim , blockDim RRR (V.m, rays->d__ray, rays->N_RAY);
}
@ calling the device kernel:
<<vignetting kernel>>=
__global__ void vignetting_kernel(char *mask, ray *d__ray, int N_RAY, 
				  float inner2, float outer2,
				  rtd *d__R, vector *d__origin)
{
  int i, j, ij, iCoordSys, idx;
  rtd rho2;
  rtd x, y, z, u, v, w, x1, y1, s0, k, l, m;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( ij<N_RAY )
  {

    idx = iCoordSys;

    u = d__ray[ij].coordinates.x - d__origin[idx].x;
    v = d__ray[ij].coordinates.y - d__origin[idx].y;
    w = d__ray[ij].coordinates.z - d__origin[idx].z;

    idx = iCoordSys*9;

    x = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    y = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    z = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    u = d__ray[ij].directions.x;
    v = d__ray[ij].directions.y;
    w = d__ray[ij].directions.z;

    k = d__R[0+idx]*u + d__R[3+idx]*v + d__R[6+idx]*w;
    l = d__R[1+idx]*u + d__R[4+idx]*v + d__R[7+idx]*w;
    m = d__R[2+idx]*u + d__R[5+idx]*v + d__R[8+idx]*w;

    if (m==0) { return; }
    s0 = -z/m;
    x1 = x + k*s0;
    y1 = y + l*s0;
    rho2 = x1*x1 + y1*y1;
    if ( (iCoordSys==0) && (rho2<inner2) )
      {
	return;
      }
    if (rho2<=outer2)
      {
	mask[ij] = 1;
      }
  }
}
@
The vignetting by the aperture is computed as the intersection between the aperture mask and the ray vignetting flags: 
<<aperture intersection>>=
__global__ void intersection(char *mask, ray *d__ray, int N_RAY)
{
  int i, j, ij, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if  ( ij<N_RAY )
  {
    ij += iSource*N_RAY;
    d__ray[ij].v &= mask[ij];
  }
}
@

\section{Ray tracing routines}
\label{sec:ray-tracing-routines}

\subsection{Coordinates transformation}
\label{sec:coord-transf}

The coordinates and cosine directions of the rays need to be transformed into the surface coordinates system first.
The matrix [[R]] in the conic structure transforms the coordinates in the LCS $(x,y,z)$ into the GCS $(\bar x,\bar y,\bar z)$ i.e.
\begin{equation}
  \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = R \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right]
\end{equation}
The reverse transform is simply
\begin{equation}
  \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right] = R^T \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = \left( \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right]^T R \right)^T 
\end{equation}
<<transformation to surface system>>=
void transform_to_S(bundle *rays, conic *F)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_S(bundle *rays, aperture *A)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
					     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to surface system kernel>>=
__global__ void transform_to_S_kernel(ray *d__ray, int N_RAY, 
				      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    forward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		      d__R, d__origin);
    forward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
			       d__R);
  }
}
@ with the projection of the ray coordinates in the surface reference frame LCS:
<<coordinates forward transform>>=
__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
					 rtd *d__R, vector *d__origin)
{
  rtd u, v, w;
  u = v_in->x - d__origin->x;
  v = v_in->y - d__origin->y;
  w = v_in->z - d__origin->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;
  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
@ 
<<transformation to rays system>>=
void transform_to_R(bundle *rays, conic *F)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_R(bundle *rays, aperture *A)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to rays system kernel>>=
__global__ void transform_to_R_kernel(ray *d__ray, int N_RAY,
                                      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    backward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		       d__R, d__origin);
    backward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
				d__R);
  }
}
@ with the projection of the ray coordinates in the rays reference frame LCS:
@ 
<<coordinates backward transform>>=
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

  v_out->x += d__origin->x;
  v_out->y += d__origin->y;
  v_out->z += d__origin->z;    
}  
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;
}  
@ 

\subsection{Surface intersection}
\label{sec:surface-intersection}

<<intersection with surface>>=
void intersect(bundle *rays, conic *F)
{
  intersect_chief_kernel LLL 1 , 1 RRR (rays->d__chief_ray, 1,
						     F->k, F->c, F->d__origin);
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  intersect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 
					       F->k, F->c, F->d__origin,
					       rays->d__chief_ray);
}

<<intersection with surface kernel>>=
__global__ void intersect_chief_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin)
{
  int j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  ij = 0;

  <<intersection with z=0 plane>>
  d__ray[ij].optical_path_length = s0;
  s0 = s1 = 0;
  for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
      s0 = s1;
    }
}
__global__ void intersect_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin,
                                 ray *d__chief_ray)
{
  int i, j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<intersection with z=0 plane>>
    d__ray[ij].optical_path_length = s0;
    s0 = s1 = 0;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
	s0 = s1;
    }
  d__ray[ij].optical_path_difference += 
    d__ray[ij].optical_path_length - d__chief_ray->optical_path_length;
  }
}
@
The intersection of a ray with the surface is derived using the parametric equations of the ray
\begin{eqnarray}
  \label{eq:3}
  x &=& x_0 + ks \\
  y &=& y_0 + ls \\
  z &=& z_0 + ms   
\end{eqnarray}
where $s$ is the distance along the ray from the point $(x_0,y_0,z_0)$.
Eq.~(\ref{eq:3}) are inserted into the surface definition Eq.~(\ref{eq:4}) that is solved for $s$.

The intersection with the plane $z=0$ in the LCS is derived first leading to 
\begin{eqnarray}
  \label{eq:5}
  s_0 &=& -z_0/m \\
  x_1 &=& x_0 + ks_0 \\
  y_1 &=& y_0 + ls_0 
\end{eqnarray}
<<intersection with z=0 plane>>=
k  = d__ray[ij].directions.x;
l  = d__ray[ij].directions.y;
m  = d__ray[ij].directions.z;
if (m==0) { return; }
s0 = -d__ray[ij].coordinates.z/m;
x1 = d__ray[ij].coordinates.x + k*s0;
y1 = d__ray[ij].coordinates.y + l*s0;
@
and giving a new set of parametric equations
\begin{eqnarray}
  \label{eq:6}
  x &=& x_1 + ks \\
  y &=& y_1 + ls \\
  z &=& ms     
\end{eqnarray}
 
The distance $s$ to the surface is obtained with the Newton--Raphson iterative method
\begin{equation}
  \label{eq:7}
  s_{j+1} = s_j - { F(x_j,y_j,z_j) \over F^\prime(x_j,y_j,z_j) }
\end{equation}
where
\begin{eqnarray}
  \label{eq:8}
  x_j &=& x_1 + ks_j \\
  y_j &=& y_1 + ls_j \\
  z_j &=& ms_j       
\end{eqnarray}
<<Newton-Raphson>>=
vv.x = x1 + k*s0;
vv.y = y1 + l*s0;
vv.z = m*s0;
@ and where
\begin{eqnarray}
  \label{eq:9}
  F^\prime(x_j,y_j,z_j) &=& \left. { {\mathrm d} F \over {\mathrm d} s  } \right|_{s=s_j} \\
                      &=& k\left.{ \partial F(x,y,z) \over \partial x } \right|_j + l\left. { \partial F(x,y,z) \over \partial y }\right|_j + m\left.{ \partial F(x,y,z) \over \partial z }\right|_j
\end{eqnarray}
<<Newton-Raphson>>=
S = conic_surface(&vv, d__origin, Fk, Fc);
K = partial_x_conic_surface(&vv, d__origin, Fk, Fc);
L = partial_y_conic_surface(&vv, d__origin, Fk, Fc);
M = partial_z_conic_surface();
dSds = K*k + L*l + M*m;
if (dSds==0) { return; }
s1 = s0 - S/dSds;
if (abs(s1-s0)<TOL)
{
  d__ray[ij].coordinates.x = x1 + k*s1;
  d__ray[ij].coordinates.y = y1 + l*s1;
  d__ray[ij].coordinates.z = m*s1;
  d__ray[ij].surface_normal.x    = 
    partial_x_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.y    =
    partial_y_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.z    = partial_z_conic_surface();
  d__ray[ij].optical_path_length += s1;
  d__ray[ij].n_iteration = j;
  break;
}
@
The iterative process is started with
\begin{equation}
  \label{eq:11}
  s_1 = 0,
\end{equation}
and is terminated when
\begin{equation}
  \label{eq:12}
  \left|s_{j+1} - s_j \right| < \epsilon,
\end{equation}
where $\epsilon$ is a tolerance set by the required accuracy.

The final distance along a ray from the point $(x_0,y_0,z_0)$ is
\begin{equation}
  \label{eq:13}
  s = s_0 + s_{j+1}.
\end{equation}

The surface normal at the intersection point will be needed to compute the refracted ray:
\begin{eqnarray}
  \label{eq:1}
  K &=& \left.{ \partial F(x,y,z) \over \partial x } \right|_{j+1} \\
  L &=& \left.{ \partial F(x,y,z) \over \partial y } \right|_{j+1} \\
  M &=& \left.{ \partial F(x,y,z) \over \partial z } \right|_{j+1}.
\end{eqnarray}
@

\subsection{Snell's law}
\label{sec:snells-law}

\subsubsection{Refraction}
\label{sec:refraction}

\def\np{n^\prime}
\def\kp{k^\prime}
\def\lp{l^\prime}
\def\mp{m^\prime}
\def\Sp{S^\prime}

The Snell's law can be written as
\begin{equation}
  \label{eq:10}
  \np \vec \Sp \times \vec r = n \vec S \times \vec r.
\end{equation}
$\vec S:(k,l,m)$ and $\vec \Sp:(\kp,\lp,\mp)$ are both unit vectors along the incident and refracted rays, respectively.
$\vec r:(K,L,M)$ is a unit vector normal to the refraction surface at the ray intersection point.
$n$ and $\np$ are the refractive indices for the incident and refracted rays, respectively.

Eq.~(\ref{eq:10}) implies that the three vectors $\vec S$, $\vec \Sp$ and $\vec r$ are co--planar, from which it follows that
\begin{equation}
  \label{eq:14}
  \vec \Sp = \mu \vec S + \Gamma \vec r,
\end{equation}
where $\mu=n/\np$ and $\Gamma$ has to be determined.
$\Gamma$ is derived by solving
\begin{equation}
  \label{eq:15}
  \left| \vec \Sp \right|^2 - \left| \mu \vec S + \Gamma \vec r \right|^2 = 0
\end{equation}
Developing Eq.~(\ref{eq:15}) leads to $\Gamma$ being the solution of a quadratic equation
\begin{equation}
  \label{eq:16}
  \Gamma^2 + 2a\Gamma + b = 0
\end{equation}
where
\begin{equation}
  \label{eq:17}
  a = \mu { kK +lL + mM \over K^2 + L^2 + M^2 },
\end{equation}
<<a equation>>=
K = d__ray[ij].surface_normal.x;
L = d__ray[ij].surface_normal.y;
M = d__ray[ij].surface_normal.z;
G2 = K*K + L*L + M*M;
k = d__ray[ij].directions.x;
l = d__ray[ij].directions.y;
m = d__ray[ij].directions.z;
a = mu*(k*K + l*L + m*M)/G2;
@  and
\begin{equation}
  \label{eq:18}
  b = { \mu^2 -1 \over K^2 + L^2 + M^2 }.
\end{equation}
<<b equation>>=
b = (mu*mu-1)/G2;
@ 
Eq.~(\ref{eq:16}) is solved with the Newton--Raphson iterative method by introducing the new function
\begin{equation}
  \label{eq:19}
  V(\Gamma) = \Gamma^2 + 2a\Gamma + b,
\end{equation}
and writing $\Gamma$ as
\begin{equation}
  \label{eq:20}
  \Gamma_{j+1} = \Gamma_j - { V(\Gamma_j) \over V^\prime(\Gamma_j) }.
\end{equation}
Noting that
\begin{equation}
  \label{eq:21}
  V^\prime(\Gamma_j) = \left. { \mathrm d V \over \mathrm d \Gamma } \right|_j = 2\left( \Gamma_j + a \right),
\end{equation}
Eq.~(\ref{eq:20}) becomes
\begin{equation}
  \label{eq:22}
  \Gamma_{j+1} = { \Gamma_j^2 - b \over 2(\Gamma_j + a) }.
\end{equation}
with
\begin{equation}
  \label{eq:23}
  \Gamma_1 = {-b \over 2a }.
\end{equation}

<<refraction>>=
void refract(bundle *rays, const rtd mu)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  refract_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, mu);
}
@ 
<<refraction kernel>>=
__global__ void refract_kernel(ray *d__ray, int N_RAY, const rtd mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a, b, gamma0, gamma1, gamma_relative_error;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    <<b equation>>
    gamma0 = -0.5*b/a;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      gamma1 = 0.5*(gamma0*gamma0-b)/(gamma0+a);
      gamma_relative_error = abs( gamma1/gamma0 - 1.0 );
      if (gamma_relative_error<0.01)
      {
        d__ray[ij].directions.x = mu*k + gamma1*K;
        d__ray[ij].directions.y = mu*l + gamma1*L;
        d__ray[ij].directions.z = mu*m + gamma1*M;
        return;
      }
      gamma0 = gamma1;
    }
  }
}
@
\subsubsection{Reflection}
\label{sec:reflection}

In the case of reflection, one have $\mu=1$, $b=0$ and
\begin{equation}
  \label{eq:24}
  \Gamma = -2a.
\end{equation}
Eq.~(\ref{eq:14}) thus becomes
\begin{equation}
  \label{eq:25}
    \vec \Sp = \vec S -2a \vec r.
\end{equation}
<<reflection>>=
void reflect(bundle *rays)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 1.0);
}
@ 
Setting $\mu=-1$ makes the mirror behaving like a thin lens:
<<thin lens>>=
void thin_lens(bundle *rays)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(rays->N_RAY/N_THREAD2+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, -1.0);
}
@ 
<<reflection kernel>>=
    __global__ void reflect_kernel(ray *d__ray, int N_RAY, float mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    a *= -2.0;
    d__ray[ij].directions.x = mu*k + a*K;
    d__ray[ij].directions.y = mu*l + a*L;
    d__ray[ij].directions.z = mu*m + a*M;
  }
}
@

\section{Input/Output}
\label{sec:inputoutput}

\section{Tests}
\label{sec:tests}

<<rayTracing.bin>>=
<<benchmark II>>
@ 
\subsection{Benchmark I}
\label{sec:benchmark-i}

<<benchmark I>>=
#include <iostream>
#include <fstream>
#include "ceo.h"
using namespace std;

int main(int argc,char *argv[]) {
  int N_GS, N_GS_max, nPx, k_nPx, k_GS, zern_j, zern_n, k;
  float elaspedTime;
  rtd D;
  vector src_origin, zern_origin, zern_euler_angles;
  ofstream f;
  float *zen, *azi;
  
  D = 25.5;
  src_origin.x =  0.0;
  src_origin.y =  0.0;
  src_origin.z = 25.0;

  nPx = 256;

  stopwatch tid;
  source src;
  zernikeS zern;
  gmt_m1 M1;
  gmt_m2 M2;

  zern_n = 6;
  zern_j = (zern_n+1)*(zern_n+2)/2;
  rtd *a;
  a = (rtd *)malloc( sizeof(rtd)*zern_j );
  for (k=0;k<zern_j;k++)
    a[k] = 1e-6;
  zern_origin.x = zern_origin.y = zern_origin.z = 0.0;
  zern_euler_angles.x = zern_euler_angles.y = zern_euler_angles.z = 0.0;
  zern.setup(zern_n,a,zern_origin,zern_euler_angles,7);

  N_GS_max = 3;

  f.open("bench0.txt");
  f.precision(3);
  f << "nPx";
  for (k_GS=1;k_GS<=N_GS_max;k_GS++) 
    f << "\t" << k_GS << "GS";
  f << endl;

  nPx = 2;
  for (k_nPx=2;k_nPx<11;k_nPx++) {

    nPx*=2;
    f << nPx;

    for (N_GS=1; N_GS<=N_GS_max; N_GS++) {

      zen = (float *) malloc( sizeof(float)*N_GS );
      azi = (float *) malloc( sizeof(float)*N_GS );
      for (k_GS=0;k_GS<N_GS;k_GS++) {
	zen[k_GS] = 0.0;
	azi[k_GS] = 0.0;
      }    

      src.setup("R",zen,azi,INFINITY,N_GS,D,nPx,src_origin);

      M1.setup(D,nPx,&zern,0);

      M2.setup(D,nPx,&zern,N_GS);

      /* for (int k=0;k<2;k++) { */
      /* 	M2.blocking( &(src.rays) ); */
      /* 	M1.trace( &(src.rays) ); */
      /* 	M2.trace( &(src.rays) ); */
      /* 	src.rays.to_sphere(-5.830,2.197173); */
      /* 	src.opd2phase(); */
      /* } */

      tid.tic();

      src.wavefront.reset();
      src.reset_rays();
      M2.blocking( &(src.rays) );
      M1.trace( &(src.rays) );
      M2.trace( &(src.rays) );
      src.rays.to_sphere(-5.830,2.197173);
      src.opd2phase();

      tid.toc(&elaspedTime);
      f << "\t" << elaspedTime;

      src.cleanup();
      M1.cleanup();
      M2.cleanup();
      free(zen);
      free(azi);

    } // N_GS
    f << endl;
  } // nPx
  f.close();
  zern.cleanup();
  free(a);
 }
@ 
\subsection{Benchmark II}
\label{sec:benchmark-ii}

<<benchmark II>>=
#include <iostream>
#include <fstream>
#include "ceo.h"
using namespace std;

int main(int argc,char *argv[]) {
  int N_GS, N_GS_max, nPx, k_nPx, k_GS, zern_j, zern_n, k;
  float elaspedTime;
  rtd D;
  vector src_origin, zern_origin, zern_euler_angles;
  ofstream f;
  float *zen, *azi;
  rtd *a;
  
  D = 25.5;
  src_origin.x =  0.0;
  src_origin.y =  0.0;
  src_origin.z = 25.0;

  nPx = 256;

  stopwatch tid;
  source src;
  zernikeS zern;
  gmt_m1 M1;
  gmt_m2 M2;

  f.open("bench_zernike.txt");
  f.precision(3);
  /* f << "nPx"; */
  /* for (k_GS=1;k_GS<=N_GS_max;k_GS++)  */
  /*   f << "\t" << k_GS << "GS"; */
  /* f << endl; */

  for (zern_n = 0;zern_n<11;zern_n++) {
    //    f << zern_n;
  zern_j = (zern_n+1)*(zern_n+2)/2;
    f << zern_j;
  a = (rtd *)malloc( sizeof(rtd)*zern_j );
  for (k=0;k<zern_j;k++)
    a[k] = 1e-7;
  zern_origin.x = zern_origin.y = zern_origin.z = 0.0;
  zern_euler_angles.x = zern_euler_angles.y = zern_euler_angles.z = 0.0;
  zern.setup(zern_n,a,zern_origin,zern_euler_angles,7);

  N_GS_max = 3;

  nPx = 469;
  N_GS = 1;

  zen = (float *) malloc( sizeof(float)*N_GS );
  azi = (float *) malloc( sizeof(float)*N_GS );
  for (k_GS=0;k_GS<N_GS;k_GS++) {
    zen[k_GS] = 6*60/RADIAN2ARCSEC;
    azi[k_GS] = 2*k_GS*PI/3;
  }    

  src.setup("R",zen,azi,INFINITY,N_GS,D,nPx,src_origin);
  M1.setup(D,nPx,&zern,0);
  M2.setup(D,nPx,&zern,0);

  for (int k=0;k<1;k++) {
  
    tid.tic();

  src.wavefront.reset();
  src.reset_rays();
  M2.blocking( &(src.rays) );
  M1.trace( &(src.rays) );
  M2.trace( &(src.rays) );
  src.rays.to_sphere(-5.830,2.197173);
  src.opd2phase();

  tid.toc(&elaspedTime);
  f << "\t" << elaspedTime;;
  
  }
  f << endl;;

  src.cleanup();
  M1.cleanup();
  M2.cleanup();
  zern.cleanup();

  }

  free(zen);
  free(azi);
  free(a);
 }
@ 
\subsection{Profile}
\label{sec:profile}

<<profile>>=
#include <cuda_profiler_api.h>
#include "ceo.h"
    /**
       /usr/local/cuda/bin/nvprof ./a.out
     */
int main(int argc,char *argv[]) {
  int N_GS, nPx, k, nIteration, zern_j, zern_n;
  rtd D;
  vector src_origin, zern_origin, zern_euler_angles;

  N_GS = 1;
  float zen[] = {0.0};
  float azi[] = {0.0};
  
  D = 25.5;
  src_origin.x =  0.0;
  src_origin.y =  0.0;
  src_origin.z = 25.0;

  nPx = 469;

  stopwatch tid;

  source src;
  src.setup("R",zen,azi,INFINITY,N_GS,D,nPx,src_origin);

  zernikeS zern;
  /* rtd a[] = {0.0}; */
  /* zern_origin.x = zern_origin.y = zern_origin.z = 0.0; */
  /* zern_euler_angles.x = zern_euler_angles.y = zern_euler_angles.z = 0.0; */
  /* zern.setup(0,a,zern_origin,zern_euler_angles,7); */
  zern_n = 6;
  zern_j = (zern_n+1)*(zern_n+2)/2;
  rtd *a;
  a = (rtd *)malloc( sizeof(rtd)*zern_j );
  for (k=0;k<zern_j;k++)
    a[k] = 1e-7;
  zern_origin.x = zern_origin.y = zern_origin.z = 0.0;
  zern_euler_angles.x = zern_euler_angles.y = zern_euler_angles.z = 0.0;
  zern.setup(zern_n,a,zern_origin,zern_euler_angles,7);

  gmt_m1 M1;
  M1.setup(D,nPx,&zern,N_GS);

  gmt_m2 M2;
  M2.setup(D,nPx,&zern,N_GS);

  src.wavefront.reset();
  src.reset_rays();
  //  M2.blocking( &(src.rays) );
  M1.trace( &(src.rays) );
  /* M2.trace( &(src.rays) ); */
  /* src.rays.to_sphere(-5.830,2.197173); */
  /* src.opd2phase(); */

  src.cleanup();
  zern.cleanup();
  M1.cleanup();
  M2.cleanup();
  free(a);
 }
