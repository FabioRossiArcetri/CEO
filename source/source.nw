% -*- mode: Noweb; noweb-code-mode: c-mode -*-

\index{source}
The source structure contains all the data associated with a remote optical emitter: its location, wavefront, irradiance, ...

\section{The files}

\subsection{Header}

<<source.h>>=
#ifndef __SOURCE_H__
#define __SOURCE_H__

#ifndef __UTILITIES_H__
#include "utilities.h"
#endif

#ifndef __PLOTLY_H__
#include "plotly.h"
#endif

<<ray data type>>

<<ray bundle structure>>

<<complex amplitude structure>>

struct source {

  <<source parameters>>

  void setup(const char *_photometric_band, 
	     float zenith, float azimuth, float height);
  void setup(const char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     int resolution);
  void setup(const char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     const char *tag_in);
  void setup(const char *_photometric_band, 
	     float zenith, float azimuth, float height, 
	     int resolution, const char *tag_in);
  void setup(const char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC);
  void setup(const char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC, int resolution);
  void setup(const char *_photometric_band, 
	     float *_zenith, float *_azimuth, float _height, 
	     int _N_SRC, rtd _L_, int _N_L_, vector origin);
  void cleanup(void);

  void reset_rays(void);

  void opd2phase(void);
   
  void info(void);

  void phase2file(const char *filename);

  float wavelength(void);
  float wavelength_micron(void);
  float spectral_bandwidth(void);
  float n_photon(void);
  float wavenumber(void);

  /*
  void transform_to_S(source *src, conic *F);
  void transform_to_S(source *src, aperture *A);
  void transform_to_R(source *src, conic *F);
  void transform_to_R(source *src, aperture *A);
  void intersect(source *src, conic *F);
  void reflect(source *src);
  */
};
#endif // __SOURCE_H__
@
\subsection{Source}

<<source.cu>>=
#include "source.h"

<<to z plane kernel>>
<<to sphere kernel>>
<<reference sphere origin from chief ray>>
<<ray bundle kernels>>
<<bundle reset kernel>>
<<ray bundle functions>>

<<square geometry>>
<<apply mask>>
<<piston removal>>

<<complex amplitude setup I>>
<<complex amplitude setup II>>
<<complex amplitude cleanup>>
<<resetting the wavefront>>
<<resetting the phase>>
<<resetting the wavefront to new wavefront>>
<<adding wavefront phase>>
<<masking wavefront amplitude I>>
<<masking wavefront amplitude II>>
<<wavefront stats>>

<<phase to file>>

<<bundle coordinates kernel>>
<<bundle coordinates kernel (box)>>
<<gathering wavefront kernel>>

<<setup>>
<<setup with wavefront resolution>>
<<setup with tag>>
<<setup with wavefront resolution and tag>>
<<setup for multiple sources>>
<<setup for multiple sources with wavefront resolution>>
<<setup for multiple sources with wavefront resolution and ray bundle>>
<<cleanup>>

<<reset rays>>
<<ray tracing>>

<<info>>

<<wavelength>>
<<spectral bandwidth>>
<<number of photons>>
<<wavenumber>>
<<plot phase>>
<<plot amplitude I>>
<<plot amplitude II>>
@ 
<<ray tracing code chunks>>=
<<transformation to surface system kernel>>
<<transformation to surface system>>
<<intersection with surface kernel>>
<<intersection with surface>>
<<reflection kernel>>
<<reflection>>

@
\subsection{Python}
\label{sec:python}

\index{source!python}

<<source.pxd>>=
from numpy cimport ndarray
from utilities cimport mask, cuFloatArray, cuDoubleArray, cuIntArray, MaskAbstract
cdef extern from "utilities.h":
    ctypedef double rtd
    ctypedef struct vector:
        rtd x
        rtd y
        rtd z
cdef extern from "source.h":
    ctypedef struct ray:
        vector coordinates
        vector directions
        vector surface_normal
        rtd optical_path_length
<<source.pxd contents>>
<<class definitions>>
@
\subsubsection{Ray bundle}
\label{sec:ray-bundle-1}

\index{source!python!Bundle}

<<source.pxd contents>>=
    cdef cppclass bundle:
        int N_RAY, N_BUNDLE
	int *d__piston_mask
        rtd *d__sphere_radius
        rtd *d__sphere_distance
        vector *d__sphere_origin
        ray *d__ray
	ray *d__chief_ray
        void setup(rtd, int, int , vector, int)
        void setup(rtd, int , vector, int)
        void cleanup()
        void to_z_plane(rtd)
        void to_sphere(vector)
        void to_sphere(rtd , rtd)
        void get_coordinates(double *)
        void get_chief_coordinates(double *)
        void get_directions(double *)
        void get_chief_directions(double *)
        void get_optical_path_length(double *)
        void get_chief_optical_path_length(double *)
        void get_optical_path_difference(double *)
        void get_optical_path_difference(double *,
					 float , int , 
					 float , int )
        void get_vignetting(double *)
	void get_n_iteration(int *)
@
<<class definitions>>=
# Bundle
cdef class Bundle:
    cdef bundle *_c_bundle
    cdef cuDoubleArray _coordinates_
    cdef cuDoubleArray _chief_coordinates_
    cdef cuDoubleArray _directions_
    cdef cuDoubleArray _chief_directions_
    cdef cuDoubleArray _optical_path_length_
    cdef cuDoubleArray _chief_optical_path_length_
    cdef cuDoubleArray _optical_path_difference_
    cdef cuDoubleArray _vignetting_
    cdef cuIntArray _n_iteration_
    cdef public cuDoubleArray sphere_radius
    cdef public cuDoubleArray sphere_distance
    cdef double[:,::1] _d__sphere_origin_
    cdef cuIntArray _piston_mask_
@ 
<<source.pyx>>=
# polar bundle
from scipy.optimize import brentq
from ceo.constants import ARCSEC2RAD
cdef class Bundle:
    """
    A class to represent a bundle of rays    

    This class is usually instanciated by the Source class

    Parameters
    ----------
    src : Source
        The Source object that contains the pointer to CEO bundle structure

    Attributes
    ----------
    N_BUNDLE : int, read only
        The number of ray bundle
    coordinates : cuDoubleArray, read only
        The coordinate vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_coordinates : cuDoubleArray, read only
        The coordinate vector of the chief ray
    directions : cuDoubleArray, read only
        The direction vectors of the rays as a (N_RAYxN_BUNDLE)x3 array
    chief_directions : cuDoubleArray, read only
        The direction vector of the chief ray
    optical_path_length : cuDoubleArray, read only
        The optical path lengths of the rays as a N_BUNDLExN_RAY array
    chief_optical_path_length : cuDoubleArray, read only
        The optical path length  of the chief ray
    optical_path_difference : cuDoubleArray, read only
        The optical path differences of the rays as a N_BUNDLExN_RAY array
    vignetting : cuDoubleArray, read only
        The vignetting flag of the rays as a N_BUNDLExN_RAY array
    sphere_radius : cuDoubleArray, read only
        The radius of the reference sphere used to compute the optical path difference
    sphere_distance : cuDoubleArray, read only
        The distance from the last surface to the reference sphere used to compute the optical path difference
    piston_mask : numpy ndarray
        A 7 columns array where each column is a mask corresponding to 1 segment
    """

    def __cinit__(self, Source src):
        self._c_bundle = new bundle()
        self._c_bundle = &(src._c_source.rays)

        self._coordinates_               = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_coordinates_         = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._directions_                = cuDoubleArray(
            shape=(self._c_bundle.N_RAY*self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._chief_directions_          = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,3),dev_malloc=True)
        self._optical_path_length_       = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._chief_optical_path_length_ = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=True)
        self._optical_path_difference_   = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._vignetting_                = cuDoubleArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)
        self._n_iteration_                = cuIntArray(
            shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY),dev_malloc=True)

        self.sphere_radius = cuDoubleArray( shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=False)
        self.sphere_radius._c_gpu.dev_data = self._c_bundle.d__sphere_radius
        self.sphere_distance = cuDoubleArray( shape=(self._c_bundle.N_BUNDLE,1),dev_malloc=False)
        self.sphere_distance._c_gpu.dev_data = self._c_bundle.d__sphere_distance

        self._piston_mask_ = cuIntArray(shape=(self._c_bundle.N_BUNDLE,self._c_bundle.N_RAY))
        self._piston_mask_._c_gpu.dev_data = self._c_bundle.d__piston_mask;

    <<bundle common>>
@ 
<<bundle common>>=
"""
def __dealloc__(self):
    self._c_bundle.cleanup()
"""

def to_z_plane(self,rtd z_plane):
    """
    Propagates the rays to a given plane

    Parameters
    ----------
    z_plane : double
        The z coordinates of the plane
    """
    self._c_bundle.to_z_plane(z_plane)

def to_sphere(self, sphere_origin=None,
              rtd focal_plane_distance=0.0, 
              rtd focal_plane_radius=0.0):
    """
    Computes the optical path difference with respect to the reference sphere

    Parameters
    ----------
    sphere_origin : list of double, optional
        A 3 elements list containing the x,y and z coordinates of the sphere center; default: None
    focal_plane_distance : double, optional
        The location of the focal plane on the optical axis; default: 0.0
    focal_plane_radius : double, optional
        The radius of curvature of the focal plane; default: 0.0

    """
    cdef vector origin
    if sphere_origin is not None:
        origin.x = <double>sphere_origin[0]
        origin.y = <double>sphere_origin[1]
        origin.z = <double>sphere_origin[2]
        self._c_bundle.to_sphere(origin)

    if focal_plane_distance!=0.0:
        self._c_bundle.to_sphere(focal_plane_distance, focal_plane_radius)

def to_focal_plane(self, rtd focal_plane_distance):
    self._c_bundle.to_z_plane(focal_plane_distance)

def get_optical_path_difference(self,
                                float delta_x, int N_x,
                                float delta_y, int N_y):
    opd = cuDoubleArray(shape=(N_x,N_y),dev_malloc=True)
    self._c_bundle.get_optical_path_difference(opd._c_gpu.dev_data,
                                               delta_x, N_x,
                                               delta_y, N_y)
    return opd

def ee80(self,spaxel="circle"):
    """
    Computes the size of the geometric EE80 square 

    Parameters
    ----------
    spaxel : char, optional
        The spaxel geometry, square or circle; default: circle

    Returns
    -------
    float
        The size of the geometric EE80 square in radian
    """
    assert(spaxel=="circle" or spaxel=="square","spaxel is either a circle or a square!")
    V = self.vignetting.host().flatten()==1
    xyz = self.coordinates.host()
    x = np.abs( xyz[V,0] )
    y = np.abs( xyz[V,1] )
    r = np.hypot(x,y)
    def ensquared(hd):
        idx = np.logical_and(x<=hd , y<=hd)
        return float(idx.sum())/V.sum()
    def encircled(hd):
        idx = r<=hd
        return float(idx.sum())/V.sum()
    if spaxel=="circle":
        f = lambda x: encircled(x)-0.8
	b = r.max()
    else:
        f = lambda x: ensquared(x)-0.8
	b = np.maximum(x.max(),y.max())
    try:
        return 2*brentq(f,0,b)*(ARCSEC2RAD/1e-3)
    except ValueError:
        return np.float('inf')


property N_BUNDLE:
    def __get__(self):
        return self._c_bundle.N_BUNDLE

property coordinates:
    def __get__(self):
        self._c_bundle.get_coordinates(self._coordinates_._c_gpu.dev_data)
        return self._coordinates_

property chief_coordinates:
    def __get__(self):
        self._c_bundle.get_chief_coordinates(self._chief_coordinates_._c_gpu.dev_data)
        return self._chief_coordinates_

property directions:
    def __get__(self):
        self._c_bundle.get_directions(self._directions_._c_gpu.dev_data)
        return self._directions_

property chief_directions:
    def __get__(self):
        self._c_bundle.get_chief_directions(self._chief_directions_._c_gpu.dev_data)
        return self._chief_directions_

property optical_path_length:
    def __get__(self):
        self._c_bundle.get_optical_path_length(self._optical_path_length_._c_gpu.dev_data)
        return self._optical_path_length_

property chief_optical_path_length:
    def __get__(self):
        self._c_bundle.get_chief_optical_path_length(self._chief_optical_path_length_._c_gpu.dev_data)
        return self._chief_optical_path_length_

property optical_path_difference:
    def __get__(self):
        self._c_bundle.get_optical_path_difference(self._optical_path_difference_._c_gpu.dev_data)
        return self._optical_path_difference_

property vignetting:
    def __get__(self):
        self._c_bundle.get_vignetting(self._vignetting_._c_gpu.dev_data)
        return self._vignetting_

property n_iteration:
    def __get__(self):
        self._c_bundle.get_n_iteration(self._n_iteration_._c_gpu.dev_data)
        return self._n_iteration_

property piston_mask:
    def __get__(self):
        P = self._piston_mask_.host()
        return [ np.array( [P[kk,:].flatten()==k for k in range(1,8)] ) for kk in range(self._piston_mask_.shape[0])]
@

\subsubsection{Complex amplitude}
\label{sec:complex-amplitude-1}

\index{source!python!Complex\_amplitude}
<<source.pxd contents>>=
    cdef cppclass complex_amplitude:
        int N
        int N_PX
        float *phase
        float *amplitude
        mask *M
        void reset()
        void reset_phase()
        void masked(mask *)
        void masked()
        void add_phase(float , float *)
        void rms(float *)
@
<<class definitions>>= 
cdef class Complex_amplitude:
    cdef:
        complex_amplitude *_c_complex_amplitude
        readonly cuFloatArray phase
        readonly cuFloatArray amplitude
@  
<<source.pyx>>=
import numpy as np
cimport cython

@cython.boundscheck(False)
@cython.wraparound(False)
cdef class Complex_amplitude:
    """
    A class to represent a wavefront complex amplitude

    Parameters
    ----------
    Source : Source
        a CEO Source object

    Attributes
    -----------
    phase : float
        The complex amplitude angle
    amplitude : float, read only
        the complex amplitude magnitude

    See also
    --------
    Source: a class for astronomical sources
    """
    def __cinit__(self,Source src=None):
        self._c_complex_amplitude = new complex_amplitude()
        if src is not None:
            self._c_complex_amplitude = &(src._c_source.wavefront)
            self.__alloc__()

    def __alloc__(self, tuple shape=None):
        if shape is None:
            shape = (self._c_complex_amplitude.N,
                     self._c_complex_amplitude.N_PX/\
                     self._c_complex_amplitude.N)
        self.phase = cuFloatArray(shape=shape)
        self.phase._c_gpu.dev_data = self._c_complex_amplitude.phase
        self.amplitude = cuFloatArray(shape=shape)
        self.amplitude._c_gpu.dev_data = self._c_complex_amplitude.amplitude


    def rms(self,int units_exponent=0):
        """
        Computes the rms of the wavefront phase

        Parameters
        ----------
        units_exponent: int, optional
            3 for km, 0 for meter, -2 for cm, -3 for mm, -6 for micron, -9 for nm, etc; default: 0

        Returns
        -------
        float
            the wavefront phase rms
        """
        cdef float[::1] rms = np.zeros(self._c_complex_amplitude.N, dtype=np.single)
        self._c_complex_amplitude.rms(&rms[0])
        return np.array(rms)*10**-units_exponent

    def reset(self, cuFloatArray phase = None):
        """
        Reset the wavefront amplitude to 1 and phase to 0 or to the given phase

        Parameters
        ----------
        phase : cuFloatArray, optional
            The GPU array the wavefront phase is reset to; default to None

        See also
        --------
        cuFloatArray : a class for GPU host and device float data 
        """
        self._c_complex_amplitude.reset()
        if phase is not None:
            self._c_complex_amplitude.add_phase(1,phase._c_gpu.dev_data)

    def reset_phase(self):
        self._c_complex_amplitude.reset_phase()
@
\subsubsection{Source}
\label{sec:source}

\index{source!python!Source}
<<source.pxd contents>>=
    cdef cppclass source:
        int N_SRC
        const char *photometric_band
        float fwhm, magnitude
        complex_amplitude wavefront
        bundle rays
        void setup(const char *,float , float , float )
	void setup(const char *,float , float , float , int )
        void setup(const char *,float *, float *, float , int , int )
        void setup(const char *,float *, float *, float , int , rtd, int, vector)
        void cleanup()
        void reset_rays()
        void opd2phase()
        void info()
        float n_photon()
        float wavelength()
        float spectral_bandwidth()
@
<<class definitions>>= 
cdef class Source:
    cdef:
        source *_c_source
        readonly int N_SRC
        readonly int n, m
        readonly int size
        readonly ndarray zenith, azimuth
        readonly float height
        readonly Bundle rays
        readonly Complex_amplitude wavefront
        readonly sphere_distance
@ 
<<source.pyx>>=
cdef class Source:
    """ 
    A class to represent an astronomical source

    Parameters
    ----------
    photometric_band : char
        The sources photometric band
    zenith : list, tuple or numpy array, optional
        The sources zenith angles [rd], defaults to 0.
    azimuth :  list, tuple or numpy array, optional
        The sources azimuth angles [rd], defaults to 0.
    height : float, optional
        The sources altitude [m], defaults to infinity.
    resolution : tuple
        A 2 element tuple with the sampling [n,m] in pixel of the source wavefront complex amplitude.
    fwhm : float, optional
        The fwhm of the source intensity distribution, defaults to None.
    rays_box_size : float, optional
        The size of the ray bundle [m], defaults to None.
    rays_box_sampling : int, optional
        The linear sampling of the ray bundle
    rays_origin : list, optional
         A 3 element list, with the first 2 being the (x,y) origin of the ray bundle and the 3rd the ray bundle starting z coordinates

    Attributes
    ----------
    n : int
        wavefront resolution
    m : int
        wavefront resolution
    size : int
        number of sources
    zenith : ndarray
        zenith angle
    azimuth : ndarray
        azimuth angle
    height : float
        source height
    ray : Bundle
        geometric ray bundle
    phase : cuFloatArray
        wavefront phase
    wavelength : float, read only
        the wavelength of the source
    spectral_bandwidth : float, read only
        the spectral bandwidth associated to the source
    nPhoton : float, read only
        number of photon [m^-2.s^-1]
    magnitude : float, write only
        star magnitude
    wavefront : Complex_amplitude
        the wavefront complex amplitude
    sphere_distance : float
        the distance to the reference sphere used to compute the OPD

    Examples
    --------
    >>> import math
    >>> import numpy as np
    >>> import ceo

    An on-axis source in K band is simply defined with:

    >>> src = Source("K")

    The resolution of the source wavefront is specifed with

    >>> n = 256
    >>> src = Source("K",resolution=(n,n))

    For a 20" off-axis and 10th magnitude source, zenith and azimuth are set with

    >>> src = Source("K",zenith=20*math.pi/180/3600,azimuth=math.pi/4,resolution=(n,n),magnitude=10)

    A Laser guide star constellation of 6 sources is defined with

    >>> zen = np.ones(6)*30*math.pi/180/3600,
    >>> azi = np.linspace(0,5,6)*2*math.pi/6
    >>> lgs = ceo.Source("R",zenith=zen,azimuth=azi,height=90e3,resolution=(n,n)) 

    If the source is to be used for ray tracing through an optical model like the GMT, then

    >>> lgs = ceo.Source("R",zenith=zen,azimuth=azi,height=90e3,
                        rays_box_size=25.5, rays_box_sampling=n, rays_origin=[0,0,25]) 

    """

    def __cinit__(self,char *_photometric_band,  
		  zenith=0, azimuth=0, 
                  magnitude=None,
		  height=float("inf"), 
		  resolution = (0,0),
		  fwhm = None,
                  rays_box_size=None, 
		  rays_box_sampling=None, 
		  rays_origin=None):

	self._c_source = new source()
        if rays_box_sampling is not None:
            resolution = [rays_box_sampling, rays_box_sampling]
        self.n = resolution[0]
        self.m = resolution[1]
        self.zenith  = np.array( zenith,  dtype=np.float32, ndmin=1)
        self.azimuth = np.array( azimuth, dtype=np.float32, ndmin=1)
        self.height  = float(height);
        self.size = self.zenith.size
        cdef vector _origin_
        if rays_box_size is None:
            self._c_source.setup(_photometric_band, 
                                 <float *>self.zenith.data, 
                                 <float *>self.azimuth.data, height, 
                                 self.size, np.prod(resolution))
        else:
            _origin_.x = <float>rays_origin[0]
            _origin_.y = <float>rays_origin[1]
            _origin_.z = <float>rays_origin[2]
            self._c_source.setup(_photometric_band, 
                                 <float *>self.zenith.data, 
                                 <float *>self.azimuth.data, height, 
                                 self.size, 
                                 rays_box_size, 
				 rays_box_sampling, 
				 _origin_)
        if magnitude is not None:
            self._c_source.magnitude = magnitude
        if fwhm is not None:
            self._c_source.fwhm = fwhm
        self.wavefront = Complex_amplitude(self)
        self.rays = Bundle(self)
        self.N_SRC = self._c_source.N_SRC
        self.sphere_distance = None

    def __dealloc__(self):
        self._c_source.cleanup()

    def opd2phase(self):
        """
        Transfer the OPD from ray tracing to the wavefront phase
        """
        self._c_source.opd2phase()                        

    property phase:
        def __get__(self):
            x = cuFloatArray(shape=(self.n*self.size,self.m))
            x._c_gpu.dev_data = self._c_source.wavefront.phase
            return x
        def __set__(self,cuFloatArray val):
            self._c_source.wavefront.add_phase(1,val._c_gpu.dev_data)

    property amplitude:
        def __get__(self):
            x = cuFloatArray(shape=(self.n*self.size,self.m))
            x._c_gpu.dev_data = self._c_source.wavefront.amplitude
            return x
    
    property wavelength:
        def __get__(self):
            return self._c_source.wavelength()
    
    property spectral_bandwidth:
        def __get__(self):
            return self._c_source.spectral_bandwidth()

    property nPhoton:
        def __get__(self):
            return self._c_source.n_photon()

    property magnitude:
        def __set__(self,value):
            self._c_source.magnitude = value
           
    def masked(self, MaskAbstract tel):
        """
        Apply the binary mask of the telescope pupil to the source wavefront

        Parameters
        ----------
        mask : Mask
            The binary mask structure
        """
        self._c_source.wavefront.masked(tel._c_mask)

    def masked(self):
        """
        Apply the binary mask of the telescope pupil to the source wavefront
        """    
        self._c_source.wavefront.masked()
    
    def reset(self):
        """
        Reset the wavefront amplitude to 1 and phase to 0 and re--initialize the ray bundle
        """
        self._c_source.wavefront.reset()
        self._c_source.reset_rays()
        
    def piston(self, where='pupil',int units_exponent=0):
        """
        Get the piston corresponding to either the pupil or the segments

        Parameters
        ----------
        where : string, optional
            Either "pupil" for a piston on the full pupil or "segments" for pistons of each segment; default: pupil
        units_exponent : int, optional
            Multiply the piston values by 10^-units_exponent; default: 0

        Returns
        -------
        ndarray of float
            The vector of piston values in meters as either an N_SRC vector for "pupil" or a N_SRCx7 array for "segments"

        Examples
        --------
        >>> import ceo
        >>> gs = ceo.Source("V",rays_box_size=25.5, rays_box_sampling=256, rays_origin=[0,0,25]) 
        >>> gmt = ceo.GMT_MX(25.5,256)
        >>> gmt.propagate(gs)
        
        The piston over the entire pupil is obtained with:
        
        >>> gs.piston(where="pupil")

        The 7 segment pistons are retrieved with

        >>> gs.piston(where="segments")

        See also
        --------
        GMT_MX : a class embedding GMT M1 and M2 classes 
        GMT_M1 : a class for GMT M1 model
        """
        assert where=="pupil" or where=="segments", "where parameter is either ""pupil"" or ""segments"""     
        cdef:
            int k
            tuple shape
            float[:,::1] amplitude, phase
        shape = (self.size,self.n*self.m)
        amplitude = self.wavefront.amplitude.host(shape=shape)
        phase     = self.wavefront.phase.host(shape=shape)
        if where=='pupil':
            return np.sum(phase,axis=1)/np.sum(amplitude,axis=1)*10**-units_exponent
        if where=='segments':
#            Q = mask*amplitude.T
#            return np.dot(Q,np.reshape( self.wavefront.phase.host() , (-1,) ) ).flatten()/np.sum(Q,axis=1)    
            ps = np.zeros((self.size,7),dtype=np.float32)
            for k in range(self.size):
                Q = self.rays.piston_mask[k]*amplitude[k,:]
                ps[k,:] = np.dot(Q,phase[k,:])/np.sum(Q,axis=1)
            return np.array(ps)*10**-units_exponent
        
    def phaseRms(self,where='pupil',int units_exponent=0):
        """
        Get the phase rms corresponding to either the pupil or the segments

        Parameters
        ----------
        where : string, optional
            Either "pupil" for a piston on the full pupil or "segments" for pistons of each segment; default: pupil
        units_exponent : int, optional
            Multiply the rms phase values by 10^-units_exponent; default: 0
        
        Returns
        -------
        ndarray of float
            The vector of phase rms values in meters as either an N_SRC vector for "pupil" or a N_SRCx7 array for "segments"
        """
        assert where=="pupil" or where=="segments", "where parameter is either ""pupil"" or ""segments"""     
        cdef:
            int k, s
            tuple shape
        shape = (self.size,self.n*self.m)
        phase     = self.wavefront.phase.host(shape=shape)
        if where=='pupil':
            return self.wavefront.rms(units_exponent)
        if where=='segments':
            rms = np.zeros((self.size,7),dtype=np.float32)
            for k in range(self.size):
                Q = self.rays.piston_mask[k]
                for s in range(7):
                    rms[k,s] = np.std(phase[k,Q[s,:]])      
        return np.array(rms)*10**-units_exponent
            
@
\subsubsection{Ray tracing routines}
\label{sec:ray-tracing-routines-1}

<<source.pxd (opt-out)>>=
    cdef void transform_to_S(source *, conic *)
    cdef void transform_to_S(source *, aperture *)
    cdef void transform_to_R(source *, conic *)
    cdef void transform_to_R(source *, aperture *)
    cdef void intersect(source *, conic *)
    cdef void reflect(source *)
    cdef void thin_lens(source *)
@ 
<<source.pyx (opt-out)>>=
# ray tracing
def Transform_to_S(Source src, Conic F):
    transform_to_S(src._c_source, F._c_conic)
def Transform_to_S_from_A(Source src, Aperture A):
    transform_to_S(src._c_source, A._c_aperture)
def Transform_to_R(Source src, Conic F):
    transform_to_R(src._c_source, F._c_conic)
def Transform_to_R_from_A(Source src, Aperture A):
    transform_to_R(src._c_source, A._c_aperture)
def Intersect(Source src, Conic F):
    intersect(src._c_source, F._c_conic)
def Reflect(Source src):
    reflect(src._c_source)
@

\section{Parameters}
\label{sec:params}

\index{source!source}
The source structure is a collection of [[N_SRC]] light sources.
<<source parameters>>=
int N_SRC;
@ 
The source locations are given by their [[zenith]] and [[azimuth]] angles, all the sources share the same height.
<<source parameters>>=
float zenith, azimuth, height, theta_x, theta_y;
@ The coordinates of the unit vector pointing towards the sources are given by [[theta_x]] and [[theta_y]].
The wavefront is the complex amplitude of the light beam.
It is given by its amplitude and phase, both are arrays of [[N_PX]] values.
The complex amplitude is defined in a new structure:
<<complex amplitude structure>>=
struct complex_amplitude {

  <<complex amplitude parameters>>

  void setup(int n_pixel);
  void setup(int n_pixel, int n_src);
  void cleanup(void);
  void reset(void);
  void reset_phase(void);
  void reset(complex_amplitude wavefront_prime);
  void add_phase(float alpha, float *phase_prime);
  void masked(void);
  void masked(mask *M_in);
  void rms(float *rms);
  void show_phase(char *filename);
  void show_phase(char *filename, int N_SRC);
  void show_amplitude(char *filename);
  void show_amplitude(char *filename, int N, int M);
};
@ with the parameters: 
<<complex amplitude parameters>>=
int N_PX, N;
float *amplitude, *phase;
@ The physical extent of the amplitude is set by the pupil mask:
<<complex amplitude parameters>>=
mask *M;
@ The magnitude at a given photometric band are set with:
<<source parameters>>=
const char *photometric_band;
float magnitude;
@ If the source is resolved by the  optical system, the irradiance is assumed to have a Gaussian shape of full width a half maximum [[fwhm]]
<<source parameters>>=
float fwhm;
@  The wavefront is added to the source
<<source parameters>>=
complex_amplitude wavefront;
@ Source structures will be allocated on the device:
<<source parameters>>=
source *dev_ptr;
@ and the source can be tagged with
<<source parameters>>=
char tag[8];
@ A source can also be propagated geometrically through optical components
<<source parameters>>=
char rays_exist;
bundle rays; 
@
\section{Functions}
\label{sec:functions}


\subsection{Ray}
\label{sec:ray}

\index{source!ray}

A type for the rays is also defined:
<<ray data type>>=
typedef struct {
  <<ray data>>
} ray;
@ 
It contains the ray coordinates:
<<ray data>>=
vector coordinates;
@ 
the direction cosines of the ray:
<<ray data>>=
vector directions;
@ 
the [[surface_normal]] at the surface it intersected with the last time:
<<ray data>>=
vector surface_normal;
@ 
the optical path length:
<<ray data>>=
rtd optical_path_length;
@ 
the optical path difference
<<ray data>>=
rtd optical_path_difference;
@ the vignetting flag [[v]], $[[v]]=0$ means the ray is vignetted:
<<ray data>>=
char v;
@ and the number of iterative steps for the Raphson--Newton method:
<<ray data>>=
int n_iteration;

@
\subsection{Ray bundle}
\label{sec:ray-bundle}

\index{source!bundle}

Collections of rays are gathered into bundles:
<<ray bundle structure>>=
struct bundle {
  <<ray bundle parameters>>
  void setup(rtd RADIUS, int N_RADIUS, int N_THETA, vector origin, int N_SRC);
  void setup(rtd L, int N_L, vector origin, int N_SRC);
  void cleanup(void);
  void to_z_plane(rtd z_in);
  void to_sphere(vector sphere_origin);
  void to_sphere(rtd z_chief_on_axis, rtd rho_focal_plane);
  void get_coordinates(double *d__coord);
  void get_chief_coordinates(double *d__coord);
  void get_directions(double *d__dir);
  void get_chief_directions(double *d__dir);
  void get_chief_optical_path_length(double *d__opl);
  void get_optical_path_length(double *d__opl);
  void get_optical_path_difference(double *d__opd);
  void get_optical_path_difference(double *d__opd,
				   float const delta_x, int N_x, 
				   float const delta_y, int N_y);
  void get_vignetting(double *d__v);
  void get_n_iteration(int *n_iteration);
};
@ 
A bundle allocates an array of [[N_RAY]] rays on the device
<<ray bundle parameters>>=
int N_RAY;
ray *d__ray;
@ 
The structure may contain several bundle of rays, each associated to a different source but with the same number of rays
<<ray bundle parameters>>=
int N_BUNDLE;
@
The x and y coordinates of the [[origin]] vector specifies the location of the center of the ray bundle when it crosses the (x,y) plane of the first surface.
The z coordinate specifies the height of the ray bundle with respect to the first surface.
<<ray bundle parameters>>=
vector *d__origin;
@ 
The chief ray is defined with
<<ray bundle parameters>>=
ray *d__chief_ray; 
vector *d__chief_origin;
@ 
The vignetting mask is defined with
<<ray bundle parameters>>=
mask V;
@
The ray geometry is defined either in polar coordinates (\textit{fan} mode)
<<ray bundle parameters>>=
char geom[8];
@ where the radius and azimuth angle are sampled with [[N_RADIUS]] and [[N_THETA]] rays,
<<ray bundle parameters>>=
int N_RADIUS, N_THETA;
@ 
or in cartesian coordinates (\textit{box} mode) where the rays sample a [[N_L]]$\times$[[N_L]] square
<<ray bundle parameters>>=
int N_L;
@
In \textit{fan} mode, the radius is saved in [[L]] and in \textit{box} mode the side of the box is saved in [[L]]:
<<ray bundle parameters>>=
rtd L;
@ 
The optical path difference is computed with respect to a reference sphere which is centered on the object in the image plane and which is tangent to the exit pupil.
<<ray bundle parameters>>=
rtd *d__sphere_distance, *d__sphere_radius;
vector *d__sphere_origin;
@ The GMT segment piston mask:
<<ray bundle parameters>>=
int *d__piston_mask;
@
\subsubsection{Setup \& Cleanup}
\label{sec:bundle-setup--cleanup}

A ray bundle is specified with either the polar or cartesian coordinates of the rays at a given origin.
The direction cosine are derived from the coordinates of a source object.

The polar coordinates are defined with the sampling of the radius [[N_RADIUS]] from 0 to [[RADIUS]] and with the sampling of the azimuth [[N_THETA]].
\index{source!bundle!setup}
<<ray bundle functions>>=
void bundle::setup(rtd RADIUS, int _N_RADIUS_, 
		   int _N_THETA_, vector origin, int N_SRC)
{
  strcpy(geom,"fan");
  N_RADIUS = _N_RADIUS_;
  N_THETA  = _N_THETA_;
  L        = RADIUS;
  N_BUNDLE = N_SRC;
  N_RAY = (N_RADIUS-1)*N_THETA + 1;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The polar coordinates $\rho$ and $\theta$ of the rays are given by
\begin{equation}
  \rho = [[RADIUS]] {k \over [[N_RADIUS]] - 1 } \forall k \in [0,[[N_RADIUS]] - 1]
\end{equation}
and
\begin{equation}
  \theta = 2\pi {k \over [[N_THETA]] } \forall k \in [0,[[N_THETA-1]]]
\end{equation}
<<bundle coordinates>>=
<<chief ray init>>
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_RADIUS/N_THREAD+1,N_THETA/N_THREAD+1, N_BUNDLE);
ray_coordinates LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                            L, N_RADIUS, N_THETA, d__origin);
@
The chief ray is defined with
<<chief ray allocation>>=
vector chief_origin;
chief_origin.x = 0.0;
chief_origin.y = 0.0;
chief_origin.z = origin.z;
HANDLE_ERROR( cudaMalloc((void**)&d__chief_ray, sizeof(ray)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__chief_origin, sizeof(vector) ) );
HANDLE_ERROR( cudaMemcpy( d__chief_origin, &chief_origin, 
                         sizeof(vector), cudaMemcpyHostToDevice ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_origin,   sizeof(vector)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_radius,   sizeof(rtd)*N_BUNDLE ) );
HANDLE_ERROR( cudaMalloc((void**)&d__sphere_distance, sizeof(rtd)*N_BUNDLE ) );
@
 and is initialized with
<<chief ray init>>= 
ray_coordinates LLL gridDim , blockDim RRR (d__chief_ray, 1, src->dev_ptr,
					    0.0, 2, 1, d__origin);

@
The cartesian coordinates are defined with the sampling of the square box length [[N_L]] from $-[[L]]$ to [[L]].
\index{source!bundle!setup}
<<ray bundle functions>>=
  void bundle::setup(rtd _L_, int _N_L_, vector origin, int N_SRC)
{
  strcpy(geom,"box");
  N_L = _N_L_;
  L = _L_;
  N_BUNDLE = N_SRC;
  N_RAY = N_L*N_L;
  V.setup(N_RAY*N_BUNDLE);
  HANDLE_ERROR( cudaMalloc((void**)&d__ray, sizeof(ray)*N_RAY*N_BUNDLE ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__origin, sizeof(vector) ) );
  HANDLE_ERROR( cudaMemcpy( d__origin, &origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  HANDLE_ERROR( cudaMalloc((void**)&d__piston_mask, sizeof(int)*N_RAY*N_BUNDLE ) );
  <<chief ray allocation>>
}
@ 
The direction cosines $(k,l,m)$ of the rays are defined from the source zenith $\zeta$ and azimuth $\xi$ angles as
\begin{eqnarray}
  \label{eq:2}
  k &=& \sin(\zeta)\cos(\xi) \\
  l &=& \sin(\zeta)\sin(\xi) \\
  k &=& \cos(\zeta)
\end{eqnarray}
The cartesian coordinates $x$ and $y$ of the rays are given by
\begin{eqnarray}
  x &=& L*(i-([[N_L]]-1)/2)/([[N_L]]-1) \\
  y &=& L*(j-([[N_L]]-1)/2)/([[N_L]]-1)
\end{eqnarray}
<<bundle coordinates (box)>>=
<<chief ray init>>
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_L/N_THREAD+1,N_L/N_THREAD+1, N_BUNDLE);
ray_coordinates_box LLL gridDim , blockDim RRR (d__ray, N_RAY, src->dev_ptr,
                                                            L, N_L, d__origin);
@
Memory is freed with
\index{source!bundle!cleanup}
<<ray bundle functions>>=
void bundle::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>bundle: freeing memory!\n");
  HANDLE_ERROR( cudaFree( d__ray ) );
  HANDLE_ERROR( cudaFree( d__chief_ray ) );
  HANDLE_ERROR( cudaFree( d__origin ) );
  HANDLE_ERROR( cudaFree( d__chief_origin ) );
  HANDLE_ERROR( cudaFree( d__piston_mask ) );
  HANDLE_ERROR( cudaFree( d__sphere_origin ) );
  HANDLE_ERROR( cudaFree( d__sphere_radius ) );
  HANDLE_ERROR( cudaFree( d__sphere_distance ) );
}
@

\subsubsection{Propagation parametric geometric equation}
\label{sec:prop-param-geom}

The rays are propagated to the plane $z=[[z__plane]]$ with
\begin{eqnarray}
  \label{eq:26}
  s &=& { [[z_plane]] - z \over m} \\\nonumber
  x &=& x + s k \\\nonumber
  y &=& y + s l \\\nonumber
  z &=& [[z_plane]]
\end{eqnarray}
\index{source!bundle!to\_z\_plane}
<<ray bundle functions>>= 
void bundle::to_z_plane(rtd z_plane)
{
  to_z_plane_chief_kernel LLL 1, 1, N_BUNDLE RRR (d__chief_ray, 1, z_plane);
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  to_z_plane_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, z_plane, d__chief_ray);
}
@ where
<<to z plane kernel>>=
  __global__ void to_z_plane_kernel(ray *d__ray, int N_RAY, rtd z_plane, ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    if (d__ray[k].directions.z==0)
       return;
    s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
    d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
    d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
    d__ray[k].coordinates.z = z_plane;
    d__ray[k].optical_path_length = s;
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray->optical_path_length;
  }
}
__global__ void to_z_plane_chief_kernel(ray *d__ray, int N_RAY, rtd z_plane)
{
  int k, iSource;
  rtd s;
  iSource = blockIdx.z;
  k = iSource;
  if (d__ray[k].directions.z==0)
    return;
  s = (z_plane - d__ray[k].coordinates.z)/d__ray[k].directions.z;
  d__ray[k].coordinates.x = d__ray[k].coordinates.x + s*d__ray[k].directions.x;
  d__ray[k].coordinates.y = d__ray[k].coordinates.y + s*d__ray[k].directions.y;
  d__ray[k].coordinates.z = z_plane;
  d__ray[k].optical_path_length = s;
}
@ 

\subsubsection{Reference sphere}
\label{sec:reference-sphere}

\paragraph{Spherical focal plane}
\label{sec:spher-focal-plane}

\index{source!bundle!to\_sphere}

<<ray bundle functions>>= 
void bundle::to_sphere(rtd z_chief_on_axis, rtd rho_focal_plane)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  <<reference sphere distance>>
  <<reference sphere origin>>
  <<reference sphere radius>>
  <<chief ray optical path length>>
  <<rays optical path difference>>
}
@
Given the $z$ location of the focal plane on axis [[z_chief_on_axis]] and the radius of curvature of the focal plane [[rho_focal_plane]], the distance to the object from the last surface for the chief ray is given by
<<reference sphere distance>>= 
to_focal_surface_chief_kernel LLL gridDim , blockDim RRR (d__sphere_distance, d__chief_ray, 1, 
                                                          z_chief_on_axis, 
							  rho_focal_plane);
@  with
<<to sphere kernel>>=
__global__ void to_focal_surface_chief_kernel(rtd *s, ray *d__ray, int N_RAY, 
                                              rtd z_chief_on_axis, rtd rho_focal_plane)
{
  int k, iSource;
  rtd x, y, z, g, rho2;
  iSource = blockIdx.z;
  k = iSource;
  x = d__ray[k].coordinates.x;
  y = d__ray[k].coordinates.y;
  z = d__ray[k].coordinates.z - z_chief_on_axis + rho_focal_plane;
  g = x*d__ray[k].directions.x + y*d__ray[k].directions.y + z*d__ray[k].directions.z;
  rho2 = x*x + y*y + z*z;
  s[k] = -1.0*sqrt( g*g - (rho2-rho_focal_plane*rho_focal_plane) ) - g;
}
@
The origin of the reference sphere is computed next 
<<reference sphere origin>>= 
chief_parametric_equation LLL gridDim , blockDim RRR (d__sphere_origin, 
						      d__chief_ray, 1, 
						      d__sphere_distance);
@ 
The chief ray defines the location of the object and the reference sphere is centered on the object e.g. the origin of the reference sphere is on the chief ray.
If the distance from the last surface to the object is known for the chief ray, then the origin of the reference sphere is given by:
<<reference sphere origin from chief ray>>=
__global__ void chief_parametric_equation(vector *d__v, ray *d__ray, int N_RAY, rtd *s)
{
  int k, iSource;
  iSource = blockIdx.z;
  k = iSource;
  d__v[k].x = d__ray[k].coordinates.x + d__ray[k].directions.x*s[k];
  d__v[k].y = d__ray[k].coordinates.y + d__ray[k].directions.y*s[k];
  d__v[k].z = d__ray[k].coordinates.z + d__ray[k].directions.z*s[k];
}
@ The computation of the radius of the reference sphere, which must be tangent to the exit pupil, is:
<<reference sphere radius>>= 
sphere_radius_kernel LLL gridDim , blockDim RRR (d__sphere_radius, d__chief_ray, 1, 
						 d__sphere_origin);
@ 
To compute the reference sphere radius, one must know the location of the exit pupil.
The location of the exit pupil is given by the intersection of the chief ray with the optical axis after the last surface of the system.
Remembering the rays parametric equation:
\begin{eqnarray}
  \label{eq:60}
  x &=& x_{-1} + k_{-1}s \\
  y &=& y_{-1} + l_{-1}s \\
  z &=& z_{-1} + m_{-1}s \\
\end{eqnarray}
and noting that, at the intersection $x=y=0$, the distance $s$ from the last surface to the exit pupil is given by
\begin{equation}
  \label{eq:61}
  s = \sqrt{  x_{-1}^2 + y_{-1}^2 \over k_{-1}^2 + l_{-1}^2 }
\end{equation}
Given the origin of the reference sphere $\left( x_{s,0},y_{s,0},z_{s,0} \right)$, the radius $\varrho_s$ is written
\begin{equation}
  \label{eq:62}
  \varrho_s = \sqrt{ x_{s,0}^2 + y_{s,0}^2 + \left( z_{s,0} - z_E \right) },
\end{equation}
where $z_E$ is the exit pupil coordinate on the z--axis,
\begin{equation}
  \label{eq:63}
  z_E = z_{-1} + m_{-1}s.
\end{equation}
In the case of an on--axis source, $k_{-1}=l_{-1}=0$ and $s=\infty$ so the radius is set to $\varrho_s=23.772110269559725$m.
<<to sphere kernel>>=
__global__ void sphere_radius_kernel(rtd *radius, ray *d__ray, int N_RAY, 
				     vector *sphere_origin)
{
  int k, iSource;
  rtd rho2_xy, rho2_kl, buf, s, z;
  iSource = blockIdx.z;
  k = iSource;

  buf =  d__ray[k].coordinates.x;
  buf *= buf;
  rho2_xy = buf;
  buf =  d__ray[k].coordinates.y;
  buf *= buf;
  rho2_xy += buf;

  buf =  d__ray[k].directions.x;
  buf *= buf;
  rho2_kl = buf;
  buf =  d__ray[k].directions.y;
  buf *= buf;
  rho2_kl += buf;
  
  if (rho2_kl<1E-24)
    radius[k] = 23.772110269559725;
  else {
    s = sqrt(rho2_xy/rho2_kl);
    z = d__ray[k].coordinates.z + d__ray[k].directions.z*s;

    buf = sphere_origin[k].x;
    buf *= buf;
    radius[k] = buf;

    buf = sphere_origin[k].y;
    buf *= buf;
    radius[k] += buf;

    buf = sphere_origin[k].z - z;
    buf *= buf;
    radius[k] += buf;
    radius[k] = sqrt( radius[k] );
  }
}
@ The optical path length of the chief ray from the last surface to the reference sphere is computed with
<<chief ray optical path length>>= 
to_sphere_chief_kernel LLL gridDim , blockDim RRR (d__chief_ray, 1, 
                                                   d__sphere_origin, d__sphere_radius);
@ with
<<to sphere kernel>>=
__global__ void to_sphere_chief_kernel(ray *d__ray, int N_RAY, 
                                       vector *sphere_origin, rtd *sphere_radius)
{
  int k, iSource;
  rtd s, x, y, z, g, rho2;
  iSource = blockIdx.z;
  k = iSource;
  <<to sphere kernel common>>
}
@
The optical path difference (OPD) is usually computed with respect to a reference sphere centered on the object.
The OPD is given by the difference between the rays optical path length (OPL) to the sphere and the OPL of the chief ray to the sphere.
The OPL $s$ is used to compute the intersection of a ray with the sphere from the parametric equation:
\begin{eqnarray}
  \label{eq:27}
  x &=& x_{-1} + s k_{-1} \\\nonumber
  y &=& y_{-1} + s l_{-1} \\\nonumber
  z &=& z_{-1} + s m_{-1} 
\end{eqnarray}
where $(x_{-1},y_{-1},z_{-1})$ and  $(k_{-1},l_{-1},m_{-1})$ are the coordinates at and direction cosines from the last surface.
Inserting $x$, $y$ and $z$ in the sphere equation,
\begin{equation}
  \label{eq:28}
  (x - x_O)^2 + (y-y_O)^2 + (z-z_O)^2 = R^2 
\end{equation}
where $(x_O,y_O,z_O)$ is the object coordinate and $R$ the sphere radius, and solving for $S$ lead to
\begin{equation}
  \label{eq:29}
  s = - \gamma - \sqrt{\gamma^2  - (\rho^2 - R^2)}
\end{equation}
with
\begin{equation}
  \label{eq:30}
  \gamma = (x_{-1} - x_O)k_{-1} + (y_{-1} - y_O)l_{-1} + (z_{-1} - z_O)m_{-1} 
\end{equation}
and
\begin{equation}
  \label{eq:31}
  \rho^2 = (x_{-1} - x_O)^2 + (y_{-1} - y_O)^2 + (z_{-1} - z_O)^2. 
\end{equation}
@ 
The code corresponding to the above equation is:
<<to sphere kernel common>>=
x = d__ray[k].coordinates.x - sphere_origin[iSource].x;
y = d__ray[k].coordinates.y - sphere_origin[iSource].y;
z = d__ray[k].coordinates.z - sphere_origin[iSource].z;
g = x*d__ray[k].directions.x + y*d__ray[k].directions.y + z*d__ray[k].directions.z;
rho2 = x*x + y*y + z*z;
s = -sqrt( g*g - (rho2-sphere_radius[iSource]*sphere_radius[iSource]) ) - g;
d__ray[k].optical_path_length = s;
d__ray[k].coordinates.x += s*d__ray[k].directions.x; 
d__ray[k].coordinates.y += s*d__ray[k].directions.y;
d__ray[k].coordinates.z += s*d__ray[k].directions.z;
@
The optical path difference of the source rays is computed last
<<rays optical path difference>>= 
blockDim = dim3(N_THREAD,N_THREAD);
gridDim  = dim3(N_RAY/N_THREAD2+1,1, N_BUNDLE);
to_sphere_kernel LLL gridDim , blockDim RRR (d__ray, N_RAY, 
                                             d__sphere_origin, d__sphere_radius, 
                                             d__chief_ray);
@ with
<<to sphere kernel>>=
__global__ void to_sphere_kernel(ray *d__ray, int N_RAY, 
				 vector *sphere_origin, rtd *sphere_radius,
				 ray *d__chief_ray)
{
  int i, j, k0, k, iSource;
  rtd s, x, y, z, g, rho2;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  k0 = k;
  k += iSource*N_RAY;
  if ( (k0<N_RAY ) && (d__ray[k].v) )
  {
    <<to sphere kernel common>>
    d__ray[k].optical_path_difference += 
      d__ray[k].optical_path_length - d__chief_ray[iSource].optical_path_length;
  }
}

@
\paragraph{Reference sphere origin}
\label{sec:refer-sphere-orig}

Given the origin and the radius of the reference sphere, the optical path difference is computed with
\index{source!bundle!to\_sphere}
<<ray bundle functions>>= 
void bundle::to_sphere(vector sphere_origin)
{
  HANDLE_ERROR( cudaMemcpy( d__sphere_origin, &sphere_origin, 
			    sizeof(vector), cudaMemcpyHostToDevice ) );
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  <<reference sphere radius>>
  <<chief ray optical path length>>
  <<rays optical path difference>>
}
@ 
<<ray bundle functions (opt-out)>>= 
void bundle::to_sphere(rtd *s, rtd sphere_radius)
{
  <<ray bundle functions: from distance>>
}
@  

\subsubsection{Gathering data}
\label{sec:gathering-data}

The coordinates, directions, optical path length and vignetting map are copied into arrays with the following functions:
<<ray bundle functions>>= 
<<gathering ray coordinates>>
<<gathering ray directions>>
<<gathering ray optical path length>>
<<gathering ray optical path difference>>
<<gathering ray vignetting map>>
<<gathering ray number of iterative steps>>
<<OPD nearest neighbor interpolation>>
@ 
<<ray bundle kernels>>= 
<<gathering ray coordinates kernel>>
<<gathering ray directions kernel>>
<<gathering ray optical path length kernel>>
<<gathering ray optical path difference kernel>>
<<gathering ray vignetting map kernel>>
<<gathering ray number of iterative steps kernel>>
<<OPD nearest neighbor interpolation kernel>>
@ 
\index{source!bundle!get\_coordinates}
<<gathering ray coordinates>>=
void bundle::get_coordinates(double *d__coord)
{
  HANDLE_ERROR( cudaMemset( d__coord, 0, sizeof(double)*N_RAY*3 ) );  
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim , blockDim RRR (d__coord, d__ray, N_RAY);
}
@ 
\index{source!bundle!get\_chief\_coordinates}
<<gathering ray coordinates>>=
void bundle::get_chief_coordinates(double *d__coord)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  get_coordinates_kernel LLL gridDim, blockDim RRR (d__coord, d__chief_ray, 1);
}
@ 
<<gathering ray coordinates kernel>>=
__global__ void get_coordinates_kernel(double *d__coord, ray *d__ray, int N_RAY)
{
  int i, j, k0, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  k0 = k;
  k += iSource*N_RAY;
  if ( ( k0<N_RAY ) && (d__ray[k].v==1) )
  {
    l = k*3;
    d__coord[l++] = d__ray[k].coordinates.x;
    d__coord[l++] = d__ray[k].coordinates.y;
    d__coord[l]   = d__ray[k].coordinates.z;
  }
}
@ 
\index{source!bundle!get\_directions}
<<gathering ray directions>>=
void bundle::get_directions(double *d__dir)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__ray, N_RAY);
}
@ 
\index{source!bundle!get\_chief\_directions}
<<gathering ray directions>>=
void bundle::get_chief_directions(double *d__dir)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_directions_kernel LLL gridDim , blockDim RRR (d__dir, d__chief_ray, 1);
}
@ 
<<gathering ray directions kernel>>=
__global__ void get_directions_kernel(double *d__dir, ray *d__ray, int N_RAY)
{
  int i, j, k, l, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
  {
    k += iSource*N_RAY;
    l = k*3;
    d__dir[l++] = d__ray[k].directions.x;
    d__dir[l++] = d__ray[k].directions.y;
    d__dir[l]   = d__ray[k].directions.z;
  }
}
@ 
\index{source!bundle!get\_optical\_path\_length}
<<gathering ray optical path length>>=
void bundle::get_optical_path_length(double *d__opl)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__ray, N_RAY);
}
@ 
\index{source!bundle!get\_chief\_optical\_path\_length}
<<gathering ray optical path length>>=
void bundle::get_chief_optical_path_length(double *d__opl)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1,N_BUNDLE);
  get_optical_path_length_kernel LLL gridDim , blockDim RRR (d__opl, d__chief_ray, 1);
}
@ 
<<gathering ray optical path length kernel>>=
__global__ void get_optical_path_length_kernel(double *d__opl, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    {
      k += iSource*N_RAY;
      d__opl[k]   = d__ray[k].optical_path_length;
    }
}
@ 
\index{source!bundle!get\_optical\_path\_difference}
<<gathering ray optical path difference>>=
void bundle::get_optical_path_difference(double *d__opd)
{
  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_RAY*N_BUNDLE ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_optical_path_difference_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY);
}
@ 
<<gathering ray optical path difference kernel>>=
__global__ void get_optical_path_difference_kernel(double *d__opd, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = k;
  k += iSource*N_RAY;
  if ( (j<N_RAY) && (d__ray[k].v) )
    {
      d__opd[k]   = d__ray[k].optical_path_difference;
    }
}
@ 
\index{source!bundle!get\_n\_iteration}
<<gathering ray number of iterative steps>>=
void bundle::get_n_iteration(int *n_iteration)
{
  HANDLE_ERROR( cudaMemset(n_iteration, 0, sizeof(int)*N_RAY*N_BUNDLE ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_n_iteration_kernel LLL gridDim , blockDim RRR (n_iteration, d__ray, N_RAY);
}
@ 
<<gathering ray number of iterative steps kernel>>=
__global__ void get_n_iteration_kernel(int *n_iteration, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = k;
  k += iSource*N_RAY;
  if ( (j<N_RAY) && (d__ray[k].v) )
    {
      n_iteration[k]   = d__ray[k].n_iteration;
    }
}
@ 
The OPD is interpolated on a $N_x\times N_y$ grid with respective sampling $\delta_x$ and $\delta_y$.
The $x_i$ and $y_i$ interpolation coordinates are written:
\begin{eqnarray}
  \label{eq:32}
  x_i &=& \delta_x(i -(N_x-1)/2),\quad \forall 0\leq i \leq N_x-1 \\\nonumber
  y_i &=& \delta_y(j -(N_y-1)/2),\quad \forall 0\leq j \leq N_y-1 
\end{eqnarray}
The coordinates are re--centered with respect to the original coordinate grid
\begin{eqnarray} 
  \label{eq:33}
  x_i &\rightarrow& x_i + L/2 \\\nonumber
  y_i &\rightarrow& y_i + L/2
\end{eqnarray}
and scale to that grid
\begin{eqnarray}
  \label{eq:34}
  x_i &\rightarrow& x_i{N_L-1 \over L} \\\nonumber
  y_i &\rightarrow& y_i{N_L-1 \over L}
\end{eqnarray}
<<OPD nearest neighbor interpolation>>=
void bundle::get_optical_path_difference(double *d__opd,
					 float const delta_x, int N_x, 
					 float const delta_y, int N_y)
{
  /* cublasHandle_t handle; */
  /* cublasStatus_t status; */
  /* double *d__coord; */
  /* int N, idx; */

  /* cublasCreate(&handle); */

  /* N = N_RAY*3; */
  /* HANDLE_ERROR( cudaMalloc((void**)&d__coord, sizeof(double)*N ) ); */
  /* get_coordinates(d__coord); */

  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord, 3, &idx) ); */
  /* printf("x max idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamin(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y min idx = %d\n",idx); */
  /* CUBLAS_ERROR( cublasIdamax(handle, N_RAY, d__coord+1, 3, &idx) ); */
  /* printf("y max idx = %d\n",idx); */

  HANDLE_ERROR( cudaMemset(d__opd, 0, sizeof(double)*N_x*N_y ) );
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1);
  get_optical_path_difference_interp_kernel LLL gridDim , blockDim RRR (d__opd, d__ray, N_RAY,
  									delta_x, N_x,
  									delta_y, N_y,
  									L, N_L);
  /* cublasDestroy(handle); */
  /* HANDLE_ERROR( cudaFree( d__coord) ); */
}
@ with
<<OPD nearest neighbor interpolation kernel>>=
__global__ void get_optical_path_difference_interp_kernel(double *d__opd,
                                                     ray* d__ray, int N_RAY,
						     float const delta_x, int N_x, 
						     float const delta_y, int N_y,
						     float const L, int const N_L)
{
  /*
  int i, j, k, kl;
  float x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) roundf( x );
      j = (int) roundf( y );
      kl = i + N_x*j;
      if ( (i<0) || (i>=N_x) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      if ( (j<0) || (j>=N_y) )
	{
	  d__opd[kl] = 0;
	  return;
	}  
      d__opd[k] = d__ray[k].optical_path_difference;
    }
  */
  int i, j, k, l;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( (k<N_RAY) && (d__ray[k].v) )
    {
      x = d__ray[k].coordinates.x;
      y = d__ray[k].coordinates.y;
      x /= delta_x;
      y /= delta_y;
      x += (N_x - 1)*0.5;
      y += (N_y - 1)*0.5;
      i = (int) rint( x );
      j = (int) rint( y );
      l = i + N_x*j;
      if ( ( (i>=0) && (i<N_x) ) && ( (i>=0) && (i<N_y) ) )
	d__opd[l]   = d__ray[k].optical_path_difference;
    }
}
@ 
\index{source!bundle!get\_vignetting}
<<gathering ray vignetting map>>=
void bundle::get_vignetting(double *d__v)
{
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1,N_BUNDLE);
  get_vignetting_kernel LLL gridDim , blockDim RRR (d__v, d__ray, N_RAY);
}
@ 
<<gathering ray vignetting map kernel>>=
  __global__ void get_vignetting_kernel(double *d__v, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    d__v[k]   = (d__ray[k].v==1) ? 1.0 : 0.0;
}
@ 
<<gathering wavefront>>=
void bundle::get_wavefront(source *src)
{
//  printf("Setting wavefront!\n");
  dim3 blockDim(N_THREAD,N_THREAD);
  dim3 gridDim(N_RAY/N_THREAD2+1,1, N_BUNDLE);
  get_wavefront_kernel LLL gridDim , blockDim RRR (src->wavefront.amplitude, 
                                                   src->wavefront.phase,
						   V.m,
                                                   d__ray, N_RAY);
  V.set_filter();
  src->wavefront.masked(&V);
}
@ 
<<gathering wavefront kernel>>=
__global__ void get_wavefront_kernel(float *amplitude, float *phase,
                                     char *m, ray *d__ray, int N_RAY)
{
  int i, j, k, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    k += iSource*N_RAY;
    if (d__ray[k].v==1)
      {
	m[k]         = 1;
	amplitude[k] = 1.0;
	phase[k]     = d__ray[k].optical_path_difference;
      } else {
	m[k]         = 0;
	amplitude[k] = 0.0;
	phase[k]     = 0.0;
    }
}
@ 

\subsubsection{Resetting}
\label{sec:resetting}

The ray vignetting is reset with
\index{source!bundle!reset}
<<ray bundle functions (opt-out)>>= 
void bundle::reset(source *src) 
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, N_BUNDLE);
  if (strcmp(geom,"box")==0)
     <<bundle coordinates (box)>>
  if (strcmp(geom,"fan")==0)
     <<bundle coordinates>>
}
@ with 
<<bundle reset kernel>>=
__global__ void reset_kernel(ray *d__ray, int N_RAY)
{
  int i, j, k;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  k = j * gridDim.x * blockDim.x + i;
  if ( k<N_RAY )
    d__ray[k].v = 0;
}
@

\subsection{source}
\label{sec:source-1}

\subsubsection{Setup \& cleanup}
\label{sec:setup--cleanup}

\index{source!source!setup}

Sources are initialized with the setup function:
\begin{itemize}
\item for a single source:
<<setup>>=
void source::setup(const char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height) {
  <<setup single source contents>>
  wavefront.setup(0);
  strcpy(tag,"source");
  info();
}
@ \item for a single source with wavefront resolution:
<<setup with wavefront resolution>>=
void source::setup(const char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height, int resolution) {
  <<setup single source contents>>
  wavefront.setup(resolution);
  strcpy(tag,"source");
  info();
}
@ \item for a single source with tag:
<<setup with tag>>=
void source::setup(const char *_photometric_band, 
		   float _zenith, float _azimuth, 
		   float _height, const char *tag_in) {
  <<setup single source contents>>
  wavefront.setup(0);
  strcpy(tag,tag_in);
  info();
}
@ \item for a single source with wavefront resolution and tag:
<<setup with wavefront resolution and tag>>=
void source::setup(const char *_photometric_band, 
		   float _zenith, float _azimuth, float _height, 
		   int resolution, const char *tag_in) {
  <<setup single source contents>>
  wavefront.setup(resolution);
  strcpy(tag,tag_in);
  info();
}
@ with
<<setup single source contents>>=
rays_exist = 0;
N_SRC   = 1;
zenith  = _zenith;
azimuth = _azimuth;
height  = _height;
theta_x = tanf(zenith)*cosf(azimuth);
theta_y = tanf(zenith)*sinf(azimuth);
photometric_band = _photometric_band;
magnitude = 0.0;
fwhm = 0.0;
source __src;
__src.zenith  = zenith;
__src.azimuth = azimuth;
__src.height  = height;
__src.theta_x = theta_x;
__src.theta_y = theta_y;
HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source) ) );
HANDLE_ERROR( cudaMemcpy( dev_ptr, &__src,
                          sizeof(source) ,
                          cudaMemcpyHostToDevice ) );

@ \item for multiple sources:
<<setup for multiple sources>>=
void source::setup(const char *_photometric_band, 
		   float *_zenith, float *_azimuth, 
		   float _height, int _N_SRC) {
  rays_exist = 0;
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength_micron(),magnitude);
  }
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
  wavefront.setup(0);
}
@  \item for multiple sources with wavefront resolution:
<<setup for multiple sources with wavefront resolution>>=
void source::setup(const char *_photometric_band, 
		   float *_zenith, float *_azimuth, float _height, 
		   int _N_SRC, int resolution) {
  rays_exist = 0;
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength_micron(),magnitude);
  }
  wavefront.setup(resolution,N_SRC);
  fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@  \item for multiple sources with wavefront resolution and with ray bundle:
<<setup for multiple sources with wavefront resolution and ray bundle>>=
void source::setup(const char *_photometric_band, 
		   float *_zenith, float *_azimuth, float _height, 
		   int _N_SRC, rtd L, int N_L, vector origin) {
  N_SRC = _N_SRC;
  height = _height;
  photometric_band = _photometric_band;
  magnitude = 0.0;
  fwhm = 0.0;
  source __src;
  HANDLE_ERROR( cudaMalloc( (void**)&dev_ptr, sizeof(source)*N_SRC ) );
  strcpy(tag,"sources");
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  for (int i_SRC=0;i_SRC<N_SRC;i_SRC++) {
    __src.zenith  = _zenith[i_SRC];
    __src.azimuth = _azimuth[i_SRC];
    __src.height  = _height;
    __src.theta_x = tanf(_zenith[i_SRC])*cosf(_azimuth[i_SRC]);
    __src.theta_y = tanf(_zenith[i_SRC])*sinf(_azimuth[i_SRC]);
    HANDLE_ERROR( cudaMemcpy( dev_ptr + i_SRC, &__src,
			      sizeof(source) ,
			      cudaMemcpyHostToDevice ) );
    fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	    _zenith[i_SRC]*RADIAN2ARCSEC,
	    _azimuth[i_SRC]*180/PI,_height,
	    wavelength_micron(),magnitude);
  }
  wavefront.setup(N_L*N_L,N_SRC);
  fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  rays_exist = 1;
  rays.setup(L, N_L, origin, N_SRC);
  reset_rays();
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}
@ with \index{source!source!reset\_rays}
<<reset rays>>=
void source::reset_rays(void)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1, rays.N_BUNDLE);
  ray_coordinates LLL gridDim , blockDim RRR (rays.d__chief_ray, 1, 
                                              dev_ptr,
                                              0.0, 2, 1, rays.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(rays.N_L/16+1,rays.N_L/16+1, rays.N_BUNDLE);
  ray_coordinates_box LLL gridDim , blockDim RRR (rays.d__ray, rays.N_RAY, 
                                                  dev_ptr,
                                                  rays.L, rays.N_L, 
                                                  rays.d__origin);    
  blockDim = dim3(256);
  gridDim  = dim3(rays.V.nel/256+1);
  fill_ones_char LLL gridDim,blockDim RRR (rays.V.m,rays.V.nel);  
  rays.V.set_filter_quiet();
}
@ and
<<bundle coordinates kernel>>=
__global__ void ray_coordinates(ray *d__ray, int N_RAY, source *src,
                                rtd RADIUS, int N_RADIUS, int N_THETA, 
                                vector *origin)
{
  int i, j, k, iSource;
  rtd rho, theta, s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  //k = j * gridDim.x * blockDim.x + i;
  if ( (i<N_RADIUS) && (j<N_THETA) )
  {
    rho   = RADIUS*i/(N_RADIUS-1);
    if (i==0) {
      j = 0;
      k = 0;
    } else
      k = j + (i - 1)*N_THETA + 1;
    k += iSource*N_RAY;
    theta = 2*PI*j/N_THETA; 
    d__ray[k].coordinates.x = rho*cos(theta) + origin->x; 
    d__ray[k].coordinates.y = rho*sin(theta) + origin->y; 
    <<bundle coordinates kernel (common)>>
  }
}
@ where
<<bundle coordinates kernel (common)>>=
d__ray[k].coordinates.z = origin->z;
d__ray[k].directions.x  = sin(src[iSource].zenith)*cos(src[iSource].azimuth);
d__ray[k].directions.y  = sin(src[iSource].zenith)*sin(src[iSource].azimuth);
d__ray[k].directions.z  = -cos(src[iSource].zenith);
d__ray[k].optical_path_length = 0.0;
d__ray[k].optical_path_difference = 0.0;
s = -origin->z/d__ray[k].directions.z;
d__ray[k].coordinates.x -= s*d__ray[k].directions.x;
d__ray[k].coordinates.y -= s*d__ray[k].directions.y;
d__ray[k].v = 1;
@ and
<<bundle coordinates kernel (box)>>=
__global__ void ray_coordinates_box(ray *d__ray, int N_RAY, source *src,
                                    rtd L, int N_L, vector *origin)
{
  int i, j, k, iSource;
  rtd x, y, s;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) )
  {
    <<rays box coordinates definition>>
    k = i + j*N_L + iSource*N_RAY;
    d__ray[k].coordinates.x = x + origin->x; 
    d__ray[k].coordinates.y = y + origin->y; 
    <<bundle coordinates kernel (common)>>
  }
}
@ with
<<rays box coordinates definition>>=
x   = L*(i - (N_L-1)*0.5)/(N_L-1);
y   = L*(j - (N_L-1)*0.5)/(N_L-1);
@ \end{itemize}
\subsubsection{Photometry}
\label{sec:photometry}

The [[wavelength]] in meter corresponding to the photometric band is given by
\index{source!source!wavelength}
<<wavelength>>=
float source::wavelength(void) {
  float lambda;
  if (strcmp(photometric_band,"V")==0)
    lambda = 0.550;
  if (strcmp(photometric_band,"R")==0)
    lambda = 0.640;
  if (strcmp(photometric_band,"I")==0)
    lambda = 0.790;
  if (strcmp(photometric_band,"J")==0)
    lambda = 1.215;
  if (strcmp(photometric_band,"H")==0)
    lambda = 1.654;
  if (strcmp(photometric_band,"K")==0)
    lambda = 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    lambda = 2.157;
  return 1E-6*lambda;
}
@ 
The [[wavelength]] in \textsl{micron}  is given by
\index{source!source!wavelength\_micron}
<<wavelength>>=
float source::wavelength_micron(void) {
  return 1E6*wavelength();
}
@ The number of photon in $m^{-2}.s^{-1}$ is derived with
\index{source!source!n\_photon}
<<number of photons>>=
float source::n_photon(void) {
  float zero_point;
  if (strcmp(photometric_band,"V")==0)
    zero_point = 8.97e9;
  if (strcmp(photometric_band,"R")==0)
    zero_point = 10.87e9 ;
  if (strcmp(photometric_band,"I")==0)
    zero_point = 7.34e9;
  if (strcmp(photometric_band,"J")==0)
    zero_point = 5.16e9;
  if (strcmp(photometric_band,"H")==0)
    zero_point = 2.99e9;
  if (strcmp(photometric_band,"K")==0)
    zero_point = 1.90e9;
  if (strcmp(photometric_band,"Ks")==0)
    zero_point = 1.49e19;
  return N_SRC*zero_point*powf(10 , -0.4*magnitude );
}
@ The spectral bandwidth is derived with
\index{source!source!spectral\_bandwidth}
<<spectral bandwidth>>=
float source::spectral_bandwidth(void) {
  float spectral_bandwidth;
  if (strcmp(photometric_band,"V")==0)
    spectral_bandwidth = 0.090;
  if (strcmp(photometric_band,"R")==0)
    spectral_bandwidth = 0.150;
  if (strcmp(photometric_band,"I")==0)
    spectral_bandwidth = 0.150;
  if (strcmp(photometric_band,"J")==0)
    spectral_bandwidth = 0.260;
  if (strcmp(photometric_band,"H")==0)
    spectral_bandwidth = 0.290;
  if (strcmp(photometric_band,"K")==0)
    spectral_bandwidth = 0.410;
  if (strcmp(photometric_band,"Ks")==0)
    spectral_bandwidth = 0.320;
  return spectral_bandwidth*1e-6;
}
@ The wave number is given by
\index{source!source!wavenumber}
<<wavenumber>>=
float source::wavenumber(void) {
  float lambda;
  if (strcmp(photometric_band,"V")==0)
    lambda = 0.550;
  if (strcmp(photometric_band,"R")==0)
    lambda = 0.640;
  if (strcmp(photometric_band,"I")==0)
    lambda = 0.790;
  if (strcmp(photometric_band,"J")==0)
    lambda = 1.215;
  if (strcmp(photometric_band,"H")==0)
    lambda = 1.654;
  if (strcmp(photometric_band,"K")==0)
    lambda = 2.179;
  if (strcmp(photometric_band,"Ks")==0)
    lambda = 2.157;
  return 1E6*2*PI/lambda;
}
@
\subsubsection{Trace}
\label{sec:trace}

The ray tracing data are transferred to the wavefront structure with
\index{source!source!opd2phase}
<<ray tracing>>=
void source::opd2phase(void)
{
//  printf("Setting wavefront!\n");
  HANDLE_ERROR( cudaMemset(rays.V.m, 0, sizeof(char)*rays.N_RAY*rays.N_BUNDLE ) ); 
  dim3 blockDim(16,16);
  dim3 gridDim(rays.N_L/16+1, rays.N_L/16+1, rays.N_BUNDLE);
  opd2phase_kernel LLL gridDim , blockDim RRR (wavefront.amplitude, 
                                                   wavefront.phase,
						   rays.V.m,
                                                   rays.d__ray, rays.N_RAY,
                                                   rays.L, rays.N_L,
                                                   dev_ptr);
  wavefront.masked(&(rays.V));
  rays.V.set_filter_quiet();
  /* wavefront.M = &(rays.V); */
}
@ 
<<gathering wavefront kernel>>=
__global__ void opd2phase_kernel(float *amplitude, float *phase,
				 char *m, ray *d__ray,  int N_RAY,
				 rtd L,  int N_L,
				 source *src)
{
  int i, j, k, iSource;
  rtd x, y;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  k = i + j*N_L + iSource*N_RAY;
  if ( ( (i<N_L) && (j<N_L) ) &&  (d__ray[k].v==1) ) {
    <<rays box coordinates definition>>
    m[k]         = 1;
    phase[k]     += d__ray[k].optical_path_difference +
      x*src[iSource].theta_x +
      y*src[iSource].theta_y;
  }
}
@ 
\subsubsection{Input/Output}
\label{sec:inputoutput}

The main parameters of the source are displayed with the [[info]] routine:
\index{source!source!info}
<<info>>=
void source::info(void)
{
  fprintf(stdout,"\n\x1B[1;42m@(CEO)>%s:\x1B[;42m\n",tag);
  fprintf(stdout," zen[arcsec] azim[deg]  height[m]  lambda[micron] magnitude\n");
  fprintf(stdout," %5.2f      %6.2f    %8.2f       %5.3f    %4.1f\n",
	  zenith*RADIAN2ARCSEC,
	  azimuth*180.0/PI,height,wavelength_micron(),
	  magnitude);
  if (wavefront.N_PX>0)
    fprintf(stdout," wavefront pixel sampling: %d\n",wavefront.N_PX);
  fprintf(stdout,"----------------------------------------------------\x1B[0m\n");
}

@ 
\subsection{Complex amplitude}
\label{sec:complex-amplitude}

\index{source!complex\_amplitude}

The complex amplitude structure is initialized with
\index{source!complex\_amplitude!setup}
<<complex amplitude setup I>>=
void complex_amplitude::setup(int n_pixel) {
  N = 1;
  <<complex amplitude setup common>>
}
<<complex amplitude setup II>>=
void complex_amplitude::setup(int n_pixel, int n_src) {
  N = n_src;
  <<complex amplitude setup common>>
}
<<complex amplitude setup common>>=
N_PX = n_pixel*N;
M = NULL;
if (N_PX>0) {
  HANDLE_ERROR( cudaMalloc( (void**)&amplitude,  sizeof(float)*N_PX ) );
  HANDLE_ERROR( cudaMalloc( (void**)&phase,      sizeof(float)*N_PX ) );
  reset();
} else {
  amplitude  = NULL;
  phase      = NULL;
}

@ and memory is de--allocated with:
\index{source!complex\_amplitude!cleanup}
<<complex amplitude cleanup>>=
void complex_amplitude::cleanup(void) {
  if (amplitude!=NULL)          
    HANDLE_ERROR( cudaFree( amplitude ) );
  if (phase!=NULL)
    HANDLE_ERROR( cudaFree( phase ) );
}
@ Allocated variable are freed with the [[cleanup]] routine
\index{source!source!cleanup}
<<cleanup>>=
void source::cleanup(void) {
  fprintf(stdout,"@(CEO)>%s: freeing memory!\n",tag);
//  fprintf(stdout," |-");
  wavefront.cleanup();
  if (rays_exist==1) {
    fprintf(stdout," |-");
    rays.cleanup();
  }
  HANDLE_ERROR( cudaFree( dev_ptr) );
}

@ 
The amplitude and phase are initialized to respectively 1 and 0:
<<square geometry>>=
__global__ void squarePupil(float* amplitude, float *phase, const int N) {
  int id;
  id = blockIdx.x * blockDim.x + threadIdx.x;
  if (id<N) {
    amplitude[id] = 1.0;
    phase[id]     = 0.0;
  }
}

@

\subsubsection{Wavefront manipulation}
\label{sec:wavefr-manip}

\paragraph{Resetting the wavefront}
\label{sec:resetting-wavefront}
The following resets the wavefront amplitude to zero and phase to 1:
\index{source!complex\_amplitude!reset}
<<resetting the wavefront>>=
void complex_amplitude::reset(void)
{
  dim3 blockDim(16,1);
  dim3 gridDim(N_PX/16+1,1);
  squarePupil LLL gridDim,blockDim RRR (amplitude, phase, N_PX);
  /* if (M!=NULL) */
  /*   apply_mask LLL gridDim,blockDim RRR (amplitude, phase, M->m, N_PX);   */
}
@  
The following resets the wavefront phase to the phase of the new wavefront:
<<resetting the wavefront to new wavefront>>=
void complex_amplitude::reset(complex_amplitude wavefront_prime)
{
  reset();
  add_phase(1, wavefront_prime.phase);
}
@ 
The wavefront phase is reset to 0 with
\index{source!complex\_amplitude!reset\_phase}
<<resetting the phase>>=
void complex_amplitude::reset_phase(void)
{
HANDLE_ERROR( cudaMemset( phase, 0, sizeof(float)*N_PX ) );
}

@ 
\paragraph{Adding wavefront phase}
\label{sec:adding-wavefr-phase}
The following adds a phase aberration to the wavefront phase $$\varphi = \varphi + \alpha \varphi^\prime$$:
\index{source!complex\_amplitude!add\_phase}
<<adding wavefront phase>>=
void complex_amplitude::add_phase(float alpha, float *phase_prime)
{
  cublasHandle_t handle;
  cublasCreate(&handle);
  CUBLAS_ERROR( cublasSaxpy(handle, N_PX, &alpha, phase_prime, 1, phase, 1) );
  cublasDestroy(handle);
}

@
\paragraph{Masking wavefront amplitude}
\label{sec:mask-wavefr-ampl}
The following applies the pupil mask to the wavefront:
\index{source!complex\_amplitude!masked}
<<masking wavefront amplitude I>>=
void complex_amplitude::masked(void)
{
<<masking wavefront common>>
}
@ 
<<masking wavefront amplitude II>>=
void complex_amplitude::masked(mask *M_in)
{
M = M_in;
<<masking wavefront common>>
}
@ with
<<masking wavefront common>>=
dim3 blockDim(16,1);
dim3 gridDim(M->nel/16+1,N_PX/M->nel);
apply_mask LLL gridDim,blockDim RRR (amplitude, phase, N_PX, M->m, M->nel);  
@ and with the kernel:
<<apply mask>>=
__global__ void apply_mask(float* amplitude, float* phase, const int N, 
                           const char *pupil_mask, const int M) {
  int i,j;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  if ( (i<M) && (pupil_mask[i]==0) ) {
    j = i + M*blockIdx.y;
    amplitude[j] = 0.0;
    phase[j]     = 0.0;
  }
}
@
\paragraph{Wavefront rms}
\label{sec:wavefront-rms}

\index{source!complex\_amplitude!rms}
<<wavefront stats>>=
void complex_amplitude::rms(float *rms)
{
  float mean_data, nnz;
  int n_data = N_PX/N, idx, k;
  cublasHandle_t handle;
  cublasCreate(&handle);
  for (k=0;k<N;k++) {
    idx = k*n_data;
    CUBLAS_ERROR( cublasSdot(handle, n_data, phase + idx, 1, M->f + idx, 1, &mean_data) );
    CUBLAS_ERROR( cublasSasum(handle, n_data, M->f + idx, 1, &nnz) );
    mean_data /= nnz;
    CUBLAS_ERROR( cublasSdot(handle, n_data, phase + idx, 1, phase + idx, 1, rms+k) );
    rms[k] /= nnz;
    rms[k] -= (mean_data*mean_data);
    rms[k] = sqrt(rms[k]);
  }
  cublasDestroy(handle);
}
@ 
\subsubsection{Input/Output}
\label{sec:inputoutput-1}
The wavefront phase is save to a file with
\index{source!source!phase2file}
<<phase to file>>=
void source::phase2file(const char *filename) {
  dev2file(filename,wavefront.phase,wavefront.N_PX,wavefront.N_PX/N_SRC,N_SRC);
}

@ The wavefront phase is plotted with the plot.ly
<<plot phase>>=
void complex_amplitude::show_phase(char *filename)
{
  char title[1024];
  float *data, *d__data, alpha, piston;
  plotly_properties prop;
  stats S;

  HANDLE_ERROR( cudaMalloc((void**)&d__data, sizeof(float)*N_PX) );
  HANDLE_ERROR( cudaMemcpy( d__data, phase,
			    sizeof(float)*N_PX,
			    cudaMemcpyDeviceToDevice ) );

  S.setup();
  alpha = 1E9;
  CUBLAS_ERROR( cublasSscal(S.handle, N_PX, &alpha, d__data, 1) );
  
  
  if (M!=NULL) {

    int k, nel;
    char rms[32];
    nel = N_PX/N;
    dim3 blockDim(256);
    dim3 gridDim(N_PX/256+1);
    sprintf(title,"RMS=");

    for (k=0;k<N;k++) {
      piston = S.mean(d__data + k*nel, M, nel);
      
      remove_piston LLL gridDim,blockDim RRR (d__data + k*nel,
					      M->m, nel, piston);
      
      sprintf(rms,"%.2fnm ",S.std(d__data+ k*nel,M,nel));
      strcat(title,rms);
    }
    prop.set("title",title);
  }
  

  S.cleanup();
 
  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, d__data, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[nm]");
  prop.set("filename",filename);
  int n = (int) sqrtf(N_PX/N);
  prop.aspect_ratio = N;
  prop.set("zdata",data,n,n*N);
  prop.set("colorscale","Portland");
  imagesc(&prop); 

  HANDLE_ERROR( cudaFree( d__data ) );
  HANDLE_ERROR( cudaFreeHost( data ) );
}
@  with the kernel
<<piston removal>>=
__global__ void remove_piston(float *data, const char* mask, int n_data, float p) 
{
int i;
i = blockIdx.x * blockDim.x + threadIdx.x;
 if ( (i<n_data) && (mask[i]>0) )
       data[i] -= p;
}

@ The wavefront amplitude is plotted with the plot.ly
<<plot amplitude I>>=
void complex_amplitude::show_amplitude(char *filename)
{
  float *data;
  plotly_properties prop;

  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, amplitude, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[au]");
  prop.set("filename",filename);
  int n = (int) sqrtf(N_PX/N);
  prop.aspect_ratio = N;
  prop.set("zdata",data,n,n*N);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
<<plot amplitude II>>=
  void complex_amplitude::show_amplitude(char *filename, int N, int M)
{
  float *data;
  plotly_properties prop;

  HANDLE_ERROR( cudaHostAlloc( (void**)&data, sizeof(float)*N_PX,
			       cudaHostAllocDefault) );
  HANDLE_ERROR( cudaMemcpy( data, amplitude, sizeof(float)*N_PX,
			    cudaMemcpyDeviceToHost ) );

  prop.set("xtitle","X");
  prop.set("ytitle","Y");
  prop.set("ztitle","[au]");
  prop.set("filename",filename);
  prop.aspect_ratio = M/N;
  prop.set("zdata",data,N,M);
  imagesc(&prop); 

  HANDLE_ERROR( cudaFreeHost( data ) );
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}


\subsubsection{Coordinates transformation}
\label{sec:coord-transf}

The coordinates and cosine directions of the rays need to be transformed into the surface coordinates system first.
The matrix [[R]] in the conic structure transforms the coordinates in the LCS $(x,y,z)$ into the GCS $(\bar x,\bar y,\bar z)$ i.e.
\begin{equation}
  \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = R \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right]
\end{equation}
The reverse transform is simply
\begin{equation}
  \left[
    \begin{array}{c}
      x \\
      y \\
      z
    \end{array}
\right] = R^T \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right] = \left( \left[
  \begin{array}{c}
    \bar x - \bar x_o \\
    \bar y - \bar y_o \\
    \bar z - \bar z_o
  \end{array}
  \right]^T R \right)^T 
\end{equation}
<<transformation to surface system>>=
void transform_to_S(source *src, conic *F)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1,
                                                    F->ref_frame.d__R, 
                                                    F->ref_frame.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY,
                                                    F->ref_frame.d__R, 
                                                    F->ref_frame.d__origin);
}
void transform_to_S(source *src, aperture *A)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1,
                                                    A->ref_frame.d__R, 
                                                    A->ref_frame.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  transform_to_S_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY,
                                                    A->ref_frame.d__R, 
                                                    A->ref_frame.d__origin);
}
@ 
<<transformation to surface system kernel>>=
__global__ void transform_to_S_kernel(ray *d__ray, int N_RAY, 
				      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    forward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		      d__R, d__origin);
    forward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
			       d__R);
  }
}
@ with the projection of the ray coordinates in the surface reference frame LCS:
<<coordinates forward transform>>=
__host__ __device__  void forward_transform(vector *v_out, vector *v_in,
					 rtd *d__R, vector *d__origin)
{
  rtd u, v, w;
  u = v_in->x - d__origin->x;
  v = v_in->y - d__origin->y;
  w = v_in->z - d__origin->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
__host__ __device__  void forward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;
  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[3]*v + d__R[6]*w;
  v_out->y = d__R[1]*u + d__R[4]*v + d__R[7]*w;
  v_out->z = d__R[2]*u + d__R[5]*v + d__R[8]*w;
}  
@ 
<<transformation to rays system>>=
void transform_to_R(source *src, conic *F)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY,
        	 				     F->ref_frame.d__R, F->ref_frame.d__origin);
}
void transform_to_R(source *src, aperture *A)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  transform_to_R_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY,
        	 				     A->ref_frame.d__R, A->ref_frame.d__origin);
}
@ 
<<transformation to rays system kernel>>=
__global__ void transform_to_R_kernel(ray *d__ray, int N_RAY,
                                      rtd *d__R, vector *d__origin)
{
  int i, j, ij;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    backward_transform(&(d__ray[ij].coordinates), &(d__ray[ij].coordinates),
		       d__R, d__origin);
    backward_transform_centered(&(d__ray[ij].directions), &(d__ray[ij].directions),
				d__R);
  }
}
@ with the projection of the ray coordinates in the rays reference frame LCS:
@ 
<<coordinates backward transform>>=
__host__ __device__  void backward_transform(vector *v_out, vector *v_in,
                                    rtd *d__R, vector *d__origin)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;

  v_out->x += d__origin->x;
  v_out->y += d__origin->y;
  v_out->z += d__origin->z;    
}  
__host__ __device__  void backward_transform_centered(vector *v_out, vector *v_in,
						  rtd *d__R)
{
  rtd u, v, w;

  u = v_in->x;
  v = v_in->y;
  w = v_in->z;

  v_out->x = d__R[0]*u + d__R[1]*v + d__R[2]*w;
  v_out->y = d__R[3]*u + d__R[4]*v + d__R[5]*w;
  v_out->z = d__R[6]*u + d__R[7]*v + d__R[8]*w;
}  
@ 

\subsubsection{Surface intersection}
\label{sec:surface-intersection}

<<intersection with surface>>=
void intersect(source *src, conic *F)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  intersect_chief_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1,
						     F->k, F->c, F->d__origin);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  intersect_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY, 
					       F->k, F->c, F->d__origin,
					       src->rays.d__chief_ray);
}

<<intersection with surface kernel>>=
__global__ void intersect_chief_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin)
{
  int j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  ij = 0;

  <<intersection with z=0 plane>>
  d__ray[ij].optical_path_length = s0;
  s0 = s1 = 0;
  for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
      s0 = s1;
    }
}
__global__ void intersect_kernel(ray *d__ray, int N_RAY, 
				 const rtd Fk, const rtd Fc,
				 vector *d__origin,
                                 ray *d__chief_ray)
{
  int i, j, ij;
  rtd s0, s1, x1, y1, k, l, m, S, K, L ,M, dSds;
  vector vv;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<intersection with z=0 plane>>
    d__ray[ij].optical_path_length = s0;
    s0 = s1 = 0;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      <<Newton-Raphson>>
	s0 = s1;
    }
  d__ray[ij].optical_path_difference += 
    d__ray[ij].optical_path_length - d__chief_ray->optical_path_length;
  }
}
@
The intersection of a ray with the surface is derived using the parametric equations of the ray
\begin{eqnarray}
  \label{eq:3}
  x &=& x_0 + ks \\
  y &=& y_0 + ls \\
  z &=& z_0 + ms   
\end{eqnarray}
where $s$ is the distance along the ray from the point $(x_0,y_0,z_0)$.
Eq.~(\ref{eq:3}) are inserted into the surface definition Eq.~(\ref{eq:4}) that is solved for $s$.

The intersection with the plane $z=0$ in the LCS is derived first leading to 
\begin{eqnarray}
  \label{eq:5}
  s_0 &=& -z_0/m \\
  x_1 &=& x_0 + ks_0 \\
  y_1 &=& y_0 + ls_0 
\end{eqnarray}
<<intersection with z=0 plane>>=
k  = d__ray[ij].directions.x;
l  = d__ray[ij].directions.y;
m  = d__ray[ij].directions.z;
if (m==0) { return; }
s0 = -d__ray[ij].coordinates.z/m;
x1 = d__ray[ij].coordinates.x + k*s0;
y1 = d__ray[ij].coordinates.y + l*s0;
@
and giving a new set of parametric equations
\begin{eqnarray}
  \label{eq:6}
  x &=& x_1 + ks \\
  y &=& y_1 + ls \\
  z &=& ms     
\end{eqnarray}
 
The distance $s$ to the surface is obtained with the Newton--Raphson iterative method
\begin{equation}
  \label{eq:7}
  s_{j+1} = s_j - { F(x_j,y_j,z_j) \over F^\prime(x_j,y_j,z_j) }
\end{equation}
where
\begin{eqnarray}
  \label{eq:8}
  x_j &=& x_1 + ks_j \\
  y_j &=& y_1 + ls_j \\
  z_j &=& ms_j       
\end{eqnarray}
<<Newton-Raphson>>=
vv.x = x1 + k*s0;
vv.y = y1 + l*s0;
vv.z = m*s0;
@ and where
\begin{eqnarray}
  \label{eq:9}
  F^\prime(x_j,y_j,z_j) &=& \left. { {\mathrm d} F \over {\mathrm d} s  } \right|_{s=s_j} \\
                      &=& k\left.{ \partial F(x,y,z) \over \partial x } \right|_j + l\left. { \partial F(x,y,z) \over \partial y }\right|_j + m\left.{ \partial F(x,y,z) \over \partial z }\right|_j
\end{eqnarray}
<<Newton-Raphson>>=
S = conic_surface(&vv, d__origin, Fk, Fc);
K = partial_x_conic_surface(&vv, d__origin, Fk, Fc);
L = partial_y_conic_surface(&vv, d__origin, Fk, Fc);
M = partial_z_conic_surface();
dSds = K*k + L*l + M*m;
if (dSds==0) { return; }
s1 = s0 - S/dSds;
if (abs(s1-s0)<TOL)
{
  d__ray[ij].coordinates.x = x1 + k*s1;
  d__ray[ij].coordinates.y = y1 + l*s1;
  d__ray[ij].coordinates.z = m*s1;
  d__ray[ij].surface_normal.x    = 
    partial_x_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.y    =
    partial_y_conic_surface(&(d__ray[ij].coordinates), d__origin, Fk, Fc);
  d__ray[ij].surface_normal.z    = partial_z_conic_surface();
  d__ray[ij].optical_path_length += s1;
  d__ray[ij].n_iteration = j;
  break;
}
@
The iterative process is started with
\begin{equation}
  \label{eq:11}
  s_1 = 0,
\end{equation}
and is terminated when
\begin{equation}
  \label{eq:12}
  \left|s_{j+1} - s_j \right| < \epsilon,
\end{equation}
where $\epsilon$ is a tolerance set by the required accuracy.

The final distance along a ray from the point $(x_0,y_0,z_0)$ is
\begin{equation}
  \label{eq:13}
  s = s_0 + s_{j+1}.
\end{equation}

The surface normal at the intersection point will be needed to compute the refracted ray:
\begin{eqnarray}
  \label{eq:1}
  K &=& \left.{ \partial F(x,y,z) \over \partial x } \right|_{j+1} \\
  L &=& \left.{ \partial F(x,y,z) \over \partial y } \right|_{j+1} \\
  M &=& \left.{ \partial F(x,y,z) \over \partial z } \right|_{j+1}.
\end{eqnarray}
@

\subsubsection{Snell's law}
\label{sec:snells-law}

\paragraph{Refraction}
\label{sec:refraction}

\def\np{n^\prime}
\def\kp{k^\prime}
\def\lp{l^\prime}
\def\mp{m^\prime}
\def\Sp{S^\prime}

The Snell's law can be written as
\begin{equation}
  \label{eq:10}
  \np \vec \Sp \times \vec r = n \vec S \times \vec r.
\end{equation}
$\vec S:(k,l,m)$ and $\vec \Sp:(\kp,\lp,\mp)$ are both unit vectors along the incident and refracted rays, respectively.
$\vec r:(K,L,M)$ is a unit vector normal to the refraction surface at the ray intersection point.
$n$ and $\np$ are the refractive indices for the incident and refracted rays, respectively.

Eq.~(\ref{eq:10}) implies that the three vectors $\vec S$, $\vec \Sp$ and $\vec r$ are co--planar, from which it follows that
\begin{equation}
  \label{eq:14}
  \vec \Sp = \mu \vec S + \Gamma \vec r,
\end{equation}
where $\mu=n/\np$ and $\Gamma$ has to be determined.
$\Gamma$ is derived by solving
\begin{equation}
  \label{eq:15}
  \left| \vec \Sp \right|^2 - \left| \mu \vec S + \Gamma \vec r \right|^2 = 0
\end{equation}
Developing Eq.~(\ref{eq:15}) leads to $\Gamma$ being the solution of a quadratic equation
\begin{equation}
  \label{eq:16}
  \Gamma^2 + 2a\Gamma + b = 0
\end{equation}
where
\begin{equation}
  \label{eq:17}
  a = \mu { kK +lL + mM \over K^2 + L^2 + M^2 },
\end{equation}
<<a equation>>=
K = d__ray[ij].surface_normal.x;
L = d__ray[ij].surface_normal.y;
M = d__ray[ij].surface_normal.z;
G2 = K*K + L*L + M*M;
k = d__ray[ij].directions.x;
l = d__ray[ij].directions.y;
m = d__ray[ij].directions.z;
a = mu*(k*K + l*L + m*M)/G2;
@  and
\begin{equation}
  \label{eq:18}
  b = { \mu^2 -1 \over K^2 + L^2 + M^2 }.
\end{equation}
<<b equation>>=
b = (mu*mu-1)/G2;
@ 
Eq.~(\ref{eq:16}) is solved with the Newton--Raphson iterative method by introducing the new function
\begin{equation}
  \label{eq:19}
  V(\Gamma) = \Gamma^2 + 2a\Gamma + b,
\end{equation}
and writing $\Gamma$ as
\begin{equation}
  \label{eq:20}
  \Gamma_{j+1} = \Gamma_j - { V(\Gamma_j) \over V^\prime(\Gamma_j) }.
\end{equation}
Noting that
\begin{equation}
  \label{eq:21}
  V^\prime(\Gamma_j) = \left. { \mathrm d V \over \mathrm d \Gamma } \right|_j = 2\left( \Gamma_j + a \right),
\end{equation}
Eq.~(\ref{eq:20}) becomes
\begin{equation}
  \label{eq:22}
  \Gamma_{j+1} = { \Gamma_j^2 - b \over 2(\Gamma_j + a) }.
\end{equation}
with
\begin{equation}
  \label{eq:23}
  \Gamma_1 = {-b \over 2a }.
\end{equation}

<<refraction>>=
void refract(source *src, const rtd mu)
{
  dim3 blockDim(16,16);
  dim3 gridDim(src->rays.N_RAY/256+1,1);
  refract_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY, mu);
}
@ 
<<refraction kernel>>=
__global__ void refract_kernel(ray *d__ray, int N_RAY, const rtd mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a, b, gamma0, gamma1, gamma_relative_error;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    <<b equation>>
    gamma0 = -0.5*b/a;
    for (j=0; j<SNELL_N_ITERATION; j++)
    {
      gamma1 = 0.5*(gamma0*gamma0-b)/(gamma0+a);
      gamma_relative_error = abs( gamma1/gamma0 - 1.0 );
      if (gamma_relative_error<0.01)
      {
        d__ray[ij].directions.x = mu*k + gamma1*K;
        d__ray[ij].directions.y = mu*l + gamma1*L;
        d__ray[ij].directions.z = mu*m + gamma1*M;
        return;
      }
      gamma0 = gamma1;
    }
  }
}
@
\paragraph{Reflection}
\label{sec:reflection}

In the case of reflection, one have $\mu=1$, $b=0$ and
\begin{equation}
  \label{eq:24}
  \Gamma = -2a.
\end{equation}
Eq.~(\ref{eq:14}) thus becomes
\begin{equation}
  \label{eq:25}
    \vec \Sp = \vec S -2a \vec r.
\end{equation}
<<reflection>>=
void reflect(source *src)
{
  dim3 blockDim(1,1);
  dim3 gridDim(1,1);
  reflect_kernel LLL gridDim , blockDim RRR (src->rays.d__chief_ray, 1, 1.0);
  blockDim = dim3(16,16);
  gridDim  = dim3(src->rays.N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY, 1.0);
}
@ 
Setting $\mu=-1$ makes the mirror behaving like a thin lens:
<<thin lens>>=
void thin_lens(source *src)
{
  dim3 blockDim(16,16);
  dim3 gridDim(src->rays.N_RAY/256+1,1);
  reflect_kernel LLL gridDim , blockDim RRR (src->rays.d__ray, src->rays.N_RAY, -1.0);
}
@ 
<<reflection kernel>>=
    __global__ void reflect_kernel(ray *d__ray, int N_RAY, float mu)
{
  int i, j, ij;
  rtd k, l, m, K, L ,M, G2, a;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  if ( (ij<N_RAY) && (d__ray[ij].v) )
  {
    <<a equation>>
    a *= -2.0;
    d__ray[ij].directions.x = mu*k + a*K;
    d__ray[ij].directions.y = mu*l + a*L;
    d__ray[ij].directions.z = mu*m + a*M;
  }
}
@
