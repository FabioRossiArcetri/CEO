% -*- mode: Noweb; noweb-code-mode: c-mode -*-

@
\index{gmtMirrors}
\section{The files}
\label{sec:files}

\subsection{Header}
\label{sec:header}

<<gmtMirrors.h>>=
#ifndef __GMTMIRRORS_H_
#define __GMTMIRRORS_H_

#ifndef __RAYTRACING_H__
#include "rayTracing.h"
#endif 

#ifndef __SOURCE_H__
#include "source.h"
#endif

<<GMT M1 structure>>
<<GMT M2 structure>>
<<stereoscopic edge sensors structure>>
<<lateral edge sensors structure>>

#endif // __GMTMIRRORS_H_
@

\subsection{Source}
\label{sec:source}

<<gmtMirrors.cu>>=
#include "gmtMirrors.h"
<<GMT chief ray tracing kernel>>
<<GMT ray tracing kernel>>
<<GMT blocking kernel>>
<<GMT track kernel>>
<<stereoscopic edge sensors initialization kernel>>
<<stereoscopic edge sensors data kernel>>
<<lateral edge sensors: laser coordinates kernel>>
<<lateral edge sensors: laser coordinates to GCS kernel>>
<<lateral edge sensors: camera coordinates kernel>>
<<lateral edge sensor camera vector kernel>>
<<lateral edge sensor laser vector kernel>>
<<laser camera intersection kernel>>
<<vignetting presetting kernel>>

<<GMT M1 functions>>
<<GMT M2 functions>>

<<stereoscopic edge sensors functions>>
<<lateral edge sensors functions>>
@ 

\subsection{Python}
\label{sec:python}

\index{gmtMirrors!python}
<<gmtMirrors.pxd>>=
from numpy cimport ndarray
from utilities cimport cuFloatArray, cuDoubleArray
from rayTracing cimport rtd, vector, coordinate_system, bundle, \
    zernikeS, ZernikeS, Coordinate_system, Bundle, Coordinates
from source cimport Source
cdef extern from "gmtMirrors.h":
<<gmtMirrors.pxd contents>>
<<class definitions>>
@ 

\subsubsection{GMT mirrors}
\label{sec:gmt-mirrors}

\index{gmtMirrors!python!GmtMirrors}

<<gmtMirrors.pxd contents>>=
    cdef cppclass gmt_m1:
        void test_ray_tracing()
        <<python GMT M12 functions>>
        void preset(bundle *, rtd ) 
        void track(float *, float *, int, int)
@  where
<<python GMT M12 functions>>=
int M_ID
rtd D_assembly, D_full, D_clear, L, conic_c, conic_k
coordinate_system aperture_CS
coordinate_system conic_CS
coordinate_system rigid_body_CS
coordinate_system motion_CS
coordinate_system TT_CS
void setup(float , int )
void setup(float , int , int)
void setup(float , int, zernikeS *)
void setup(float , int, zernikeS *, int)
void cleanup()
void update(vector , vector ,int )
void reset()
void trace(bundle *)
void blocking(bundle *)
void global_tiptilt(float , float )
@
<<class definition>>=
cdef class GmtMirrors:
    cdef:
        readonly float D, D_px, focal_plane_distance, focal_plane_radius
        readonly GMT_M1 M1
        readonly GMT_M2 M2   
@ 
<<gmtMirrors.pyx>>=
cdef class GmtMirrors:
    """
    A class container from GMT_M1 and GMT_M2 classes

    Parameters
    ----------
    D : float
        The size of the pupil plane in meter
    D_px : int
        The size of the pupil plane in pixel
    M1_radial_order : int, optionnal
        The largest radial order of the Zernike polynomials on M1 segments, default to 0
    M2_radial_order : int, optionnal
        The largest radial order of the Zernike polynomials on M2 segments, default to 0

    Attributes
    ----------
    D : float
        The size of the pupil plane in meter
    D_px : int
        The size of the pupil plane in pixel
    M1 : GMT_M1
        The GMT M1 CEO class
    M2 : GMT_M2
        The GMT M2 CEO class
    sphere_radius : float
        The curvature radius of the ray tracing reference sphere

    See also
    --------
    GMT_M1 : the class for GMT M1 model
    GMT_M2 : the class for GMT M2 model
    Source : a class for astronomical sources
    cuFloatArray : an interface class between GPU host and device data for floats

    Examples
    --------
    >>> import ceo

    The mandatory parameters are the size of the pupil plane in meter or in pixel

    >>> gmt = ceo.GMT_MX(25.5,256)

    If more that one source (lets say 3) is going to be propagated through the telescope:

    >>> gmt = ceo.GMT_MX(25.5,256, N_SRC=3)

    A combination of Zernike polynomials can be applied to M1 and M2 segments by specifying the largest radial order on each mirror

    >>> gmt = ceo.GMT_MX(25.5,256, M1_radial_order=8, M2_radial_order=14)

    A source is propagated (geometrically) through the telescope with the following procedure:
u
    >>> src = ceo.Source("R",rays_box_size=25.5,rays_box_sampling=256,rays_origin=[0.0,0.0,25])
    >>> gmt.propagate(src)

    and the wavefront phase is retrieved either as a 2D map cuFloatArray object with

    >>> gpu_ps2d = src.phase()

    or as a 1D vector with 

    >>> gpu_ps1d = src.wavefront.phase()
    """
    def __cinit__(self, float D, float D_px, 
                 int M1_radial_order=0, int M2_radial_order=0):
        self.D = D
        self.D_px = D_px
        self.M1 = GMT_M1(D, D_px, radial_order=M1_radial_order)
        self.M2 = GMT_M2(D, D_px, radial_order=M2_radial_order)
        self.focal_plane_distance = -5.830
        self.focal_plane_radius   =  2.197173

    def propagate(self,Source src,where_to="exit pupil",M2_is_a_stop=True):
        """
        Propagate the Source object to the pupil plane conjugated to M1

        Parameters
        ----------
        src : Source
            The Source object
        where_to: char, optional
            Either "exit pupil" or "focal plane"; default: "exit pupil"
        M2_is_a_stop: boolean, optional
            Set if M2 acts also a stop; default: True
        """
        #src.reset()
        if M2_is_a_stop:
            self.M2.blocking(src.rays)
        self.M1.trace(src.rays)
        self.M2.trace(src.rays)
#        src.sphere_distance
#        src.rays.to_sphere(self.sphere_radius,sphere_distance = src.sphere_distance)
        if where_to=="exit pupil":
            src.rays.to_sphere(focal_plane_distance=self.focal_plane_distance,
                               focal_plane_radius=self.focal_plane_radius)
            src.opd2phase()
        if where_to=="focal plane":
            src.rays.to_z_plane(self.focal_plane_distance)

    def reset(self):
        """
        Reset M1 and M2 mirror segments to their original locations and shapes
        """
        self.M1.reset()
        self.M1.zernike.reset()
        self.M2.reset()
        self.M2.zernike.reset()
@
\subsubsection{GMT M1}
\label{sec:gmt-m1-1}

\index{gmtMirrors!python!GMT\_M1}
<<class definitions>>=
cdef class GMT_M1:
    cdef:
        gmt_m1 *_c_gmt_m12
    <<GMT M12 class properties>>    
@
<<gmtMirrors.pyx>>=
# GMT M1
cdef class GMT_M1:
    <<GMT M12 docstring>>

    def __cinit__(self, float D, int D_px, int radial_order=0, int N_SRC=1):
        self._c_gmt_m12 = new gmt_m1()
        <<GMT M12 constructor>>

    <<GMT M12 methods>>

    def test(self):
        self._c_gmt_m12.test_ray_tracing();

    def preset(self, Bundle rays, float margin):
        self._c_gmt_m12.preset(rays._c_bundle, margin)

    def track(self, ndarray x, ndarray y, int segId):

        cdef cuFloatArray gx, gy, gz
        gx = cuFloatArray( host_data = x )
        gy = cuFloatArray( host_data = y )
        self._c_gmt_m12.track(gx._c_gpu.dev_data,
                              gy._c_gpu.dev_data,
                              x.size, segId)
        return gx.host(), gy.host()
@
<<GMT M12 constructor>>=
self.zernike = ZernikeS(radial_order,N_SURF=7)
self._c_gmt_m12.setup(D, D_px, <zernikeS *> self.zernike._c_zernikeS, 0)

self.aperture_CS   = Coordinate_system(7)
self.conic_CS      = Coordinate_system(7)
self.motion_CS     = Coordinate_system(7)
self.rigid_body_CS = Coordinate_system(7)
self.TT_CS         = Coordinate_system(1)

self.aperture_CS.init(   &(self._c_gmt_m12.aperture_CS)   )
self.conic_CS.init(      &(self._c_gmt_m12.conic_CS)      )
self.motion_CS.init(     &(self._c_gmt_m12.motion_CS)     )
self.rigid_body_CS.init( &(self._c_gmt_m12.rigid_body_CS) )
self.TT_CS.init(         &(self._c_gmt_m12.TT_CS)         )

@ 
<<GMT M12 methods>>=
def __dealloc__(self):
    self._c_gmt_m12.cleanup()

def trace(self, Bundle rays):
    """
    Ray tracing to the mirror

    Parameters
    ----------
    rays : Bundle
        A ray bundle used to propagate the light

    See also
    --------
    Bundle: a class representing a bundle of light rays used for geometric propagation
    """
    self._c_gmt_m12.trace(rays._c_bundle)

def blocking(self, Bundle rays):
    """
    Makes the mirror acting as a stop

    Parameters
    ----------
    rays : Bundle
        A ray bundle used to propagate the light

    See also
    --------
    Bundle: a class representing a bundle of light rays used for geometric propagation
    """
    self._c_gmt_m12.blocking(rays._c_bundle)

def update(self, list origin=[0.0,0.0,0.0], list euler_angles=[0.0,0.0,0.0], int idx=0):
    """
    Updates the position of the mirror segments

    Parameters
    ----------
    origin : list of float, optional
        The location of a segment center; default: [0,0,0]
    euler_angles : list of float, optional
        The tip, tilt and clock angles of a segment; default: [0,0,0]
    idx : int
        The segment index from 1 to 7
    """
    assert idx>0 and idx<8, "The segment index must be between 1 and 7!"
    self.motion_CS.origin[idx-1,:] = origin
    self.motion_CS.euler_angles[idx-1,:] = euler_angles
    self.motion_CS.update()

def global_tiptilt(self, float tip, float tilt):
    """
    Applies a global tip--tilt to M1

    Parameters
    ----------
    tip : float
        The x axis angle
    tilt : float
        The y axis angle
    """
    self._c_gmt_m12.global_tiptilt(tip, tilt);

def reset(self):
    """
    Reset the segments to their original prescription
    """
    self.motion_CS.origin[:] = 0.0
    self.motion_CS.euler_angles[:] = 0.0
    self.motion_CS.update()
        
property D_assembly:
    def __get__(self):
        return self._c_gmt_m12.D_assembly

property D_full:
    def __get__(self):
        return self._c_gmt_m12.D_full

property D_clear:
    def __get__(self):
        return self._c_gmt_m12.D_clear

property L:
    def __get__(self):
        return self._c_gmt_m12.L

property conic_c:
    def __get__(self):
        return self._c_gmt_m12.conic_c

property conic_k:
    def __get__(self):
        return self._c_gmt_m12.conic_k

property M_ID:
    def __get__(self):
        return self._c_gmt_m12.M_ID
@ with
<<GMT M12 docstring>>=
"""
A class to represent GMT M1 or M2 segmented mirror

Parameters
----------
D : float
    The size in meter of the pupil plane (must be equal or larger than the telescope diameter)
D_px : float
    The size in pxixel of the pupil plane
radial_order : int, optional
    The radial order of the last Zernike polynomials, default to 0

Attributes
----------
D_assembly : rtd
    The mirror assembly diameter
D_full : rtd
    The segment full aperture diameter
D_clear : rtd
    The segment clear aperture diameter
L : rtd
    The distance from the optical axis to the center of the tilted peripheral segments
conic_c : rtd
    The inverse of the mirror radius of curvature
conic_k : rtd
    The conic parametert
M_ID : int
    The mirror ID #
zernike : ZernikeS
    The figure of the segments as Zernike surface object
aperture_CS : Coordinate_system
    The segment aperture coordinate system
conic_CS : Coordinate_system
    The segment conic coordinate system
motion_CS : Coordinate_system
    The segment motion coordinate system
rigid_body_CS : Coordinate_system
    The segment rigid body coordinate system
TT_CS : Coordinate_system
    The mirror global tip-tilt coordinate system

Examples
--------
>>> import ceo
>>> M1 = ceo.GMT_M1(25.5,101)

With multiple sources:

>>> M2 = ceo.GMT_M2(25.5,101,N_SRC=4)

With Zernike modes

>>> M1 = ceo.GMT_M1(25.5,101,radial_order=4)

An M1 segment (#2) is displaced in x of 2 micron and tilted in y of 50mas with

>>> import math
>>> theta = 50e-3*math.pi/180/3600
>>> M1.update(origin=[2e-6,0,0],euler_angles=[0,theta,0],idx=2)

A global tip-tilt of M1 is achieved with

>>> M1.global_tiptilt(theta,-theta)

M2 pointing neutral and coma neutral tip-tilt are realized with

>>> M2.pointing_neutral(theta,-theta)
>>> M2.coma_neutral(theta,-theta)
"""
@ and with
<<GMT M12 class properties>>=
cdef:
    public ZernikeS zernike
    public Coordinate_system aperture_CS
    public Coordinate_system conic_CS
    public Coordinate_system rigid_body_CS
    public Coordinate_system motion_CS
    public Coordinate_system TT_CS
@ 

\subsubsection{GMT M2}
\label{sec:gmt-m2-1}

\index{gmtMirrors!python!GMT\_M2}
<<gmtMirrors.pxd contents>>=
    cdef cppclass gmt_m2:
        <<python GMT M12 functions>>
        void pointing_neutral(float, float)
        void coma_neutral(float, float)
@
<<gmtMirrors.pyx>>=
# GMT M2
cdef class GMT_M2:
    <<GMT M12 docstring>>
    cdef gmt_m2 *_c_gmt_m12
    <<GMT M12 class properties>>    
    
    def __cinit__(self, float D, int D_px, radial_order=0, int N_SRC=1):
        self._c_gmt_m12 = new gmt_m2()
        <<GMT M12 constructor>>

    <<GMT M12 methods>>

    def pointing_neutral(self, float tip, float tilt):
        """
        Applies a pointing neutral global tip--tilt to M2

        Parameters
        ----------
        tip : float
            The x axis angle
        tilt : float
            The y axis angle
        """
        self._c_gmt_m12.pointing_neutral(tip, tilt);

    def coma_neutral(self, float tip, float tilt):
        """
        Applies a coma neutral global tip--tilt to M2

        Parameters
        ----------
        tip : float
            The x axis angle
        tilt : float
            The y axis angle
        """
        self._c_gmt_m12.coma_neutral(tip, tilt);
@
\subsubsection{Stereoscopic edge sensors}
\label{sec:ster-edge-sens}

\index{gmtMirrors!python!stereoscopic\_edge\_sensors}
<<gmtMirrors.pxd contents>>=
    cdef cppclass stereoscopic_edge_sensors:
        int N, N_DATA
        vector *v0
        vector *dv0
        vector *v
        vector *dv
        void setup(gmt_m1 *)
        void cleanup()
        void data()
@
<<class definitions>>=
cdef class StereoscopicEdgeSensors:
    cdef:
        stereoscopic_edge_sensors *_c_stereoscopic_edge_sensors
        public Coordinates v0, v, dv0, dv
@ 
<<gmtMirrors.pyx>>=
cdef class StereoscopicEdgeSensors:
    """
    A class for the GMT stereoscopic edge sensors.
    The stereoscopic model measures the coordinates of the 3-dimension vector joining a pair of edge sensors.

    Parameters
    ----------
    mirror : GMT_M1
        The GMT M1 mirror

    Attributes
    ----------
    v0 : Coordinates
        The coordinates of the edge sensors for a perfectly aligned telescope
    v : Coordinates
        The coordinates of the edge sensors for a disturbed telescope
    dv0 : Coordinates
        The coordinates of the vector joining a pair of edge sensors for a perfectly aligned telescope
    dv : Coordinates
        The coordinates of the vector joining a pair of edge sensors for a disturbed telescope

    See also
    --------
    Coordinates : an interface between an array of device vectors and an array of host coordinates
    """
    def __cinit__(self,GMT_M1 mirror):
        self._c_stereoscopic_edge_sensors = new stereoscopic_edge_sensors()
        self._c_stereoscopic_edge_sensors.setup(mirror._c_gmt_m12)
        self.v0    = Coordinates((self._c_stereoscopic_edge_sensors.N,3))
        self.v0.v  = self._c_stereoscopic_edge_sensors.v0
        self.dv0   = Coordinates((self._c_stereoscopic_edge_sensors.N_DATA,3))
        self.dv0.v = self._c_stereoscopic_edge_sensors.dv0
        self.v     = Coordinates((self._c_stereoscopic_edge_sensors.N,3))
        self.v.v   = self._c_stereoscopic_edge_sensors.v
        self.dv   = Coordinates((self._c_stereoscopic_edge_sensors.N_DATA,3))
        self.dv.v = self._c_stereoscopic_edge_sensors.dv

    def __dealloc__(self):
        self._c_stereoscopic_edge_sensors.cleanup()

    def data(self):
        """
        Computes the edge sensor measurements
        """
        self._c_stereoscopic_edge_sensors.data()
@
\subsubsection{Lateral edge sensors}
\label{sec:lateral-edge-sensor}

\index{gmtMirrors!python!lateral\_edge\_sensors}
<<gmtMirrors.pxd contents>>=
    cdef cppclass lateral_edge_sensors:
        int N_DATA
        vector *A0
        vector *A
        vector *B0
        vector *B
        vector *k_cam
        vector *k_laser
        rtd *d__x
        rtd *d__y
        rtd *d__d
        void setup(gmt_m1 *)
        void setup(gmt_m1 *, rtd)
        void cleanup()
        void data()
@
<<class definitions>>=
cdef class LateralEdgeSensors:
    cdef:
        lateral_edge_sensors *_c_lateral_edge_sensors
        public Coordinates A, A0, B, B0, k_cam, k_laser
        public cuDoubleArray x, y
@ 
<<gmtMirrors.pyx>>=
cdef class LateralEdgeSensors:
    """
    A class for the GMT lateral displacement edge sensors.
    It applies to the case of a laser aiming at a camera.
    The measurements are the laser spot location within the frame of the camera.
    
    Parameters
    ----------
    mirror : GMT_M1
        The GMT M1 mirror
    
    Attributes
    ----------
    A : Coordinates
        The laser location coordinates in the motion coordinate system of the segment they are attached to.
    B : Coordinates
        The camera location coordinates in the rigid body coordinate system of the segment they are attached to.
    B0 : Coordinates
        The camera location coordinates in the global coordinate system of the segment they are attached to.
    k_cam : Coordinates
        The vector joining a pair of laser/camera in the rigid body coordinate system of the segment that the camera is attached to in the case of a perfectly aligned telescope.
    k_laser : Coordinates
        The vector joining a pair of laser/camera in the rigid body coordinate system of the segment that the camera is attached to in the case of a disturbed telescope.
    x : cuDoubleArray
        The x-axis coordinates of the laser spot
    y : cuDoubleArray
        The y-axis coordinates of the laser spot
    
    See also
    --------
    Coordinates : an interface between an array of device vectors and an array of host coordinates
    cuDoubleArray : an interface class between GPU host and device data for doubles
    """
    def __cinit__(self,*args,**kwargs):
        self._c_lateral_edge_sensors = new lateral_edge_sensors()

    def __init__(self,GMT_M1 mirror,*args,**kwargs):
        if len(args)>0:
            self._c_lateral_edge_sensors.setup(mirror._c_gmt_m12,args[0])
        else:
            self._c_lateral_edge_sensors.setup(mirror._c_gmt_m12)
        self.A = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.A.v = self._c_lateral_edge_sensors.A
        self.A0 = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.A0.v = self._c_lateral_edge_sensors.A0
        self.B0 = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.B0.v = self._c_lateral_edge_sensors.B0
        self.B = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.B.v = self._c_lateral_edge_sensors.B
        self.k_cam = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.k_cam.v = self._c_lateral_edge_sensors.k_cam
        self.k_laser = Coordinates((self._c_lateral_edge_sensors.N_DATA,3))
        self.k_laser.v = self._c_lateral_edge_sensors.k_laser
        self.x = cuDoubleArray(shape=(self._c_lateral_edge_sensors.N_DATA,1),dev_malloc=False)
        self.x._c_gpu.dev_data = self._c_lateral_edge_sensors.d__x
        self.y = cuDoubleArray(shape=(self._c_lateral_edge_sensors.N_DATA,1),dev_malloc=False)
        self.y._c_gpu.dev_data = self._c_lateral_edge_sensors.d__y

    def __dealloc__(self):
        self._c_lateral_edge_sensors.cleanup()

    def data(self):
        """
        Computes the edge sensor measurements
        """
        self._c_lateral_edge_sensors.data()
@
\subsubsection{Distance edge sensors}
\label{sec:dist-edge-sens}

\index{gmtMirrors!python!distance\_edge\_sensors}
<<class definitions>>=
cdef class DistanceEdgeSensors(LateralEdgeSensors):
    cdef:
        cuDoubleArray _d_
        readonly double[:,::1] d0
@ 
<<gmtMirrors.pyx>>=
import numpy as np
cdef class DistanceEdgeSensors(LateralEdgeSensors):
    """
    A class for the GMT distance edge sensors.
    It applies to the case of a laser aiming at a retroreflector.
    The measurements are the distances between the laser spot and the retroreflector.
    
    Parameters
    ----------
    mirror : GMT_M1
        The GMT M1 mirror
    height : rtd
        The laser and retroreflector are placed at a distance of +/- height from the z=0 plane of the segments
    
    Attributes
    ----------
    d : cuDoubleArray
        The distance between the laser and the retroreflector
    
    See also
    --------
    cuDoubleArray : an interface class between GPU host and device data for doubles
    """
    def __init__(self,GMT_M1 mirror, rtd height=0.25):
        super().__init__(mirror, height)
        self._d_ = cuDoubleArray(shape=(self._c_lateral_edge_sensors.N_DATA,1),dev_malloc=False)
        self._d_._c_gpu.dev_data = self._c_lateral_edge_sensors.d__d
        self.d0 = np.zeros((self._c_lateral_edge_sensors.N_DATA,1))

    def calibration(self):
        self.data()
        self.d0 = self._d_.host()

    property d:
        def __get__(self):
            self.data()
            return self._d_.host()-self.d0
        
@
\section{GMT M1}
\label{sec:gmt-m1}

\index{gmtMirrors!gmt\_m1}
A new structure to hold GMT M1 and M2 parameters and functions is defined.
<<GMT M1 structure>>=
struct gmt_m1 {
  <<GMT M12 parameters>>
  <<GMT M1 parameters>>
  <<GMT M12 functions>>
  void preset(bundle *rays, rtd margin);
  void edge_sensors_data(void);
};
@  with
<<GMT M12 functions>>=
void setup(float _D_, int _D_px_);
void setup(float _D_, int _D_px_, zernikeS *ZS);
void setup(float _D_, int _D_px_, int N_SRC);
void setup(float _D_, int _D_px_, zernikeS *ZS, int N_SRC);
void cleanup(void);
void update(vector _origin_, vector _euler_angles_,int idx);
void reset(void);
void trace(bundle *rays);
void blocking(bundle *rays);
void global_tiptilt(float tip, float tilt);
void test_ray_tracing(void);
void track(float *x, float *y, int N, int idx);
@ 
The GMT M12 parameters are:
\begin{itemize}
\item the mirror ID:
<<GMT M12 parameters>>=
int M_ID;
@
\item the mirror assembly diameter $[[D_assembly]]$:
<<GMT M12 parameters>>=
rtd D_assembly;
@
\item the segment clear aperture diameter $[[D_clear]]$:
<<GMT M12 parameters>>=
rtd D_clear;
@
\item the segment full aperture diameter $[[D_full]]$:
<<GMT M12 parameters>>=
rtd D_full;
@
\item the obscuration ratio of the center segment $[[ri]]$
<<GMT M12 parameters>>=
rtd ri;
@
\item the tilt angle of the peripheral segment $[[beta]]$degree
<<GMT M12 parameters>>=
rtd beta;
@
\item the distance from the optical axis to the center of the tilted peripheral segments $[[L]]$m:
<<GMT M12 parameters>>=
rtd L;
@
\item the size of the square array containing M1 in meter and pixel [[D]] and [[D_px]]:
<<GMT M12 parameters>>=
rtd D;
int D_px;
@
\item the mirror total area as seen by an on--axis source in square meter and number of pixel
<<GMT M12 parameters>>=
rtd area0;
float area0_px;
@ 
\item the mirror total area as seen by the star propagating through the telescope
<<GMT M12 parameters>>=
rtd area;
@
\item the number of segment $[[N]]=7$
<<GMT M12 parameters>>=
int N;
@
\item the edge to center depth of the segment conic $[[depth]]$:
<<GMT M12 parameters>>=
rtd depth;
@
\item the reference frames of the apertures:
<<GMT M12 parameters>>=
coordinate_system aperture_CS;
@
\item the reference frames and origins of the conics:
<<GMT M12 parameters>>=
coordinate_system conic_CS;
vector conic_origin[7], *d__conic_origin;
@
\item the conic parameters:
<<GMT M12 parameters>>=
rtd conic_c, conic_k;
@
\item the reference frames of the rigid bodies:
<<GMT M12 parameters>>=
coordinate_system rigid_body_CS;
@
\item the reference frames of the motions:
<<GMT M12 parameters>>=
coordinate_system motion_CS;
@
\item the mirror height
<<GMT M12 parameters>>=
rtd height;
@
\item the M1 pupil mask [[V]]:
<<GMT M12 parameters>>=
mask *V;
@
\item the segment index offset (0 for M1 and 3 for M2):
<<GMT M12 parameters>>=
int idx_offset;
@
\item an array of Zernike surface, one per segment, [[ZS]]:
<<GMT M12 parameters>>=
zernikeS *ZS;
@
\item the segment piston mask
<<GMT M12 parameters>>=
int *d__piston_mask;
@
\item global tip--tilt transformation variables:
  \begin{itemize}
  \item a coordinate system:
<<GMT M12 parameters>>=
coordinate_system TT_CS;
@
\item a pointer to a matrix array:
<<GMT M12 parameters>>=
double *d__C;
@
\item a CUBLAS handle:
<<GMT M12 parameters>>=
cublasHandle_t handle;
@
\end{itemize}
 \end{itemize}


\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-1}

The GMT M1 segment have all the same clear aperture of 8.365m diameter.
The center segment has a hole of 2.4412m diameter.
The center aperture is centered on the vertex of the conic surface that defines M1.
The vertex is set as the origin of the global coordinate system (GCS).
The center of the peripheral segments are evenly located on a circle of radius 8.710m with a phase of 30 degrees.
The peripheral segments also tilted inwards by 13.522 degrees.
The [[GMT_M1]] structure is initialized with the size of the square array containing M1 in meter and pixel.
The size must be 25.5m or more to contain M1 fully.
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_)
{
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ or
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_)
{
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ where
<<M1 parameters>>=
M_ID    = 1;
D_px    = _D_px_;
D       = _D_;
D_assembly = 25.498;
D_full  = 8.417;
D_clear = 8.365;
area    = 368;
area0   = 368;
ri      = 2.4412/8.365;
beta    = 13.601685*PI/180.0;
L       = 8.710;
N       = 7;
conic_c = 1.0/36.0;
conic_k = 1-0.9982857;
height  = 0.0;
idx_offset = 0;
V = NULL;
@  
If an array of sources is propagated through the telescope then
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  <<M1 parameters>>
  <<GMT setup common>>
}
@ or
\index{gmtMirrors!gmt\_m1!setup}
<<GMT M1 functions>>=
void gmt_m1::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  <<M1 parameters>>
  <<GMT setup common>>
}
@  where
<<GMT setup common>>=
vector __v0(0.0,0.0,0.0),
       __v(D_full*0.5,0.0,0.0),
       origin[12],
       euler_angles[12];
rtd D_c, o, zo;
 int k, idx;    
char tag[16];

depth = conic_equation(&__v,&__v0,conic_k,conic_c);
D_c = L;
__v.x = L;
zo = conic_equation(&__v,&__v0,conic_k,conic_c);

<<M12 rigid body definition>>

<<M12 aperture definition>>

<<M12 conic definition>>

<<M12 motion definition>>

<<GMT global tip-tilt setup>>
@
\subsubsection{Rigid body coordinate systems}
\label{sec:rigid-body-coord}

The rigid body coordinate systems are aligned with the segment coordinate systems.
The origins $[x_O, y_O, z_O]$ of the segment coordinate systems are given with respect to the global coordinate system which origin is at the vertex of M1 conic surface: 
\begin{eqnarray}
  \label{eq:1}
  x_{O,k} &=& L\cos(\theta_{O,k}), \\
  y_{O,k} &=& L\sin(\theta_{O,k}), \\
  z_O &=& F(L),\\
\end{eqnarray}
with, for M1, $L = 8.71$m, $\theta_{O,k}=\pi(3-2k)/6, \forall k \in [0,5]$, $x_{O,6}=y_{O,6}=0$ and
\begin{equation}
  \label{eq:2}
  F(\rho) = {c\rho^2 \over 1 + \sqrt{1 - \kappa c^2 \rho^2} }.
\end{equation}
In addition to the change of origin with respect to the GCS, the segment coordinate system is rotated around the z--axis of $-k\pi/3$radian and then tilted around the x--axis of $\beta$.
\begin{center}
\input{rigidBodyCS.tex}
\end{center}
<<M12 rigid body definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = height;
euler_angles[N-1].x = euler_angles[N-1].y = 0.0;
euler_angles[N-1].z = (idx_offset/2)*PI;
for (k=0; k<N-1; k++)
{
  o = PI*(3-2*k)/6.0;
  <<segment index offset>>
  origin[idx].x = D_c*cos(o);
  origin[idx].y = D_c*sin(o);
  origin[idx].z = height + zo;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
}
sprintf(tag,"M%d RIGID BODY",M_ID);
rigid_body_CS.setup(origin, euler_angles, N, tag);
@ with
<<segment index offset>>=
idx = (k + idx_offset)%6;
@
\subsubsection{Aperture coordinate systems}
\label{sec:apert-coord-syst}


The coordinate systems of the segment apertures are defined with respect to the coordinate systems of the rigid body motions.
The apertures are directly above the segments such as they rest on the rim of the segments. 
<<M12 aperture definition>>=
origin[N-1].x = origin[N-1].y = 0.0;
origin[N-1].z = depth;
euler_angles[N-1].x = euler_angles[N-1].y = euler_angles[N-1].z = 0.0;
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = depth;
  euler_angles[idx].x = 0.0;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = 0.0;
}
sprintf(tag,"M%d APERTURE",M_ID);
aperture_CS.setup(origin, euler_angles, N, tag);
@
\subsubsection{Conic coordinate systems}
\label{sec:conic-coord-syst}


The coordinate systems of the segment conics are defined with respect to the coordinate systems of the rigid body motions.
Both coordinate systems share the same origin but x--axis and y--axis are parallel to the x--axis and y--axis of the GCS.
The origins of the segment conics are also given in the coordinate systems of the segment conics.
\begin{center}
\begin{tikzpicture}
  \draw[->] (-25mm,0) -- (35mm,0) node[below] {$\bar x$};
  \draw[->] (0,-25mm) -- (0,35mm) node[right] {$\bar y$};
  \draw[thin,dashed] (0,0) circle [radius=21mm];
  \coordinate (O) at (0,0);
  \draw (O) circle [radius=10mm] node[above left=3mm] {7};
  \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\hat x$};
  \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\hat y$};
  \foreach \x in {1,...,6} {
    \coordinate (O) at (150-\x*60:21mm);
    \draw (O) circle [radius=10mm] node[above left=3mm] {\x};
    \draw[->,thick,red] ($(O)+(-5mm,0)$) -- ($(O)+(5mm,0)$) node[below] {$\check x$};
    \draw[->,thick,red] ($(O)+(0,-5mm)$) -- ($(O)+(0,5mm)$) node[right] {$\check y$};

  }    
\end{tikzpicture}  
\end{center}
<<M12 conic definition>>=
origin[N-1].x = origin[N-1].y = origin[N-1].z = 0.0;
euler_angles[N-1].x = euler_angles[N-1].y = 0.0;
euler_angles[N-1].z = (idx_offset/2)*PI;
conic_origin[N-1].x = conic_origin[N-1].y = conic_origin[N-1].z = 0.0; 
for (k=0; k<N-1; k++)
{
  <<segment index offset>>
  o = PI*(3-2*k)/6.0;
  origin[idx].x = 0.0;
  origin[idx].y = 0.0;
  origin[idx].z = 0.0;
  euler_angles[idx].x = beta;
  euler_angles[idx].y = 0.0;
  euler_angles[idx].z = -PI*k/3.0;
  conic_origin[idx].x = -D_c*cos(o);
  conic_origin[idx].y = -D_c*sin(o);
  conic_origin[idx].z = -zo;
}
//euler_angles[0].x = 30.0*PI/180.0/3600.0;
sprintf(tag,"M%d CONIC",M_ID);
conic_CS.setup(origin, euler_angles, N, tag);
HANDLE_ERROR( cudaMalloc((void**)&d__conic_origin, sizeof(vector)*N ) );
HANDLE_ERROR( cudaMemcpy( d__conic_origin, conic_origin, 
			    sizeof(vector)*N, cudaMemcpyHostToDevice ) );
@
\subsubsection{Segment motion coordinate systems}
\label{sec:segm-moti-coord}


The motion coordinate systems are defined with respect to the coordinate systems of the rigid body motions.
For unperturbed segments, both coordinate systems coincide.
<<M12 motion definition>>=
for (k=0; k<N; k++)
{
  origin[k].x = 0.0;
  origin[k].y = 0.0;
  origin[k].z = 0.0;
  euler_angles[k].x = 0.0;
  euler_angles[k].y = 0.0;
  euler_angles[k].z = 0.0;
}
sprintf(tag,"M%d MOTION",M_ID);
motion_CS.setup(origin, euler_angles, N, tag);
@ 

\subsubsection{Cleanup, update \& reset}
\label{sec:cleanup-update-reset}


Memory is freed with
\index{gmtMirrors!gmt\_m1!cleanup}
<<GMT M1 functions>>=
void gmt_m1::cleanup(void)
{
  fprintf(stdout,"@(CEO)>gmt_m1: freeing memory!\n");
  <<GMT cleanup common>>
}
@ with
<<GMT cleanup common>>=
fprintf(stdout," |-");
<<GMT global tip-tilt cleanup>>
fprintf(stdout," |-");
aperture_CS.cleanup();
fprintf(stdout," |-");
conic_CS.cleanup();
fprintf(stdout," |-");
rigid_body_CS.cleanup();
fprintf(stdout," |-");
motion_CS.cleanup();
HANDLE_ERROR( cudaFree( d__conic_origin ) );
@
The rigid body motion parameters are updated with:
\index{gmtMirrors!gmt\_m1!update}
<<GMT M1 functions>>=
void gmt_m1::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ where
<<GMT M12 update>>=
  //fprintf(stdout,"\n\x1B[31m");
motion_CS.update( _origin_, _euler_angles_, --idx);
//motion_CS.info();
@ 
The rigid body motion are reset to 0 with:
\index{gmtMirrors!gmt\_m1!reset}
<<GMT M1 functions>>=
void gmt_m1::reset(void)
{
    <<GMT M12 reset>>
}
@ where
<<GMT M12 reset>>=
vector zero;
zero.x = 0.0;
zero.y = 0.0;
zero.z = 0.0;
//fprintf(stdout,"\n\x1B[31m");
for (int k=0; k<N; k++)
   motion_CS.update( zero, zero, k);
//motion_CS.info();
@ 

\subsection{Presetting rays vignetting}
\label{sec:pres-rays-vign}
\index{gmtMirrors!gmt\_m1!preset}

The GMT have a sparse aperture.
But presetting the vignetting of the rays of the source, the ray tracing routines will run much faster.
The assumption is that all the rays outside a circle of diameter $[[D_assembly]]+[[margin]]$ are vignetted per default.
<<GMT M1 functions>>=
void gmt_m1::preset(bundle *rays, rtd margin) 
{
 dim3 blockDim(N_THREAD,N_THREAD);
 dim3 gridDim(rays->N_L/N_THREAD+1,rays->N_L/N_THREAD+1, rays->N_BUNDLE);
 m1_preset_kernel LLL gridDim , blockDim RRR (rays->d__ray, rays->N_RAY, 
					      rays->L, rays->N_L, 
					      0.5*(margin+D_assembly));
}
@ with the kernel
<<vignetting presetting kernel>>=
__global__ void m1_preset_kernel(ray *d__ray, int N_RAY,
				 rtd L, int N_L, rtd R)
{
  int i, j, k, iSource;
  rtd x, y, r;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = blockIdx.y * blockDim.y + threadIdx.y;
  iSource = blockIdx.z;
  if ( (i<N_L) && (j<N_L) ) {
    k = i + j*N_L + iSource*N_RAY;
    x   = L*(i - (N_L-1)*0.5)/(N_L-1);
    y   = L*(j - (N_L-1)*0.5)/(N_L-1);
    r = hypot(x,y);
    if (r>R) 
      d__ray[k].v = 0;
  }
}
@ 
\subsection{Blocking}
\label{sec:blocking}

The rays blocking with M1 is computed with
\index{gmtMirrors!gmt\_m1!blocking}
<<GMT M1 functions>>=
void gmt_m1::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@ where
<<GMT blocking common>>=
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 V = &(rays->V);
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 // printf("N_BUNDLE=%d\n",rays->N_BUNDLE);
 int nel = rays->N_RAY*rays->N_BUNDLE;
 dim3 blockDim(N_THREAD2);
 dim3 gridDim(nel/N_THREAD2+1);
 fill_ones_char LLL gridDim,blockDim RRR (V->m,nel);
 blockDim = dim3(N_THREAD,N_THREAD);
 gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE);
 m1_blocking_kernel LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin);
 intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY);
@ and with the kernel
<<GMT blocking kernel>>=
__global__ void m1_blocking_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin)
{
  int i, j, ij, iCoordSys, iSource;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  vector xyz, klm, xyz_GS, klm_GS;

  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 0;
          }
       }
   }
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing}

  \begin{figure}
    \centering    
    \input{raytracingWorkflow.tex}
    \caption{Ray tracing flowchart for GMT M1 and M2 mirrors.}
    \label{fig:1}
  \end{figure}

The rays propagation through M1 is computed with
\index{gmtMirrors!gmt\_m1!trace}
<<GMT M1 functions>>=
void gmt_m1::trace(bundle *rays)
{
  rays->V.area = area0;
  <<GMT trace common>>
}
@ where
<<GMT trace common>>=
 dim3 blockDim, gridDim;
 rtd R2, Rri2;
 R2 = D_clear*D_clear*0.25;
 Rri2 = R2*ri*ri;
 /* if (V!=NULL) { */
 /*    blockDim = dim3(N_THREAD,N_THREAD); */
 /*    gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE); */
 /*    intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY); */
 /* } */
 V = &(rays->V);
 // fprintf(stdout,"R2=%5.2f - Rri2=%5.2f\n",R2,Rri2);  
 blockDim = dim3(1,1);
 gridDim  = dim3(1,1,rays->N_BUNDLE);
 m1_trace_chief_kernel LLL gridDim , blockDim RRR (V->m, rays->d__chief_ray, 1, 
						   conic_CS.d__R,
						   conic_CS.d__origin,
						   conic_k, conic_c,
						   d__conic_origin,
						   rigid_body_CS.d__R,
						   rigid_body_CS.d__origin,
						   motion_CS.d__R,
						   motion_CS.d__origin,
						   ZS->max_n, ZS->n_mode,
						   ZS->d__a, ZS->d__cx, ZS->d__cy,
						   0.5*D_full);
 blockDim = dim3(N_THREAD,N_THREAD);
 gridDim  = dim3(rays->N_RAY/N_THREAD2+1,1,rays->N_BUNDLE);
 HANDLE_ERROR( cudaMemset(V->m, 0, sizeof(char)*rays->N_RAY*rays->N_BUNDLE ) );
 HANDLE_ERROR( cudaMemset(rays->d__piston_mask, 0, 
			  sizeof(int)*rays->N_RAY*rays->N_BUNDLE ) );
m1_trace_kernel LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY, 
					     Rri2, R2,
					     aperture_CS.d__R,
					     aperture_CS.d__origin,
					     conic_CS.d__R,
					     conic_CS.d__origin,
					     conic_k, conic_c,
					     d__conic_origin,
					     rigid_body_CS.d__R,
					     rigid_body_CS.d__origin,
					     motion_CS.d__R,
					     motion_CS.d__origin,
					     ZS->max_n, ZS->n_mode,
					     ZS->d__a, ZS->d__cx, ZS->d__cy,
					     0.5*D_full,
					     rays->d__chief_ray,
					     rays->d__piston_mask);
intersection LLL gridDim , blockDim RRR (V->m, rays->d__ray, rays->N_RAY);
float previous_nnz = rays->V.nnz;
//fprintf(stdout,"M%d previous nnz rays: %f\n",M_ID,previous_nnz);
rays->V.set_filter_quiet();
//fprintf(stdout,"M%d current nnz rays: %f\n",M_ID,rays->V.nnz);
if (previous_nnz<rays->N_RAY)
  rays->V.area *= rays->V.nnz/previous_nnz;
//fprintf(stdout,"M%d current area: %f\n",M_ID,rays->V.area);
@ and with the kernel
<<GMT ray tracing kernel>>=
__global__ void m1_trace_kernel(char *mask, ray *d__ray, int N_RAY, 
				rtd inner2, rtd outer2,
				rtd *d__aperture_R, vector *d__aperture_origin,
				rtd *d__conic_R, vector *d__conic_origin,
                                const rtd Fk, const rtd Fc,
                                vector *d__conic_self_origin,
				rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				rtd *d__motion_R, vector *d__motion_origin,
				int max_n, int n_mode,
				rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R,
				ray *d__chief_ray,
				int *d__piston_mask)
{
  int i, j, ij, iCoordSys, iSource, b_n_mode;
  rtd rho2;
  rtd x, y, z, x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;

  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  //  iCoordSys = blockIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  j = ij;
  ij += iSource*N_RAY;
  b_n_mode = max_n*(max_n+1)*0.5;
  if  ( ( j<N_RAY ) && (d__ray[ij].v) )// & (iCoordSys<1) )
  {

    for (iCoordSys=0; iCoordSys<7; iCoordSys++)
      {

	d__origin = d__conic_self_origin[iCoordSys];

        <<from global CS to motion CS>>

	<<from motion CS to aperture intersection>>

	if (rho2<=outer2)
	  {
	    mask[ij] = 1;
	    d__piston_mask[ij] = iCoordSys + 1;

            <<from motion CS to conic intersection and back to global CS>>
	    d__ray[ij].optical_path_difference += 
		d__ray[ij].optical_path_length - d__chief_ray[iSource].optical_path_length;
	    return;
	  }
      }
  }
}
@ and the chief ray kernel
<<GMT chief ray tracing kernel>>=
__global__ void m1_trace_chief_kernel(char *mask, ray *d__ray, int N_RAY, 
				      rtd *d__conic_R, vector *d__conic_origin,
				      const rtd Fk, const rtd Fc,
				      vector *d__conic_self_origin,
				      rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				      rtd *d__motion_R, vector *d__motion_origin,
				      int max_n, int n_mode,
				      rtd *d__a, rtd *d__cx, rtd *d__cy, rtd R)
{
  int j, ij, iCoordSys, iSource;
  rtd x1, y1, s0, k, l, m;
  rtd s1, S, K, L ,M, dSds;
  rtd G2, a;
  vector d__origin, xyz, klm, xyz_GS, klm_GS;

  iSource = blockIdx.z;
  ij = iSource*N_RAY;
  iCoordSys = 0;

  d__origin = d__conic_self_origin[iCoordSys];

  <<from global CS to rigid body CS>>

  <<from motion CS to conic CS>>
  <<GMT intersection with conic>>
  <<reflection from the surface>>
  <<from conic CS to motion CS>>
  <<from rigid body CS to global CS>>

}
@ The following is a test routine to validate the sequence of transformation in the ray tracing kernel:
<<GMT M1 functions>>=
void gmt_m1::test_ray_tracing(void)
{
  int iCoordSys;
  vector in, out;

  in.x = 8.71*cos(PI/6);
  in.y = 8.71*sin(PI/6);
  in.z = 0.0;

  printf("Output vector:\n");
  for (iCoordSys = 0; iCoordSys<N; iCoordSys++)
    {
      printf(" #%d\n",iCoordSys);
        forward_transform(&out, &in,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        forward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	backward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

	forward_transform_centered(&out, &out,
				    conic_CS.R+iCoordSys*9);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          motion_CS.R+iCoordSys*9,
                          motion_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x,out.y,out.z);

        backward_transform(&out, &out,
                          rigid_body_CS.R+iCoordSys*9,
                          rigid_body_CS.origin+iCoordSys);
        printf(". x = %.2e ; y = %.2e ; z = %.2e\n",out.x-in.x,out.y-in.y,out.z-in.z);
    }
    
}
@ 
The transformation of the coordinates and directions of the rays is performed in 3 steps, 
<<from global CS to motion CS>>=
<<from global CS to rigid body CS>>
<<from rigid body CS to motion CS>>
@ (i) the rays are transformed into the CS of the segment,
<<from global CS to rigid body CS>>=
// RIGID BODY >>> 
forward_transform(&xyz_GS, &(d__ray[ij].coordinates),
		  d__rigid_body_R+iCoordSys*9, d__rigid_body_origin+iCoordSys);
forward_transform_centered(&klm_GS, &(d__ray[ij].directions),
			   d__rigid_body_R+iCoordSys*9);
@ (ii) the segments are perturbed
<<from rigid body CS to motion CS>>=
// MOTION >>>  
forward_transform(&xyz_GS, &xyz_GS,
		  d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
forward_transform_centered(&klm_GS, &klm_GS,
			    d__motion_R+iCoordSys*9);
@  and (iii) the rays are transformed into the CS of the aperture:
<<from motion CS to aperture intersection>>=
// APERTURE >>>
forward_transform(&xyz, &xyz_GS,
		  d__aperture_R+iCoordSys*9,
		  d__aperture_origin+iCoordSys);
forward_transform_centered(&klm, &klm_GS,
			   d__aperture_R+iCoordSys*9);
 
	x = xyz.x;
	y = xyz.y;
	z = xyz.z;
	k = klm.x;
	l = klm.y;
	m = klm.z;

        <<GMT intersection with aperture plane>>

        rho2 = x1*x1 + y1*y1;
	if ( (iCoordSys==6) && (rho2<inner2) )
	  {
	    return;
	  }
@
The intersection with and reflection from the surface is done with
<<from motion CS to conic intersection and back to global CS>>=
<<from motion CS to conic CS>>
<<GMT intersection with aspheric>>
<<reflection from the surface>>
<<from conic CS to motion CS>>
<<from motion CS to rigid body CS>>
<<from rigid body CS to global CS>>
@ 
<<from motion CS to conic CS>>=
// CONIC >>>
backward_transform_centered(&xyz, &xyz_GS,
			    d__conic_R+iCoordSys*9);
backward_transform_centered(&klm, &klm_GS,
			    d__conic_R+iCoordSys*9);
@ 
<<reflection from the surface>>=
G2 = K*K + L*L + M*M;
a  = k*K + l*L + m*M;

a *= -2.0/G2;
klm.x += a*K;
klm.y += a*L;
klm.z += a*M;
@ 
<<from conic CS to motion CS>>=
 // CONIC <<<
 forward_transform_centered(&xyz_GS, &xyz,
			    d__conic_R+iCoordSys*9);
 forward_transform_centered(&klm_GS, &klm,
			    d__conic_R+iCoordSys*9);
@ 
<<from motion CS to rigid body CS>>=
 // MOTION <<<
 backward_transform(&xyz_GS, &xyz_GS,
		    d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
 backward_transform_centered(&klm_GS, &klm_GS,
			     d__motion_R+iCoordSys*9);
@ 
<<from rigid body CS to global CS>>=
 // RIGID_BODY <<<
 backward_transform(&(d__ray[ij].coordinates), &xyz_GS,
		    d__rigid_body_R+iCoordSys*9,
		    d__rigid_body_origin+iCoordSys);
 backward_transform_centered(&(d__ray[ij].directions), &klm_GS,
			     d__rigid_body_R+iCoordSys*9);

@
The vignetting by the aperture is computed as the intersection between the aperture mask and the ray vignetting flags: 
<<aperture intersection>>=
__global__ void intersection(char *mask, ray *d__ray, int N_RAY)
{
  int i, j, ij, iSource;
  i = blockIdx.x * blockDim.x + threadIdx.x;
  j = threadIdx.y;
  ij = j * gridDim.x * blockDim.x + i;
  iSource = blockIdx.z;
  if  ( ij<N_RAY )
  {
    ij += iSource*N_RAY;
    d__ray[ij].v &= mask[ij];
  }
}
@
The intersection with the aperture plane is computed with
<<GMT intersection with aperture plane>>=
if (m==0) { return; }
s0 = -z/m;
x1 = x + k*s0;
y1 = y + l*s0;
@ 
The intersection with the plane $z=0$ in the conic coordinate transformed is computed with  
<<GMT intersection with aspheric>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length = s0;
s0 = s1 = 0;
for (j=0; j<SNELL_N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  <<aspheric surface>>
  <<aspheric surface derivatives>>
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      <<aspheric surface derivatives>>
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@ 
<<aspheric surface>>=
S = aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                     d__a + iCoordSys*n_mode, R);
@
<<aspheric surface derivatives>>=
K = partial_x_aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                               d__cx + iCoordSys*b_n_mode, R);
L = partial_y_aspheric_surface(&xyz, &d__origin, Fk, Fc, max_n, 
                               d__cy + iCoordSys*b_n_mode, R);
M = partial_z_aspheric_surface();
@
<<GMT intersection with conic>>=
k  = klm.x;
l  = klm.y;
m  = klm.z;
if (m==0) { return; }
s0 = -xyz.z/m;
x1 = xyz.x + k*s0;
y1 = xyz.y + l*s0;
d__ray[ij].optical_path_length = s0;
s0 = s1 = 0;
for (j=0; j<SNELL_N_ITERATION; j++)
{
  xyz.x = x1 + k*s0;
  xyz.y = y1 + l*s0;
  xyz.z = m*s0;
  <<conic surface>>
  <<conic surface derivatives>>
  dSds = K*k + L*l + M*m;
  if (dSds==0) { break; }
  s1 = s0 - S/dSds;
  if (abs(s1-s0)<TOL)
    {
      xyz.x = x1 + k*s1;
      xyz.y = y1 + l*s1;
      xyz.z = m*s1;
      <<conic surface derivatives>>
      d__ray[ij].optical_path_length += s1;
      d__ray[ij].n_iteration = j;
      break;
    }
  s0 = s1;
}
@ 
<<conic surface>>=
S = conic_surface(&xyz, &d__origin, Fk, Fc);
@
<<conic surface derivatives>>=
K = partial_x_conic_surface(&xyz, &d__origin, Fk, Fc);
L = partial_y_conic_surface(&xyz, &d__origin, Fk, Fc);
M = partial_z_conic_surface();
@
\subsection{Mirror location tracker}
\label{sec:mirr-locat-track}

The track function transforms the coordinates $(x,y,0)$ in the motion CS of segment [[idx]] to the GCS.

\index{gmtMirrors!gmt\_m1!track}
<<GMT M1 functions>>=
void gmt_m1::track(float *d__x, float *d__y, int N, int idx)
{
  <<GMT track common>>
}
@  with
<<GMT track common>>=
dim3 blockDim(N_THREAD,1);
dim3 gridDim(N/N_THREAD+1,1);
track_kernel LLL gridDim, blockDim RRR (d__x, d__y, N,
					idx,
					rigid_body_CS.d__R,
					rigid_body_CS.d__origin,
					motion_CS.d__R,
					motion_CS.d__origin);
@ and
<<GMT track kernel>>= 
__global__ void track_kernel(float *x, float *y, const int N,
			     const int iCoordSys,
			     rtd *d__rigid_body_R, vector *d__rigid_body_origin,
			     rtd *d__motion_R, vector *d__motion_origin)
 {
   int i;
   vector v;
   i = blockIdx.x * blockDim.x + threadIdx.x;
   if (i<N) {
     v.x = x[i];
     v.y = y[i];
     v.z = 0.0;
     // MOTION <<<
     backward_transform(&v, &v,
			d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
     // RIGID_BODY <<<
     backward_transform(&v, &v,
			d__rigid_body_R+iCoordSys*9,
			d__rigid_body_origin+iCoordSys);
     x[i] = v.x;
     y[i] = v.y;
   }
}

@ 
\subsection{Global tip--tilt}
\label{sec:global-tip-tilt}

\def\ijk{\ensuremath{\left[\vec i,\vec j, \vec k\right]}}
\def\uvw{\ensuremath{\left[\vec u,\vec v, \vec w\right]_k}}
\def\uvwp{\ensuremath{\left[\vec u^\prime,\vec v^\prime, \vec w^\prime\right]}}
\def\RS{\ensuremath{R_{{\cal S},k}}}
\def\RT{\ensuremath{R_{\cal T}}}
\def\RM{\ensuremath{R_{\cal M}}}

The GCS is defined with the 3 ortho--normal unit vectors \ijk.
The segment coordinate systems also called rigid body CSs are defined with the 3 ortho-normal vectors \uvw.
\uvw are derived from \ijk with the matrix \RS
\begin{equation}
  \label{eq:3}
  \uvw = \RS^T \ijk.
\end{equation}
Within the rigid body CSs, motion CSs (\uvwp) are defined with
\begin{equation}
  \label{eq:4}
  \uvwp = \RM^T \uvw = \RM^T \RS^T \ijk,
\end{equation}
where \RM is the 3D rotation matrix of each segment.

When a global tip--tilt is applied to M1, \ijk becomes $\RT^T\ijk$ with \RT the tip--tilt matrix, and the motion CSs are given by
\begin{equation}
  \label{eq:5}
  \uvwp = \RS^T\RT^T\ijk.
\end{equation}

From Eq.~(\ref{eq:4}) and Eq.~(\ref{eq:5}), the 3D rotation matrix of each segment as a result of a global tip--tilt is given by
\begin{equation}
  \label{eq:6}
  \RM = \RS^T \RT \RS.
\end{equation}
<<global tip-tilt transformation>>=
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_N,
	     3,3,3,
	     &alpha,
	     rigid_body_CS.d__R+k9, 3,
	     TT_CS.d__R, 3,
	     &beta,
	     d__C, 3);
 cublasDgemm(handle,
	     CUBLAS_OP_N, CUBLAS_OP_T,
	     3,3,3,
	     &alpha,
	     d__C, 3,
	     rigid_body_CS.d__R+k9, 3,
	     &beta,
	     motion_CS.d__R+k9, 3);

 HANDLE_ERROR( cudaMemcpy( motion_CS.R+k9, motion_CS.d__R+k9, 
			   sizeof(double)*9, cudaMemcpyDeviceToHost ) );
 /* 
 int i, j, idx = 0;
for (i=0;i<3;i++)
   {
     fprintf(stdout,"||  ");
     for (j=0;j<3;j++)
       {
	 idx = j + i*3 + k9;
	 fprintf(stdout,"%+.4e  ",motion_CS.R[idx]);
       }
     fprintf(stdout,"||\n");
   }
 */
@
From \RM, the Euler angles corresponding to the 3 rotations of each segment are derived
\begin{eqnarray}
  \label{eq:7}
  \alpha &=& \arctan\left( \RM(32) \over \RM(33) \right) \\\nonumber
  \beta  &=& \arcsin\left( -\RM(31) \right) \\\nonumber
  \gamma &=& \arctan\left( \RM(21) \over \RM(11) \right) 
\end{eqnarray}
<<global tip-tilt transformation>>=
motion_CS.euler_angles[k].x = atan2(motion_CS.R[7+k9],motion_CS.R[8+k9]);
motion_CS.euler_angles[k].y = asin(-1.0*motion_CS.R[6+k9]);
motion_CS.euler_angles[k].z = atan2(motion_CS.R[3+k9],motion_CS.R[k9]);
@
The tip--tilt transformation is also applied to the origin of each segment $\vec O_k$ and the difference between the two origins is the translation of the motion CS, i.e.
\begin{equation}
  \label{eq:8}
  \vec O_k^\prime = \vec O_k - \vec O_R - \RT^T\left( \vec O_k -\vec O_R \right)
\end{equation}
where $\vec O_R$ is the rotation point.
<<global tip-tilt transformation>>=
 forward_transform(motion_CS.origin + k, rigid_body_CS.origin + k,
		   TT_CS.R, TT_CS.origin);
 motion_CS.origin[k].x = rigid_body_CS.origin[k].x - TT_CS.origin->x - motion_CS.origin[k].x;
 motion_CS.origin[k].y = rigid_body_CS.origin[k].y - TT_CS.origin->y - motion_CS.origin[k].y;
 motion_CS.origin[k].z = rigid_body_CS.origin[k].z - TT_CS.origin->z - motion_CS.origin[k].z;
 forward_transform_centered(motion_CS.origin + k, motion_CS.origin + k, rigid_body_CS.R + k9);
 HANDLE_ERROR( cudaMemcpy( motion_CS.d__origin+k, motion_CS.origin+k, 
			   sizeof(vector), cudaMemcpyHostToDevice ) );

/*
 fprintf(stdout,"#%d >> MOTION CS origins [micron]  : %+.3e, %+.3e, %+.3e\n",k,
	 motion_CS.origin[k].x*1e6,
	 motion_CS.origin[k].y*1e6,
	 motion_CS.origin[k].z*1e6);

 float r2d;
 r2d = 1000*3600*180.0/PI;
 fprintf(stdout,"#%d >> MOTION CS Euler angles [mas]: %+.3e, %+.3e, %+.3e\n",k,
	 r2d*motion_CS.euler_angles[k].x,
	 r2d*motion_CS.euler_angles[k].y,
	 r2d*motion_CS.euler_angles[k].z);
*/
@ 
\index{gmtMirrors!gmt\_m1!global\_tiptilt}
<<GMT M1 functions>>=
void gmt_m1::global_tiptilt(float tip, float tilt)
{
  <<GMT global tip-tilt common>>
}    
@  with
<<GMT global tip-tilt setup>>=
sprintf(tag,"GLOBAL TIP-TILT");
vector TT_CS_origin, TT_CS_euler_angles;
TT_CS_origin.x = TT_CS_origin.y = TT_CS_origin.z = 0.0;
TT_CS_euler_angles.x = TT_CS_euler_angles.y = TT_CS_euler_angles.z = 0.0;
TT_CS.setup(&TT_CS_origin, &TT_CS_euler_angles, 1, tag);
cublasCreate(&handle);
HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
@
<<GMT global tip-tilt cleanup>>=
TT_CS.cleanup();
cublasDestroy(handle);
HANDLE_ERROR( cudaFree( d__C ) );
@  and 
<<GMT global tip-tilt common>>=
double alpha, beta;
alpha = 1.0;
beta  = 0.0;
int k, k9;
vector origin, euler_angles;
origin.x = origin.y = origin.z = 0.0;
euler_angles.x = tip;
euler_angles.y = tilt;
euler_angles.z = 0.0;
TT_CS.update(origin,euler_angles,0);
for (k=0;k<N;k++)
  {
    k9 = k*9;
    <<global tip-tilt transformation>>
  }
@ 
@
\section{Edge sensors}
\label{sec:edge-sensors}

\index{gmtMirrors!gmt\_m1!edge\_sensors}
Edge sensors are set on the rim of each segment.
12 edges sensors are located on the central segment.
Pairs of edge sensor are at an angle $\pm \alpha$ with respect to the line joining the center of the segment to the center of the peripheral segment.
The coordinates of the edge sensor in the rigid body CS are
\begin{equation}
  \label{eq:9}
  \left|
  \begin{array}{c}
    l_{7,k} \\
    r_{7,k}
  \end{array}
  \right|
   = {1\over 2}[[D_full]]\exp\left(i \left( {\pi(3-2k)\over 6} \pm \alpha  \right)\right), \forall k=0,\dots,5.
\end{equation}
Each peripheral segment has 2 pairs of edge sensors facing the adjacent peripheral segments.
The coordinates of the edge sensors of a peripheral segment in the rigid body CS are:
\begin{eqnarray}
  \label{eq:10}
  \left|
  \begin{array}{c}
    l_{k,3} \\
    r_{k,3}
  \end{array}
  \right|
   &=& {1\over 2}[[D_full]]\exp\left(i \left( -{\pi\over 6} \pm \alpha \right) \right), \\
  \left|
  \begin{array}{c}
    l_{k,5} \\
    r_{k,5}
  \end{array}
  \right|
   &=& {1\over 2}[[D_full]]\exp\left(i  \left( -{5\pi\over 6} \pm \alpha \right) \right). 
\end{eqnarray}
Each peripheral segment has also a pair of edge sensor facing the central segment whose coordinates, in the rigid body CS, are:
\begin{equation}
  \label{eq:11}
  \left|
  \begin{array}{c}
    l_{k,4} \\
    r_{k,4}
  \end{array}
  \right|
   = {1\over 2}[[D_full]]\exp\left(i \left( -{\pi\over 2} \pm \alpha \right) \right).  
\end{equation}
The heights of the edge sensors are $z=0$ in the rigid body CS of the segment they belong to.

\begin{figure}
\begin{center}
\input{edgeSensor.tex}
\end{center}  
  \caption{Edge sensor layout.}
  \label{fig:edge_sensor}
\end{figure}

\subsection{Stereoscopic model}
\label{sec:stereoscopic-model}

\index{gmtMirrors!stereoscopic\_edge\_sensors}

<<stereoscopic edge sensors structure>>=
struct stereoscopic_edge_sensors {
<<stereoscopic edge sensors parameters>>
void setup(gmt_m1 *_mirror_);
void cleanup(void);
void data(void);
};
@  with
\index{gmtMirrors!stereoscopic\_edge\_sensors!setup}
\index{gmtMirrors!stereoscopic\_edge\_sensors!cleanup}
\index{gmtMirrors!stereoscopic\_edge\_sensors!data}
<<stereoscopic edge sensors functions>>=
void stereoscopic_edge_sensors::setup(gmt_m1 *_mirror_) 
{
  <<stereoscopic edge sensors setup>>
}
void stereoscopic_edge_sensors::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>stereoscopic_edge_sensors: freeing memory!\n");
  <<stereoscopic edge sensors cleanup>>
}
void stereoscopic_edge_sensors::data(void) 
{
  <<stereoscopic edge sensors measurements>>
}
@ 
The total number of unique edge sensors coordinates in the rigid body CS is 18 whose 12 are on the central segment and 6 on the peripheral segments leading to a total of 48 edge sensors coordinates in the GCS and 24 edge sensor mesurements.
<<stereoscopic edge sensors parameters>>=
int N, N_DATA;
int n_byte, n_byte_DATA;
<<stereoscopic edge sensors setup>>=
N = 48;
N_DATA = 24;
n_byte      = sizeof(vector)*N;
n_byte_DATA = sizeof(vector)*N_DATA;
@ The $\alpha$ angle is set to 19.5degree
<<stereoscopic edge sensors parameters>>=
rtd alpha;
<<stereoscopic edge sensors setup>>=
alpha = 19.5;
@ The mirror the edge sensors are affected to is
<<stereoscopic edge sensors parameters>>=
gmt_m1 *mirror;
<<stereoscopic edge sensors setup>>=
mirror = _mirror_;
@
The coordinates of the edge sensors in the GCS are saved in the vectors [[d__v0]] for a perfectly aligned telescope and in the vectors [[d__v]] for a perturbed telescope.
<<stereoscopic edge sensors parameters>>=
vector *v0, *v, *d__v0, *d__v;
<<stereoscopic edge sensors setup>>=
v0 = (vector *)malloc(n_byte);
v  = (vector *)malloc(n_byte);
HANDLE_ERROR( cudaMalloc((void**)&d__v0, n_byte ) );
HANDLE_ERROR( cudaMalloc((void**)&d__v,  n_byte ) );
<<stereoscopic edge sensors cleanup>>=
free( v0 );
free( v );
HANDLE_ERROR( cudaFree( d__v0 ) );
HANDLE_ERROR( cudaFree( d__v ) );
@
The edge sensor 24 measurements are saved in the vector [[d__dv0]] and [[d__dv]] for a perfectly aligned and perturbed telescope, respectively.
<<stereoscopic edge sensors parameters>>=
vector *dv0, *d__dv0;
vector *dv, *d__dv;
<<stereoscopic edge sensors setup>>=
dv0  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__dv0, n_byte_DATA ) );
dv  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__dv, n_byte_DATA ) );
<<stereoscopic edge sensors cleanup>>=
free( dv0 );
HANDLE_ERROR( cudaFree( d__dv0 ) );
free( dv );
HANDLE_ERROR( cudaFree( d__dv ) );
@
The edge sensor coordinates in the GCS are computed with:
<<stereoscopic edge sensors setup>>=
fprintf(stdout,"@(CEO)>gmt_m1: Initializing edge sensors coordinates!\n");
dim3 blockDim(6,1);
dim3 gridDim(1,1);
edge_sensors_read LLL gridDim, blockDim RRR (d__v0, mirror->N-1, mirror->D_full, alpha,
					     mirror->rigid_body_CS.d__R,
                                             mirror->rigid_body_CS.d__origin,
                                             mirror->motion_CS.d__R,
                                             mirror->motion_CS.d__origin);
HANDLE_ERROR( cudaMemcpy( v0, d__v0,
                          n_byte, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemcpy( d__v, d__v0,
                          n_byte, cudaMemcpyDeviceToDevice ) );
HANDLE_ERROR( cudaMemcpy( v, d__v,
                          n_byte, cudaMemcpyDeviceToHost ) );
@  and the reference measurements with:
<<stereoscopic edge sensors setup>>=
HANDLE_ERROR( cudaMemset(d__dv0, 0, n_byte_DATA ) );
edge_sensors_data_kernel LLL gridDim, blockDim RRR (d__dv,
                                                   d__v,
                                                   d__dv0,
                                                   mirror->N-1);
HANDLE_ERROR( cudaMemcpy( d__dv0, d__dv, 
                          n_byte_DATA, cudaMemcpyDeviceToDevice ) );
HANDLE_ERROR( cudaMemcpy( dv0, d__dv0, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemset(d__dv, 0, n_byte_DATA ) );
HANDLE_ERROR( cudaMemcpy( dv, d__dv, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@ with
<<stereoscopic edge sensors initialization kernel>>=
__global__ void edge_sensors_read(vector *v, const int N_OUT_SEGMENT, 
				   const rtd D, const rtd alpha,
				   rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				   rtd *d__motion_R, vector *d__motion_origin)
{
  int i, iCoordSys, k;
  rtd R, a, offset_angle;
  i = threadIdx.x;
  if (i<N_OUT_SEGMENT)
  {
    R = 0.5*D;
    a = alpha/180;

    <<central segment edge sensors new>>

    __syncthreads();

    <<outer segment edge sensors new>>

  }
}
@ 
First the coordinates $l_{7,k}$ are computed,
<<central segment edge sensors new>>=
iCoordSys = 6;
k = i;
offset_angle = (3.0-2.0*i)/6.0 + a;
<<edge sensor coordinates>>
@
followed by the coordinates $r_{7,k}$
<<central segment edge sensors new>>=
k             += N_OUT_SEGMENT;
offset_angle = (3.0-2.0*i)/6.0 - a;
<<edge sensor coordinates>>
@
The coordinates of the edge sensors of segment \# $k=[[iCoordSys]]$ are computed next, starting with  $l_{k,4}$ and $r_{k,4}$:
<<outer segment edge sensors new>>=
iCoordSys    = i;
k            = 2*N_OUT_SEGMENT + i;
offset_angle = -0.5 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -0.5 - a;
<<edge sensor coordinates>>
@ then $l_{k,3}$ and $r_{k,3}$:
<<outer segment edge sensors new>>=
k += 6;
offset_angle = -1.0/6.0 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -1.0/6.0 - a;
<<edge sensor coordinates>>
@ and finally $l_{k,5},$ and $r_{k,5}$:
<<outer segment edge sensors new>>=
k += 6;
offset_angle = -5.0/6.0 + a;
<<edge sensor coordinates>>
k += 6;
offset_angle = -5.0/6.0 - a;
<<edge sensor coordinates>>
@ 
The coordinates are first calculated in the motion CS,
<<edge sensor coordinates>>=
sincospi( offset_angle, &(v[k].y), &(v[k].x) );
v[k].x       *= R;
v[k].y       *= R;
v[k].z       = 0.0;
@ 
then they are transformed from the motion CS to the rigid body CS,
<<edge sensor coordinates>>=
// MOTION <<<
backward_transform(v+k, v+k,
		   d__motion_R+iCoordSys*9, d__motion_origin+iCoordSys);
@ 
and finally, they are transformed from the rigid body CS to the GCS.
<<edge sensor coordinates>>=
// RIGID_BODY <<<
backward_transform(v+k, v+k,
		   d__rigid_body_R+iCoordSys*9,
		   d__rigid_body_origin+iCoordSys);
@ 
The edge sensor measurements consist in the coordinates of the vector joining pair of edge sensors.
The edge sensors coordinates are stored in the [[d__v0]] and  [[d__v0]] arrays as shown in the diagram below.
The vectors linking pairs of edge sensors are also drawn.

\begin{tikzpicture}[>=stealth',node distance=2cm,edge sensor block/.style={draw, anchor=base, minimum height=7mm,minimum width=2cm}]
  \node[edge sensor block] (l7k) {$l_{7,k}$};
  \node[edge sensor block, right of=l7k] (r7k) {$r_{7,k}$};
  \node[edge sensor block, right of=r7k] (lk4) {$l_{k,4}$};
  \node[edge sensor block, right of=lk4] (rk4) {$r_{k,4}$};
  \node[edge sensor block, right of=rk4] (lk3) {$l_{k,3}$};
  \node[edge sensor block, right of=lk3] (rk3) {$r_{k,3}$};
  \node[edge sensor block, right of=rk3] (lk5) {$l_{k,5}$};
  \node[edge sensor block, right of=lk5] (rk5) {$r_{k,5}$};
  \draw[->] (l7k.north) to [out=30,in=150] (rk4.north);
  \draw[->] (r7k.south) to [out=-90,in=-90] (lk4.south);
  \draw[->] (lk3.north) to [out=30,in=150] (rk5.north);
  \draw[->] (rk3.south) to [out=-90,in=-90] (lk5.south);
  \draw[blue!20] ($(l7k.south west)-(2mm,2mm)$) rectangle ($(rk5.north east)+(2mm,2mm)$);
 \end{tikzpicture}

They measurements are computed with
<<stereoscopic edge sensors measurements>>=
dim3 blockDim(6,1);
dim3 gridDim(1,1);
edge_sensors_read LLL gridDim, blockDim RRR (d__v, mirror->N-1, mirror->D_full, alpha,
       					     mirror->rigid_body_CS.d__R,
                                             mirror->rigid_body_CS.d__origin,
                                             mirror->motion_CS.d__R,
                                             mirror->motion_CS.d__origin);
edge_sensors_data_kernel LLL gridDim, blockDim RRR (d__dv,
						     d__v,
						     d__dv0,
						     mirror->N-1);
HANDLE_ERROR( cudaMemcpy( dv, d__dv,
			    sizeof(vector)*N_DATA, cudaMemcpyDeviceToHost ) );
@  
with the kernel
<<stereoscopic edge sensors data kernel>>=
__global__ void edge_sensors_data_kernel(vector *d__dv, 
					vector *d__v, 
					vector *d__dv0, 
					const int N_OUT_SEGMENT)
{
  int k;
  k = threadIdx.x;
  if (k<N_OUT_SEGMENT)
    {
      d__dv[k]                 =
      	d__v[k+3*N_OUT_SEGMENT] - 
        d__v[k] - 
        d__dv0[k];
      d__dv[k+  N_OUT_SEGMENT] =
      	d__v[k+2*N_OUT_SEGMENT] - 
        d__v[k+  N_OUT_SEGMENT] - 
        d__dv0[k+N_OUT_SEGMENT];
      d__dv[k+2*N_OUT_SEGMENT] =
      	d__v[(k+1)%6+7*N_OUT_SEGMENT] - 
        d__v[k+4*N_OUT_SEGMENT] - 
        d__dv0[k+2*N_OUT_SEGMENT];
      d__dv[k+3*N_OUT_SEGMENT] =
      	d__v[(k+1)%6+6*N_OUT_SEGMENT] - 
        d__v[k+5*N_OUT_SEGMENT] - 
        d__dv0[k+3*N_OUT_SEGMENT];
    }
}
@ 

\subsection{Lateral displacement model}
\label{sec:later-displ-model}

\index{gmtMirrors!lateral\_edge\_sensors}

<<lateral edge sensors structure>>=
struct lateral_edge_sensors {
<<lateral edge sensors parameters>>
void setup(gmt_m1 *_mirror_);
void setup(gmt_m1 *_mirror_, rtd _height_);
void cleanup(void);
void data(void);
};
@  with
\index{gmtMirrors!lateral\_edge\_sensors!setup}
\index{gmtMirrors!lateral\_edge\_sensors!cleanup}
\index{gmtMirrors!lateral\_edge\_sensors!data}
<<lateral edge sensors functions>>=
void lateral_edge_sensors::setup(gmt_m1 *_mirror_) 
{
  N_HEIGHT = 1;
  height = 0.0;
  <<lateral edge sensors setup>>
}
void lateral_edge_sensors::setup(gmt_m1 *_mirror_, rtd _height_) 
{
  N_HEIGHT = 2;
  height = _height_;
  <<lateral edge sensors setup>>
}
void lateral_edge_sensors::cleanup(void) 
{
  fprintf(stdout,"@(CEO)>lateral_edge_sensors: freeing memory!\n");
  <<lateral edge sensors cleanup>>
}
void lateral_edge_sensors::data(void) 
{
  <<lateral edge sensors measurements>>
}
@ 
The lateral displacement model represents the case where a laser on one segment is aimed to a camera on an adjacent segment.
The camera returns the position of the laser beam in the detector frame.
%The difference between the current position of the laser beam and the position of the laser beam for a perfectly aligned telescope gives 

Looking at Fig.~\ref{fig:edge_sensor}, each vector between pairs of edge sensors is a laser.
The tail of the vector corresponds to the location where the laser is fired from and the head of the vector corresponds to the center of the camera.

The total number of unique edge sensors coordinates in the rigid body CS is 18 whose 12 are on the central segment and 6 on the peripheral segments leading to a total of 48 edge sensors coordinates in the GCS and 24 edge sensor mesurements.
<<lateral edge sensors parameters>>=
int N, N_DATA, N_HEIGHT;
<<lateral edge sensors setup>>=
//N = 48;
N_DATA = 24*N_HEIGHT;
@ The $\alpha$ angle is set to 19.5degree
<<lateral edge sensors parameters>>=
rtd alpha;
<<lateral edge sensors setup>>=
alpha = 19.5;
@ The [[height]] of the edge sensor in the rigid body CS of the segment they are attached to.
If $[[N_HEIGHT]]=2$, then 2 edge sensors are set a $\pm[[height]]$; otherwise $[[N_HEIGHT]]=1$ and $[[height]]=0$
<<lateral edge sensors parameters>>=
rtd height;
@ The mirror the edge sensors are affected to is
<<lateral edge sensors parameters>>=
gmt_m1 *mirror;
<<lateral edge sensors setup>>=
mirror = _mirror_;
@
The edge sensors have two components: a laser on one segment edge and a camera on another segment edge.
The location of the lasers are given by the vectors $l_{7,k}$, $r_{7,k}$, $l_{k,3}$ and $r_{k,3}$.
The location of the cameras are given by the vectors $l_{k,4}$, $r_{k,4}$, $l_{k,5}$ and $r_{k,5}$.
 
The coordinates of the vectors joining pairs of edge sensors are saved in the vector [[d__k0_cam]] and [[d__k0_laser]] for a perfectly aligned telescope in the rigid body CS of their segments.
<<lateral edge sensors parameters>>=
int n_byte_DATA;
rtd *x, *y, *d__x, *d__y, *d, *d__d;
vector *k_cam, *d__k_cam;
vector *k_laser, *d__k_laser;
vector *uP, *d__uP;
vector *vP, *d__vP;
@
<<lateral edge sensors setup>>=
n_byte_DATA = sizeof(vector)*N_DATA;
k_cam  = (vector *)malloc(n_byte_DATA);
k_laser  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__k_cam, n_byte_DATA ) );
HANDLE_ERROR( cudaMalloc((void**)&d__k_laser, n_byte_DATA ) );
uP  = (vector *)malloc(n_byte_DATA);
vP  = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__uP, n_byte_DATA ) );
HANDLE_ERROR( cudaMalloc((void**)&d__vP, n_byte_DATA ) );
x  = (rtd*)malloc(sizeof(rtd)*N_DATA);
y  = (rtd*)malloc(sizeof(rtd)*N_DATA);
d  = (rtd*)malloc(sizeof(rtd)*N_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__x, sizeof(rtd)*N_DATA ) );
HANDLE_ERROR( cudaMalloc((void**)&d__y, sizeof(rtd)*N_DATA ) );
HANDLE_ERROR( cudaMalloc((void**)&d__d, sizeof(rtd)*N_DATA ) );
@
<<lateral edge sensors cleanup>>=
free( k_cam );
free( k_laser );
HANDLE_ERROR( cudaFree( d__k_cam ) );
HANDLE_ERROR( cudaFree( d__k_laser ) );
free( uP );
free( vP );
HANDLE_ERROR( cudaFree( d__uP ) );
HANDLE_ERROR( cudaFree( d__vP ) );
free( x );
free( y );
free( d );
HANDLE_ERROR( cudaFree( d__x ) );
HANDLE_ERROR( cudaFree( d__y ) );
HANDLE_ERROR( cudaFree( d__d ) );
@
\def\aO{A^i_0}
\def\aOi{A^i_{0i}}
\def\kOi{\mathbf{k^i_{0i}}}
\def\kOj{\mathbf{k^i_{0j}}}
\def\kOjx{{k^i_{0j,x}}}
\def\kOjy{{k^i_{0j,y}}}
\def\kOjz{{k^i_{0j,z}}}
\def\kj{\mathbf{k^i_{j}}}
\def\kjx{{k^i_{j,x}}}
\def\kjy{{k^i_{j,y}}}
\def\kjz{{k^i_{j,z}}}
\def\aOj{A^i_{0j}}
\def\aOjx{A^i_{0jx}}
\def\aOjy{A^i_{0jy}}
\def\aOjz{A^i_{0jz}}
\def\aj{A^i_{j}}
\def\ajx{A^i_{j,x}}
\def\ajy{A^i_{j,y}}
\def\ajz{A^i_{j,z}}
\def\bO{B^j_0}
\def\bOi{B^j_{0i}}
\def\bOj{B^j_{0j}}
\def\bOjx{B^j_{0j,x}}
\def\bOjy{B^j_{0j,y}}
\def\bOjz{B^j_{0j,z}}
\def\abO{\mathbf{AB}_0^{ij}}
\def\abOj{\mathbf{AB}_{0j}^{ij}}
\def\abOi{\mathbf{AB}_{0i}^{ij}}
\def\abOjx{\kOjx}
\def\abOjy{\kOjy}
\def\abOjz{\kOjz}
\def\camplane{\mathcal{P}_j}
\def\tlp{t_{\mathcal{LP}}}
\def\ilp{I^j_{\mathcal{LP}}}
\def\bi{\mathbf{BI^j_{0j,{\mathcal{LP}}}}}
\def\valpha{\boldsymbol{\alpha}}
\def\vbeta{\boldsymbol{\beta}}
\newcommand{\tocs}[3]{\mathrm{R}_{#1{#2}}\left(#3\right)}
\newcommand{\itocs}[3]{\mathrm{R}^{-1}_{#1{#2}}\left(#3\right)}

The coordinates transformation from one CS to another CS is noted $R_X$ where $X$ denote the final CS,
$X\equiv R$ for the rigid body CS [[rigid_body_CS]] and $X\equiv M$ for the motion CS [[motion_CS]].

\begin{figure}
  \centering
\begin{tikzpicture}[>=stealth',node distance=2cm,
  edge sensor camera/.style={draw, anchor=base, minimum height=7mm,minimum width=2cm,fill=blue!20},
  edge sensor laser/.style={draw, anchor=base, minimum height=7mm,minimum width=2cm,fill=red!20}]
  \begin{scope}[yshift=1cm]
    \node (B) {[[B]]};
    \node[edge sensor camera, label={[xshift=-4mm]above left:\scriptsize 0}, right of=B] (rk4) {$r_{k,4}$};
    \node[edge sensor camera, label={[xshift=-4mm]above left:\scriptsize 1}, right of=rk4] (lk4) {$l_{k,4}$};
    \node[edge sensor camera, label={[xshift=-4mm]above left:\scriptsize 2}, right of=lk4] (rk5) {$r_{k,5}$};
    \node[edge sensor camera, label={[xshift=-4mm]above left:\scriptsize 3}, right of=rk5] (lk5) {$l_{k,5}$};
  \end{scope}
  \begin{scope}[yshift=-1cm]
    \node (A) {[[A]]};
    \node[edge sensor laser, label={[xshift=-4mm]above left:\scriptsize 0}, right of=A] (l7k) {$l_{7,k}$};
    \node[edge sensor laser, label={[xshift=-4mm]above left:\scriptsize 1}, right of=l7k] (r7k) {$r_{7,k}$};
    \node[edge sensor laser, label={[xshift=-4mm]above left:\scriptsize 2}, right of=r7k] (lk3) {$l_{k,3}$};
    \node[edge sensor laser, label={[xshift=-4mm]above left:\scriptsize 3}, right of=lk3] (rk3) {$r_{k,3}$};
    % \draw[->] (l7k.north) to [out=30,in=150] (rk4.north);
    % \draw[->] (r7k.south) to [out=-30,in=-150] (lk4.south);
    % \draw[->] (lk3.north) to [out=30,in=150] (rk5.north);
    % \draw[->] (rk3.south) to [out=-30,in=-150] (lk5.south);
  \end{scope}
  \draw[->] (l7k.north) to (rk4.south);
  \draw[->] (r7k.north) to (lk4.south);
  \draw[->] (lk3.north) to (rk5.south);
  \draw[->] (rk3.north) to (lk5.south);
  \begin{scope}[on background layer]
    \fill[black!10] ($(B.south west)-(2mm,4mm)$) rectangle ($(lk5.north east)+(4mm,4mm)$);    
    \fill[black!10] ($(A.south west)-(2mm,4mm)$) rectangle ($(rk3.north east)+(4mm,4mm)$);    
  \end{scope}
  \node[right of=lk5] {Cameras};
  \node[right of=rk3] {Lasers};
\end{tikzpicture}  
  \caption{[[A]] and [[B]] vector arrays with $k=\left[1,\dots,6\right]$.}
  \label{fig:lateral-edge-sensors-1}
\end{figure}

The computation of the location of the laser on the camera requires to define both the camera plane and the line of sight between the camera and the laser when the telescope is perfectly aligned:
\begin{enumerate}
\item Lets define the camera plane $\camplane$ as being perpendicular to the line of sight of the laser:
  \begin{enumerate}
  \item Lets call $\bOj$, the coordinates of the camera location at segment \# $j$ in the rigid body CS of segment \# $j$;
    the coordinates are saved in the vector array [[B]] as show in Fig.~\ref{fig:lateral-edge-sensors-1}
  \item Lets call $\aOj$, the coordinates of the laser location at segment \# $i$ in the rigid body CS of segment \# $j$;
    the coordinates are saved in the vector array [[A]] as show in Fig.~\ref{fig:lateral-edge-sensors-1}
<<lateral edge sensors parameters>>=
vector *A, *A0, *B, *B0, *d__A, *d__A0, *d__B, *d__B0;
<<lateral edge sensors setup>>=
B = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__B, n_byte_DATA ) );
B0 = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__B0, n_byte_DATA ) );
A = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__A, n_byte_DATA ) );
A0 = (vector *)malloc(n_byte_DATA);
HANDLE_ERROR( cudaMalloc((void**)&d__A0, n_byte_DATA ) );
<<lateral edge sensors cleanup>>=
free( A );
free( A0 );
free( B );
free( B0 );
HANDLE_ERROR( cudaFree( d__A ) );
HANDLE_ERROR( cudaFree( d__A0 ) );
HANDLE_ERROR( cudaFree( d__B ) );
HANDLE_ERROR( cudaFree( d__B0 ) );
@
  \item Lets transform $\aOi$ into the rigid body CS of segment \# $j$:
    \begin{equation}
      \label{eq:12}
      \aOj = \tocs{R}{j}{\itocs{R}{i}{\aOi}},
    \end{equation}
@
<<lateral edge sensors setup>>=
fprintf(stdout,"@(CEO)>gmt_m1: Initializing edge sensors coordinates!\n");
dim3 blockDim(6,N_HEIGHT);
dim3 gridDim(1,1);
laser_coordinates LLL gridDim, blockDim RRR (d__A, mirror->N-1, mirror->D_full, 
					     alpha, height,
					     mirror->rigid_body_CS.d__R,
                                             mirror->rigid_body_CS.d__origin,
                                             mirror->motion_CS.d__R,
                                             mirror->motion_CS.d__origin);
HANDLE_ERROR( cudaMemcpy( A, d__A, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
laser_coordinates_to_GCS LLL gridDim, blockDim RRR (d__A0, d__A, mirror->N-1, 
                                                    mirror->rigid_body_CS.d__R,
                                                    mirror->rigid_body_CS.d__origin);
HANDLE_ERROR( cudaMemcpy( A0, d__A0, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@ 
 with
<<lateral edge sensors: laser coordinates kernel>>=
__global__ void laser_coordinates(vector *v, const int N_OUT_SEGMENT, 
				  const rtd D, 
				  const rtd alpha,
				  const rtd height,
				  rtd *d__rigid_body_R, vector *d__rigid_body_origin,
				  rtd *d__motion_R, vector *d__motion_origin)
{
  int i, j, iCoordSys_laser, iCoordSys_cam, k;
  rtd R, a, offset_angle;
  i = threadIdx.x;
  j = threadIdx.y;
  if (i<N_OUT_SEGMENT)
  {
    R = 0.5*D;
    a = alpha/180;
    <<central segment lateral edge sensors>>
    __syncthreads();
    <<outer segment lateral edge sensors>>
  }
}
@ $l_{7,k}$ and $r_{7,k}$:
<<central segment lateral edge sensors>>=
iCoordSys_laser = 6;
iCoordSys_cam   = i;
k = i + 24*j;
offset_angle = (3.0-2.0*i)/6.0 + a;
<<from motion CS to motion CS>>
k             += N_OUT_SEGMENT;
offset_angle = (3.0-2.0*i)/6.0 - a;
<<from motion CS to motion CS>>
@ $l_{k,3}$ and $r_{k,3}$:
<<outer segment lateral edge sensors>>=
iCoordSys_laser = i;
iCoordSys_cam   = (i+1)%N_OUT_SEGMENT;
k = 2*N_OUT_SEGMENT + i + 24*j;
offset_angle = -1.0/6.0 + a;
<<from motion CS to motion CS>>
k += 6;
offset_angle = -1.0/6.0 - a;
<<from motion CS to motion CS>>
@ 
<<polar to cartesian>>=
sincospi( offset_angle, &(v[k].y), &(v[k].x) );
v[k].x      *= R;
v[k].y      *= R;
v[k].z       = height;
<<from motion CS to motion CS>>=
<<polar to cartesian>>
v[k].z      *= (j==0) ? 1 : -1; 
// MOTION <<<
backward_transform(v+k, v+k,
		   d__motion_R+iCoordSys_laser*9,
                   d__motion_origin+iCoordSys_laser);
// RIGID_BODY <<<
backward_transform(v+k, v+k,
		   d__rigid_body_R+iCoordSys_laser*9,
		   d__rigid_body_origin+iCoordSys_laser);
// RIGID BODY >>> 
forward_transform(v+k, v+k,
		  d__rigid_body_R+iCoordSys_cam*9,
                  d__rigid_body_origin+iCoordSys_cam);
// MOTION >>>  
forward_transform(v+k, v+k,
		  d__motion_R+iCoordSys_cam*9,
                  d__motion_origin+iCoordSys_cam);
@ and
<<lateral edge sensors: laser coordinates to GCS kernel>>=
__global__ void laser_coordinates_to_GCS(vector *v0, vector *v, const int N_OUT_SEGMENT, 
				  rtd *d__rigid_body_R, vector *d__rigid_body_origin)
{
  int i, j, k;
  i = threadIdx.x;
  j = threadIdx.y;
  if (i<N_OUT_SEGMENT)
  {
    k = i + 24*j;
    // RIGID_BODY <<<
    backward_transform(v0+k, v+k,
                       d__rigid_body_R+i*9,
                       d__rigid_body_origin+i);
    k += N_OUT_SEGMENT;
    // RIGID_BODY <<<
    backward_transform(v0+k, v+k,
                       d__rigid_body_R+i*9,
                       d__rigid_body_origin+i);
    __syncthreads();
    k = 2*N_OUT_SEGMENT + i + 24*j;
    i = (i+1)%N_OUT_SEGMENT;
    // RIGID_BODY <<<
    backward_transform(v0+k, v+k,
                       d__rigid_body_R+i*9,
                       d__rigid_body_origin+i);
    k += N_OUT_SEGMENT;
    // RIGID_BODY <<<
    backward_transform(v0+k, v+k,
                       d__rigid_body_R+i*9,
                       d__rigid_body_origin+i);
  }
}
@
\item Lets compute the coordinates of $\bOj$ ([[B]]) in the rigid body CS of segment \# j and the coordinates of $\bO$ ([[B0]]) in the GCS:
<<lateral edge sensors setup>>=
camera_coordinates LLL gridDim, blockDim RRR (d__B, d__B0, mirror->N-1, 
                                              mirror->D_full, alpha, height,
					      mirror->rigid_body_CS.d__R,
					      mirror->rigid_body_CS.d__origin);
HANDLE_ERROR( cudaMemcpy(B , d__B, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemcpy(B0 , d__B0, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@ with
<<lateral edge sensors: camera coordinates kernel>>=
__global__ void camera_coordinates(vector *v, vector *v0,
                                   const int N_OUT_SEGMENT, 
				   const rtd D, 
				   const rtd alpha,
				   const rtd height,
				   rtd *d__rigid_body_R,
                                   vector *d__rigid_body_origin)
{
  int i, j, k;
  rtd R, a, offset_angle;
  i = threadIdx.x;
  j = threadIdx.y;
  if (i<N_OUT_SEGMENT)
  {
    R = 0.5*D;
    a = alpha/180;
    <<central segment camera edge sensors>>
    __syncthreads();
    <<outer segment camera edge sensors>>
  }
}
@ $r_{k,4}$ and $l_{k,4}$:
<<central segment camera edge sensors>>=
k = i + 24*j;
offset_angle = -0.5 - a;
<<from rigid body CS to GCS>>
k += N_OUT_SEGMENT;
offset_angle = -0.5 + a;
<<from rigid body CS to GCS>>
@ $r_{k,5},$ and $l_{k,5}$:
<<outer segment camera edge sensors>>=
k = 2*N_OUT_SEGMENT + i + 24*j;
offset_angle = -5.0/6.0 - a;
<<from rigid body CS to GCS>>
k += N_OUT_SEGMENT;
offset_angle = -5.0/6.0 + a;
<<from rigid body CS to GCS>>
@ 
<<from rigid body CS to GCS>>=
<<polar to cartesian>>
v[k].z      *= (j==0) ? -1 : 1; 
// RIGID_BODY <<<
backward_transform(v0+k, v+k,
		   d__rigid_body_R+i*9,
		   d__rigid_body_origin+i);
@
  \item Lets define the vector of the line of sight expressed in the rigid body CS of segment \# $j$ as:
    \begin{equation}
      \label{eq:13}
      \kOj = \abOj,
    \end{equation}
  \item Lets define the plane $\camplane$ perpendicular to the vector $\kOj$ and including the point $\bOj$ in the rigid body CS of segment $j$:
    \begin{equation}
      \label{eq:14}
      \camplane:\quad \abOjx \left( x - \bOjx \right) + \abOjy \left( y - \bOjy \right) +  \abOjz \left( z - \bOjz \right) = 0,
    \end{equation}
  \item Lets define the origin of coordinates in $\camplane$ at $\bOj$,
  \item Lets define the $x$--axis of $\camplane$ to be in the horizontal plane $\mathcal{Z}_j: z=0$ of the rigid body CS of segment \# j and to include the point $\bOj$,
  \item The unit vector normal to the plane $\mathcal{Z}_j$ is $\mathbf{n}_j=(0,0,1)$,
  \item The vector parallel to the line that defines the intersection between $\camplane$ and $\mathcal{Z}_j$ is given by $\valpha=\mathbf{n}\wedge\kOj$,
  \item The unit $x$--axis vector in $\camplane$ is given by
    \begin{equation}
      \label{eq:15}
      \mathbf{u} = { \valpha \over \left\| \valpha \right\| },
    \end{equation}
  \item Lets define the vector perpendicular to both $\kOj$ and $\valpha$: $\vbeta = \valpha \wedge \kOj$, the vector $\vbeta$ lies in the plane $\camplane$,
  \item The unit $y$--axis vector in $\camplane$ is given by
    \begin{equation}
      \label{eq:16}
      \mathbf{v} = { \vbeta \over \left\| \vbeta \right\| },
    \end{equation}
<<lateral edge sensors setup>>=
edge_sensors_camera_vector_kernel LLL gridDim, blockDim RRR (d__k_cam, d__A, d__B,
                                                           d__uP, d__vP,
                                                           mirror->N-1);
HANDLE_ERROR( cudaMemcpy(k_cam , d__k_cam, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@ with the kernel
<<lateral edge sensor camera vector kernel>>=
__global__ void edge_sensors_camera_vector_kernel(vector *d__k, 
                                                vector *d__A, vector*d__B,
                                                vector *d__uP, vector *d__vP,
                                                const int N_OUT_SEGMENT)
{
  int i, j, k;
  i = threadIdx.x;
  j = 24*threadIdx.y;
  vector n;
  n.x = n.y = 0.0;
  n.z = 1.0;
  if (i<N_OUT_SEGMENT)
    {
      k = i + j;
      d__k[k] = d__B[k] - d__A[k];      
      <<u and v derivation>>

      k += N_OUT_SEGMENT;
      d__k[k] =	d__B[k] - d__A[k];
      <<u and v derivation>>

      __syncthreads();

      k = 2*N_OUT_SEGMENT + i + j;
      d__k[k] =	d__B[k-i+(i+1)%6] - d__A[k];
      <<u and v derivation>>

      k += N_OUT_SEGMENT;
      d__k[k] =	d__B[k-i+(i+1)%6] - d__A[k];
      <<u and v derivation>>
    }
}
@ where
<<u and v derivation>>=
d__k[k].left_cross(&d__uP[k],&n);
d__uP[k].unit();
d__uP[k].left_cross(&d__vP[k], &d__k[k]);
d__vP[k].unit();
@ 
  \end{enumerate}
\end{enumerate}

The next step consists in deriving, for given displacements of segment \# $i$ and \# $j$, the intersection of the vector $\kOj$ with the plane $\camplane$:
\begin{enumerate}
\item Lets transform $\kOj$ into the motion CS of segment \# $i$ and back to the motion CS of segment \# $j$:
  \begin{equation}
    \label{eq:50}
    \kj = \tocs{M}{j}{\tocs{R}{j}{\itocs{R}{i}{\itocs{M}{i}{\tocs{R}{i}{\itocs{R}{j}{\kOj}}}}}}.
  \end{equation}
<<lateral edge sensors measurements>>=
dim3 blockDim(6,N_HEIGHT);
dim3 gridDim(1,1);
edge_sensors_laser_vector_kernel LLL gridDim, blockDim RRR (d__k_laser, d__k_cam, 
                                                            mirror->N-1,
							    mirror->rigid_body_CS.d__R,
							    mirror->motion_CS.d__R);
HANDLE_ERROR( cudaMemcpy(k_laser , d__k_laser, 
                          N_DATA*sizeof(vector), cudaMemcpyDeviceToHost ) );
@ with the kernel
<<lateral edge sensor laser vector kernel>>=
__global__ void edge_sensors_laser_vector_kernel(vector *d__k_laser, 
                                                vector *d__k_cam,
                                                const int N_OUT_SEGMENT,
						 rtd *d__rigid_body_R,
						 rtd *d__motion_R)
{
  int i, j, iCoordSys_laser, iCoordSys_cam, k;
  i = threadIdx.x;
  j = 24*threadIdx.y;
  if (i<N_OUT_SEGMENT)
  {
    iCoordSys_laser = 6;
    iCoordSys_cam   = i;
    k = i + j;
    <<from camera rigid body CS to camera motion CS through laser motion CS>>
    k             += N_OUT_SEGMENT;
    <<from camera rigid body CS to camera motion CS through laser motion CS>>
    __syncthreads();
    iCoordSys_laser = i;
    iCoordSys_cam   = (i+1)%N_OUT_SEGMENT;
    k = 2*N_OUT_SEGMENT + i + j;
    <<from camera rigid body CS to camera motion CS through laser motion CS>>
    k             += N_OUT_SEGMENT;
    <<from camera rigid body CS to camera motion CS through laser motion CS>>
  }
}
@ where
<<from camera rigid body CS to camera motion CS through laser motion CS>>=
// RIGID_BODY <<<
backward_transform_centered(d__k_laser+k, d__k_cam+k,
			    d__rigid_body_R+iCoordSys_cam*9);
// RIGID BODY >>> 
forward_transform_centered(d__k_laser+k, d__k_laser+k,
			   d__rigid_body_R+iCoordSys_laser*9);    
// MOTION <<<
backward_transform_centered(d__k_laser+k, d__k_laser+k,
			    d__motion_R+iCoordSys_laser*9);
// RIGID_BODY <<<
backward_transform_centered(d__k_laser+k, d__k_laser+k,
			    d__rigid_body_R+iCoordSys_laser*9);
// RIGID BODY >>> 
forward_transform_centered(d__k_laser+k, d__k_laser+k,
			   d__rigid_body_R+iCoordSys_cam*9);
// MOTION >>>  
forward_transform_centered(d__k_laser+k, d__k_laser+k,
			   d__motion_R+iCoordSys_cam*9);
@
\item Lets transform $\aOj$ into the motion CS of segment \# j
  \begin{equation}
    \label{eq:51}
    \aj = \tocs{M}{j}{\tocs{R}{j}{\itocs{R}{i}{\itocs{M}{i}{\aOi}}}}
  \end{equation}
<<lateral edge sensors measurements>>=
laser_coordinates LLL gridDim, blockDim RRR (d__A, mirror->N-1, mirror->D_full, 
					     alpha, height,
					     mirror->rigid_body_CS.d__R,
                                             mirror->rigid_body_CS.d__origin,
                                             mirror->motion_CS.d__R,
                                             mirror->motion_CS.d__origin);
int n_byte_DATA;
n_byte_DATA = sizeof(vector)*N_DATA;
HANDLE_ERROR( cudaMemcpy( A, d__A, 
                          n_byte_DATA, cudaMemcpyDeviceToHost ) );
@
\item Lets define the line $\mathcal{L}_j$ with the equation: $\forall t \in [-\infty,+\infty]$,
  \begin{eqnarray}
    \label{eq:10a}
    x &=& \kjx t + \ajx, \\
    \label{eq:10b}
    y &=& \kjy t + \ajy, \\
    \label{eq:10c}
    z &=& \kjz t + \ajz,
  \end{eqnarray}
\item Inserting Eq.~(\ref{eq:10a}), Eq.~(\ref{eq:10b}) and Eq.~(\ref{eq:10c}) into Eq.~(\ref{eq:14}) and solving for $t$ leads to
  \begin{equation}
    \label{eq:19}
    \tlp = {\abOjx ( \bOjx - \ajx ) + \abOjy ( \bOjy - \ajy ) + \abOjz ( \bOjz - \ajz ) \over \kjx\abOjx + \kjz\abOjz + \kjz\abOjz},
  \end{equation}
\item Inserting $\tlp$ back into Eq.~(\ref{eq:10a}), Eq.~(\ref{eq:10b}) and Eq.~(\ref{eq:10c}) gives the point of intersection $\ilp$ between $\mathcal{L}_j$ and $\camplane$.
\item the $x_j$ and $y_j$ coordinates of the laser location in the plane $\camplane$ are
  \begin{eqnarray}
    \label{eq:20}
    x_j &=& \bi \cdot \mathbf{u}, \\
    y_j &=& \bi \cdot \mathbf{v}.
  \end{eqnarray}
<<lateral edge sensors measurements>>=
laser_camera_intersection LLL gridDim, blockDim RRR (d__x, d__y, d__d,
						     d__B, d__A,
						     d__k_cam, d__k_laser,
						     d__uP, d__vP,
						     mirror->N-1);
HANDLE_ERROR( cudaMemcpy( x, d__x, 
                          sizeof(rtd)*N_DATA, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemcpy( y, d__y, 
                          sizeof(rtd)*N_DATA, cudaMemcpyDeviceToHost ) );
HANDLE_ERROR( cudaMemcpy( d, d__d, 
                          sizeof(rtd)*N_DATA, cudaMemcpyDeviceToHost ) );
@
with
<<laser camera intersection kernel>>=
  __global__ void laser_camera_intersection(rtd *x, rtd *y, rtd *d,
					  vector *B, vector *A,
					  vector *k_cam, vector *k_laser,
					  vector *uP, vector *vP,
					  const int N_OUT_SEGMENT)
{
  int i, j, i_cam, i_laser;
  rtd t;
  vector w, Ilp;
  i = threadIdx.x;
  j = 24*threadIdx.y;
  if (i<N_OUT_SEGMENT)
    {
      i_cam = i_laser = i + j;
      <<laser intersection coordinates>>

      i_cam   += N_OUT_SEGMENT;
      i_laser += N_OUT_SEGMENT;
      <<laser intersection coordinates>>

      __syncthreads();

      i_cam   = 2*N_OUT_SEGMENT + (i+1)%6 + j; 
      i_laser = 2*N_OUT_SEGMENT + i + j;
      <<laser intersection coordinates>>

      i_cam   += N_OUT_SEGMENT;
      i_laser += N_OUT_SEGMENT;
      <<laser intersection coordinates>>
    }  
}
@ where
<<laser intersection coordinates>>=
w          = B[i_cam] - A[i_laser];
d[i_laser] = w.norm();
t          = (k_cam[i_cam]*w)/(k_cam[i_cam]*k_laser[i_laser]);
Ilp        = k_laser[i_laser]*t + A[i_laser];
w          = Ilp - B[i_cam];
x[i_cam]   = w*uP[i_cam];
y[i_cam]   = w*vP[i_cam];
@
\end{enumerate}
@
\section{GMT M2}
\label{sec:gmt-m2}

\index{gmtMirrors!gmt\_m2}
A new structure to hold GMT M1 parameters and functions is defined.
<<GMT M2 structure>>=
struct gmt_m2 {
  <<GMT M12 parameters>>
  <<GMT M12 functions>>
  void pointing_neutral(float tip, float tilt);
  void coma_neutral(float tip, float tilt);
};
@
\subsection{Setup \& Cleanup}
\label{sec:setup--cleanup-2}

\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_)
{
  <<M2 parameters>>
  <<GMT setup common>>
}
@ with
<<M2 parameters>>=
 M_ID    = 2;
 D_px    = _D_px_;
 D       = _D_;
 D_assembly = 3.168;
 D_full  = 1.0425*1.005; // slightly larger to always encompass M1; needed for the Zernike
 D_clear = 1.0415;
 ri      = 0.0;
 beta    = -14.777462*PI/180.0;
 L       = 1.08774;
 N       = 7;
 conic_c = -1.0/4.1639009;
 conic_k = 1-0.71692784;
 height  = 20.26247614;
 idx_offset = 3;
@  
If an array of sources is propagated through the telescope then
\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, int N_SRC)
{
  ZS = NULL;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
\index{gmtMirrors!gmt\_m2!setup}
<<GMT M2 functions>>=
void gmt_m2::setup(float _D_, int _D_px_, zernikeS *_ZS_, int N_SRC)
{
  ZS = _ZS_;
  M_ID    = 2;
  <<M2 parameters>>
  <<GMT setup common>>
}
@ 
Memory is freed with
\index{gmtMirrors!gmt\_m2!cleanup}
<<GMT M2 functions>>=
void gmt_m2::cleanup(void)
{
  fprintf(stdout,"@(CEO)>gmt_m2: freeing memory!\n");
  <<GMT cleanup common>>
}
@
\subsection{Blocking}
\label{sec:blocking-2}

The rays blocking with M2 is computed with
\index{gmtMirrors!gmt\_m2!blocking}
<<GMT M2 functions>>=
void gmt_m2::blocking(bundle *rays)
{
  <<GMT blocking common>>
}
@
\subsection{Ray tracing}
\label{sec:ray-tracing-2}

The rays propagation through M1 is computed with
\index{gmtMirrors!gmt\_m2!trace}
<<GMT M2 functions>>=
void gmt_m2::trace(bundle *rays)
{ 
  <<GMT trace common>>
}
@
The rigid body motion parameters are updated with:
\index{gmtMirrors!gmt\_m2!update}
<<GMT M2 functions>>=
void gmt_m2::update(vector _origin_, vector _euler_angles_,int idx)
{
    <<GMT M12 update>>
}
@ 
The rigid body motion are reset to 0 with:
\index{gmtMirrors!gmt\_m2!reset}
<<GMT M2 functions>>=
void gmt_m2::reset(void)
{
    <<GMT M12 reset>>
}
@
\subsection{Global motions}
\label{sec:global-motions}

\subsection{Global tip--tilt}
\label{sec:global-tip-tilt-1}

\index{gmtMirrors!gmt\_m2!global\_tiptilt}
<<GMT M2 functions>>=
void gmt_m2::global_tiptilt(float tip, float tilt)
{
  <<GMT global tip-tilt common>>
}    
@
\subsubsection{Tip--tilt neutral}
\label{sec:tip-tilt-neutral}

\index{gmtMirrors!gmt\_m2!pointing\_neutral}
<<GMT M2 functions>>=
void gmt_m2::pointing_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height - 4390.312E-03;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@
\subsubsection{Coma neutral}
\label{sec:coma-neutral}

\index{gmtMirrors!gmt\_m2!coma\_neutral}
<<GMT M2 functions>>=
void gmt_m2::coma_neutral(float tip, float tilt)
{
  double alpha, beta, *d__C;
  vector origin, euler_angles;
  cublasHandle_t handle;
  coordinate_system TT_CS;

  origin.x = origin.y = 0.0;
  origin.z = height - 2246.410E-03;
  euler_angles.x = tip;
  euler_angles.y = tilt;
  euler_angles.z = 0.0;

  TT_CS.setup(origin, euler_angles);
  cublasCreate(&handle);

  alpha = 1;
  beta  = 0;
  HANDLE_ERROR( cudaMalloc((void**)&d__C, sizeof(double)*9 ) );
  int k, k9;
  for (k=0;k<N;k++)
    {
      k9 = k*9;
      <<global tip-tilt transformation>>
    }

  cublasDestroy(handle);
  TT_CS.cleanup();
  HANDLE_ERROR( cudaFree( d__C ) );
}
@

